/*!
 * Bootstrap v3.3.4 (http://getbootstrap.com)
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 */

/*!
 * Generated using the Bootstrap Customizer (http://getbootstrap.com/customize/?id=dd258d9a9ddb9b37c7ee)
 * Config saved to config.json and https://gist.github.com/dd258d9a9ddb9b37c7ee
 */
if("undefined"==typeof jQuery)throw new Error("Bootstrap's JavaScript requires jQuery");+function(t){"use strict";var e=t.fn.jquery.split(" ")[0].split(".");if(e[0]<2&&e[1]<9||1==e[0]&&9==e[1]&&e[2]<1)throw new Error("Bootstrap's JavaScript requires jQuery version 1.9.1 or higher")}(jQuery),+function(t){"use strict";function e(e,o){return this.each(function(){var s=t(this),n=s.data("bs.modal"),r=t.extend({},i.DEFAULTS,s.data(),"object"==typeof e&&e);n||s.data("bs.modal",n=new i(this,r)),"string"==typeof e?n[e](o):r.show&&n.show(o)})}var i=function(e,i){this.options=i,this.$body=t(document.body),this.$element=t(e),this.$dialog=this.$element.find(".modal-dialog"),this.$backdrop=null,this.isShown=null,this.originalBodyPad=null,this.scrollbarWidth=0,this.ignoreBackdropClick=!1,this.options.remote&&this.$element.find(".modal-content").load(this.options.remote,t.proxy(function(){this.$element.trigger("loaded.bs.modal")},this))};i.VERSION="3.3.4",i.TRANSITION_DURATION=300,i.BACKDROP_TRANSITION_DURATION=150,i.DEFAULTS={backdrop:!0,keyboard:!0,show:!0},i.prototype.toggle=function(t){return this.isShown?this.hide():this.show(t)},i.prototype.show=function(e){var o=this,s=t.Event("show.bs.modal",{relatedTarget:e});this.$element.trigger(s),this.isShown||s.isDefaultPrevented()||(this.isShown=!0,this.checkScrollbar(),this.setScrollbar(),this.$body.addClass("modal-open"),this.escape(),this.resize(),this.$element.on("click.dismiss.bs.modal",'[data-dismiss="modal"]',t.proxy(this.hide,this)),this.$dialog.on("mousedown.dismiss.bs.modal",function(){o.$element.one("mouseup.dismiss.bs.modal",function(e){t(e.target).is(o.$element)&&(o.ignoreBackdropClick=!0)})}),this.backdrop(function(){var s=t.support.transition&&o.$element.hasClass("fade");o.$element.parent().length||o.$element.appendTo(o.$body),o.$element.show().scrollTop(0),o.adjustDialog(),s&&o.$element[0].offsetWidth,o.$element.addClass("in").attr("aria-hidden",!1),o.enforceFocus();var n=t.Event("shown.bs.modal",{relatedTarget:e});s?o.$dialog.one("bsTransitionEnd",function(){o.$element.trigger("focus").trigger(n)}).emulateTransitionEnd(i.TRANSITION_DURATION):o.$element.trigger("focus").trigger(n)}))},i.prototype.hide=function(e){e&&e.preventDefault(),e=t.Event("hide.bs.modal"),this.$element.trigger(e),this.isShown&&!e.isDefaultPrevented()&&(this.isShown=!1,this.escape(),this.resize(),t(document).off("focusin.bs.modal"),this.$element.removeClass("in").attr("aria-hidden",!0).off("click.dismiss.bs.modal").off("mouseup.dismiss.bs.modal"),this.$dialog.off("mousedown.dismiss.bs.modal"),t.support.transition&&this.$element.hasClass("fade")?this.$element.one("bsTransitionEnd",t.proxy(this.hideModal,this)).emulateTransitionEnd(i.TRANSITION_DURATION):this.hideModal())},i.prototype.enforceFocus=function(){t(document).off("focusin.bs.modal").on("focusin.bs.modal",t.proxy(function(t){this.$element[0]===t.target||this.$element.has(t.target).length||this.$element.trigger("focus")},this))},i.prototype.escape=function(){this.isShown&&this.options.keyboard?this.$element.on("keydown.dismiss.bs.modal",t.proxy(function(t){27==t.which&&this.hide()},this)):this.isShown||this.$element.off("keydown.dismiss.bs.modal")},i.prototype.resize=function(){this.isShown?t(window).on("resize.bs.modal",t.proxy(this.handleUpdate,this)):t(window).off("resize.bs.modal")},i.prototype.hideModal=function(){var t=this;this.$element.hide(),this.backdrop(function(){t.$body.removeClass("modal-open"),t.resetAdjustments(),t.resetScrollbar(),t.$element.trigger("hidden.bs.modal")})},i.prototype.removeBackdrop=function(){this.$backdrop&&this.$backdrop.remove(),this.$backdrop=null},i.prototype.backdrop=function(e){var o=this,s=this.$element.hasClass("fade")?"fade":"";if(this.isShown&&this.options.backdrop){var n=t.support.transition&&s;if(this.$backdrop=t('<div class="modal-backdrop '+s+'" />').appendTo(this.$body),this.$element.on("click.dismiss.bs.modal",t.proxy(function(t){return this.ignoreBackdropClick?void(this.ignoreBackdropClick=!1):void(t.target===t.currentTarget&&("static"==this.options.backdrop?this.$element[0].focus():this.hide()))},this)),n&&this.$backdrop[0].offsetWidth,this.$backdrop.addClass("in"),!e)return;n?this.$backdrop.one("bsTransitionEnd",e).emulateTransitionEnd(i.BACKDROP_TRANSITION_DURATION):e()}else if(!this.isShown&&this.$backdrop){this.$backdrop.removeClass("in");var r=function(){o.removeBackdrop(),e&&e()};t.support.transition&&this.$element.hasClass("fade")?this.$backdrop.one("bsTransitionEnd",r).emulateTransitionEnd(i.BACKDROP_TRANSITION_DURATION):r()}else e&&e()},i.prototype.handleUpdate=function(){this.adjustDialog()},i.prototype.adjustDialog=function(){var t=this.$element[0].scrollHeight>document.documentElement.clientHeight;this.$element.css({paddingLeft:!this.bodyIsOverflowing&&t?this.scrollbarWidth:"",paddingRight:this.bodyIsOverflowing&&!t?this.scrollbarWidth:""})},i.prototype.resetAdjustments=function(){this.$element.css({paddingLeft:"",paddingRight:""})},i.prototype.checkScrollbar=function(){var t=window.innerWidth;if(!t){var e=document.documentElement.getBoundingClientRect();t=e.right-Math.abs(e.left)}this.bodyIsOverflowing=document.body.clientWidth<t,this.scrollbarWidth=this.measureScrollbar()},i.prototype.setScrollbar=function(){var t=parseInt(this.$body.css("padding-right")||0,10);this.originalBodyPad=document.body.style.paddingRight||"",this.bodyIsOverflowing&&this.$body.css("padding-right",t+this.scrollbarWidth)},i.prototype.resetScrollbar=function(){this.$body.css("padding-right",this.originalBodyPad)},i.prototype.measureScrollbar=function(){var t=document.createElement("div");t.className="modal-scrollbar-measure",this.$body.append(t);var e=t.offsetWidth-t.clientWidth;return this.$body[0].removeChild(t),e};var o=t.fn.modal;t.fn.modal=e,t.fn.modal.Constructor=i,t.fn.modal.noConflict=function(){return t.fn.modal=o,this},t(document).on("click.bs.modal.data-api",'[data-toggle="modal"]',function(i){var o=t(this),s=o.attr("href"),n=t(o.attr("data-target")||s&&s.replace(/.*(?=#[^\s]+$)/,"")),r=n.data("bs.modal")?"toggle":t.extend({remote:!/#/.test(s)&&s},n.data(),o.data());o.is("a")&&i.preventDefault(),n.one("show.bs.modal",function(t){t.isDefaultPrevented()||n.one("hidden.bs.modal",function(){o.is(":visible")&&o.trigger("focus")})}),e.call(n,r,this)})}(jQuery);
//  angularModalService.js
//
//  Service for showing modal dialogs.

/***** JSLint Config *****/
/*global angular  */
(function() {

  'use strict';

  var module = angular.module('angularModalService', []);

  module.factory('ModalService', ['$document', '$compile', '$controller', '$http', '$rootScope', '$q', '$templateCache','$window','$timeout',
    function($document, $compile, $controller, $http, $rootScope, $q, $templateCache, $window, $timeout) {

    //  Get the body of the document, we'll add the modal to this.
    var body = $document.find('body');
    function addModalOpen(){
      $('html').addClass('modal-open');
    }
    function removeModalOpen(){
      $('html').removeClass('modal-open');
    }
    function ModalService() {

      var self = this;

      //  Returns a promise which gets the template, either
      //  from the template parameter or via a request to the
      //  template url parameter.
      var getTemplate = function(template, templateUrl) {
        var deferred = $q.defer();
        if(template) {
          deferred.resolve(template);
          addModalOpen();
        } else if(templateUrl) {
          // check to see if the template has already been loaded
          var cachedTemplate = $templateCache.get(templateUrl);
          if(cachedTemplate !== undefined) {
            deferred.resolve(cachedTemplate);
            addModalOpen();
          }
          // if not, let's grab the template for the first time
          else {
            $http({method: 'GET', url: templateUrl, cache: true})
              .then(function(result) {
                // save template into the cache and return the template
                $templateCache.put(templateUrl, result.data);
                deferred.resolve(result.data);
                addModalOpen();
              }, function(error) {
                deferred.reject(error);
              });
          }
        } else {
          deferred.reject("No template or templateUrl has been specified.");
        }
        return deferred.promise;
      };
	  
	  var reposition = function(modalObj){
		  if(modalObj){
			  var dialog = modalObj.find('.modal-dialog');
			  modalObj.css('display', 'block');
			  dialog.css("margin-top", Math.max(0, ($(window).height() - dialog.height()) / 2));
		  }
	  };

      self.showModal = function(options) {

        //  Create a deferred we'll resolve when the modal is ready.
        var deferred = $q.defer();

        //  Validate the input parameters.
        var controllerName = options.controller;
        if(!controllerName) {
          deferred.reject("No controller has been specified.");
          return deferred.promise;
        }

        //  If a 'controllerAs' option has been provided, we change the controller
        //  name to use 'as' syntax. $controller will automatically handle this.
        if(options.controllerAs) {
          controllerName = controllerName + " as " + options.controllerAs;
        }

        //  Get the actual html of the template.
        getTemplate(options.template, options.templateUrl)
          .then(function(template) {

            //  Create a new scope for the modal.
            var modalScope = $rootScope.$new();

            //  Create the inputs object to the controller - this will include
            //  the scope, as well as all inputs provided.
            //  We will also create a deferred that is resolved with a provided
            //  close function. The controller can then call 'close(result)'.
            //  The controller can also provide a delay for closing - this is
            //  helpful if there are closing animations which must finish first.
            var closeDeferred = $q.defer();
            var inputs = {
              $scope: modalScope,
              close: function(result, delay) {
                if(delay === undefined || delay === null) delay = 0;
                window.setTimeout(function() {
                  //  Resolve the 'close' promise.
                  closeDeferred.resolve(result);

                  //  We can now clean up the scope and remove the element from the DOM.
                  modalScope.$destroy();
                  modalElement.remove();

                  removeModalOpen();
                  
                  //  Unless we null out all of these objects we seem to suffer
                  //  from memory leaks, if anyone can explain why then I'd 
                  //  be very interested to know.
                  inputs.close = null;
                  deferred = null;
                  closeDeferred = null;
                  modal = null;
                  inputs = null;
                  modalElement = null;
                  modalScope = null;
                }, delay);
              }
            };

            //  If we have provided any inputs, pass them to the controller.
            if(options.inputs) {
              for(var inputName in options.inputs) {
                inputs[inputName] = options.inputs[inputName];
              }
            }

            //  Parse the modal HTML into a DOM element (in template form).
            var modalElementTemplate = angular.element(template);

            //  Compile then link the template element, building the actual element.
            //  Set the $element on the inputs so that it can be injected if required.
            var linkFn = $compile(modalElementTemplate);
            var modalElement = linkFn(modalScope);
            inputs.$element = modalElement;

            //  Create the controller, explicitly specifying the scope to use.
            var modalController = $controller(controllerName, inputs);

            //  Finally, append the modal to the dom.
            if (options.appendElement) {
              // append to custom append element
              options.appendElement.append(modalElement);
            } else {
              // append to body when no custom append element is specified
              body.append(modalElement);
            }
			
			$timeout(function(){
				reposition(modalElement); //Reposition modal to vertically centre
			},200);
			
			$window.onresize = function() {
		  		reposition(modalElement); //Reposition modal to vertically centre
			}

            //  We now have a modal object...
            var modal = {
              controller: modalController,
              scope: modalScope,
              element: modalElement,
              close: closeDeferred.promise
            };

            //  ...which is passed to the caller via the promise.
            deferred.resolve(modal);

          })
          .then(null, function(error) { // 'catch' doesn't work in IE8.
            deferred.reject(error);
          });

        return deferred.promise;
      };

    }

    return new ModalService();
  }]);

}());
angular.module('modalPopupMod', [])
.directive('modalPopup', function() {
    return {
        restrict: 'E',
        transclude: true,
        replace:true,
        scope: {
            size: '@',
            title:'@',
            buttonTitle:'@',
            backbutton:'@',
            id:'@',
            onback:'&'
        },
        //template:'Helo helo',
        templateUrl: "/vmf/m/components/modal/modalTemplate.tpl.html",
        link: function(scope, elem) {
            scope.$watch("modalShown", function(newValue, OldValue, scope) {
                //alert(scope.modalShown);
                if (scope.modalShown) {
                    angular.element('html').addClass('modal-open');
                    angular.element('.modalLoad .modal').addClass('in');
                 } else {
                    angular.element('html').removeClass('modal-open');
                    angular.element('.modalLoad .modal').removeClass('in');
                }
            });

            scope.hideModal = function() {
                //console.log(scope.modalSize);
                //console.log('hide/show');  
                scope.modalShown = false;
            };

            scope.primaryBtn = function() {
                //console.log(scope.modalSize);
                //console.log('primaryBtn');
            };

            scope.test = function($event) {
                // console.log($event.which);
                if($event.which === 27) {
                    scope.modalShown = false;
                    elem.find('.modal-backdrop').hide();
                }
            };
            elem.find('.modal-backdrop').show();
        }
    };
});
/****** JQUERY DATATABLES *******/
/*! DataTables 1.10.2
 * ©2008-2014 SpryMedia Ltd - datatables.net/license
 */

/**
 * @summary     DataTables
 * @description Paginate, search and order HTML tables
 * @version     1.10.2
 * @file        jquery.dataTables.js
 * @author      SpryMedia Ltd (www.sprymedia.co.uk)
 * @contact     www.sprymedia.co.uk/contact
 * @copyright   Copyright 2008-2014 SpryMedia Ltd.
 *
 * This source file is free software, available under the following license:
 *   MIT license - http://datatables.net/license
 *
 * This source file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.
 *
 * For details please refer to: http://www.datatables.net
 */

/*jslint evil: true, undef: true, browser: true */
/*globals $,require,jQuery,define,_selector_run,_selector_opts,_selector_first,_selector_row_indexes,_ext,_Api,_api_register,_api_registerPlural,_re_new_lines,_re_html,_re_formatted_numeric,_re_escape_regex,_empty,_intVal,_numToDecimal,_isNumber,_isHtml,_htmlNumeric,_pluck,_pluck_order,_range,_stripHtml,_unique,_fnBuildAjax,_fnAjaxUpdate,_fnAjaxParameters,_fnAjaxUpdateDraw,_fnAjaxDataSrc,_fnAddColumn,_fnColumnOptions,_fnAdjustColumnSizing,_fnVisibleToColumnIndex,_fnColumnIndexToVisible,_fnVisbleColumns,_fnGetColumns,_fnColumnTypes,_fnApplyColumnDefs,_fnHungarianMap,_fnCamelToHungarian,_fnLanguageCompat,_fnBrowserDetect,_fnAddData,_fnAddTr,_fnNodeToDataIndex,_fnNodeToColumnIndex,_fnGetCellData,_fnSetCellData,_fnSplitObjNotation,_fnGetObjectDataFn,_fnSetObjectDataFn,_fnGetDataMaster,_fnClearTable,_fnDeleteIndex,_fnInvalidateRow,_fnGetRowElements,_fnCreateTr,_fnBuildHead,_fnDrawHead,_fnDraw,_fnReDraw,_fnAddOptionsHtml,_fnDetectHeader,_fnGetUniqueThs,_fnFeatureHtmlFilter,_fnFilterComplete,_fnFilterCustom,_fnFilterColumn,_fnFilter,_fnFilterCreateSearch,_fnEscapeRegex,_fnFilterData,_fnFeatureHtmlInfo,_fnUpdateInfo,_fnInfoMacros,_fnInitialise,_fnInitComplete,_fnLengthChange,_fnFeatureHtmlLength,_fnFeatureHtmlPaginate,_fnPageChange,_fnFeatureHtmlProcessing,_fnProcessingDisplay,_fnFeatureHtmlTable,_fnScrollDraw,_fnApplyToChildren,_fnCalculateColumnWidths,_fnThrottle,_fnConvertToWidth,_fnScrollingWidthAdjust,_fnGetWidestNode,_fnGetMaxLenString,_fnStringToCss,_fnScrollBarWidth,_fnSortFlatten,_fnSort,_fnSortAria,_fnSortListener,_fnSortAttachListener,_fnSortingClasses,_fnSortData,_fnSaveState,_fnLoadState,_fnSettingsFromNode,_fnLog,_fnMap,_fnBindAction,_fnCallbackReg,_fnCallbackFire,_fnLengthOverflow,_fnRenderer,_fnDataSource,_fnRowAttributes*/

(/** @lends <global> */function( window, document, undefined ) {

(function( factory ) {
  "use strict";

  // if ( typeof define === 'function' && define.amd ) {
  //   // Define as an AMD module if possible
  //   define( 'datatables', ['jquery'], factory );
  // }
  //   else 
  if ( typeof exports === 'object' ) {
        // Node/CommonJS
        factory( require( 'jquery' ) );
    }
  else if ( jQuery && !jQuery.fn.dataTable ) {
    // Define using browser globals otherwise
    // Prevent multiple instantiations if the script is loaded twice
    factory( jQuery );
  }
}
(/** @lends <global> */function( $ ) {
  "use strict";

  /**
   * DataTables is a plug-in for the jQuery Javascript library. It is a highly
   * flexible tool, based upon the foundations of progressive enhancement,
   * which will add advanced interaction controls to any HTML table. For a
   * full list of features please refer to
   * [DataTables.net](href="http://datatables.net).
   *
   * Note that the `DataTable` object is not a global variable but is aliased
   * to `jQuery.fn.DataTable` and `jQuery.fn.dataTable` through which it may
   * be  accessed.
   *
   *  @class
   *  @param {object} [init={}] Configuration object for DataTables. Options
   *    are defined by {@link DataTable.defaults}
   *  @requires jQuery 1.7+
   *
   *  @example
   *    // Basic initialisation
   *    $(document).ready( function {
   *      $('#example').dataTable();
   *    } );
   *
   *  @example
   *    // Initialisation with configuration options - in this case, disable
   *    // pagination and sorting.
   *    $(document).ready( function {
   *      $('#example').dataTable( {
   *        "paginate": false,
   *        "sort": false
   *      } );
   *    } );
   */
  var DataTable;

  
  /*
   * It is useful to have variables which are scoped locally so only the
   * DataTables functions can access them and they don't leak into global space.
   * At the same time these functions are often useful over multiple files in the
   * core and API, so we list, or at least document, all variables which are used
   * by DataTables as private variables here. This also ensures that there is no
   * clashing of variable names and that they can easily referenced for reuse.
   */
  
  
  // Defined else where
  //  _selector_run
  //  _selector_opts
  //  _selector_first
  //  _selector_row_indexes
  
  var _ext; // DataTable.ext
  var _Api; // DataTable.Api
  var _api_register; // DataTable.Api.register
  var _api_registerPlural; // DataTable.Api.registerPlural
  
  var _re_dic = {};
  var _re_new_lines = /[\r\n]/g;
  var _re_html = /<.*?>/g;
  var _re_date_start = /^[\w\+\-]/;
  var _re_date_end = /[\w\+\-]$/;
  
  // Escape regular expression special characters
  var _re_escape_regex = new RegExp( '(\\' + [ '/', '.', '*', '+', '?', '|', '(', ')', '[', ']', '{', '}', '\\', '$', '^', '-' ].join('|\\') + ')', 'g' );
  
  // U+2009 is thin space and U+202F is narrow no-break space, both used in many
  // standards as thousands separators
  var _re_formatted_numeric = /[',$£€¥%\u2009\u202F]/g;
  
  
  var _empty = function ( d ) {
    return !d || d === true || d === '-' ? true : false;
  };
  
  
  var _intVal = function ( s ) {
    var integer = parseInt( s, 10 );
    return !isNaN(integer) && isFinite(s) ? integer : null;
  };
  
  // Convert from a formatted number with characters other than `.` as the
  // decimal place, to a Javascript number
  var _numToDecimal = function ( num, decimalPoint ) {
    // Cache created regular expressions for speed as this function is called often
    if ( ! _re_dic[ decimalPoint ] ) {
      _re_dic[ decimalPoint ] = new RegExp( _fnEscapeRegex( decimalPoint ), 'g' );
    }
    return typeof num === 'string' ?
      num.replace( /\./g, '' ).replace( _re_dic[ decimalPoint ], '.' ) :
      num;
  };
  
  
  var _isNumber = function ( d, decimalPoint, formatted ) {
    var strType = typeof d === 'string';
  
    if ( decimalPoint && strType ) {
      d = _numToDecimal( d, decimalPoint );
    }
  
    if ( formatted && strType ) {
      d = d.replace( _re_formatted_numeric, '' );
    }
  
    return _empty( d ) || (!isNaN( parseFloat(d) ) && isFinite( d ));
  };
  
  
  // A string without HTML in it can be considered to be HTML still
  var _isHtml = function ( d ) {
    return _empty( d ) || typeof d === 'string';
  };
  
  
  var _htmlNumeric = function ( d, decimalPoint, formatted ) {
    if ( _empty( d ) ) {
      return true;
    }
  
    var html = _isHtml( d );
    return ! html ?
      null :
      _isNumber( _stripHtml( d ), decimalPoint, formatted ) ?
        true :
        null;
  };
  
  
  var _pluck = function ( a, prop, prop2 ) {
    var out = [];
    var i=0, ien=a.length;
  
    // Could have the test in the loop for slightly smaller code, but speed
    // is essential here
    if ( prop2 !== undefined ) {
      for ( ; i<ien ; i++ ) {
        if ( a[i] && a[i][ prop ] ) {
          out.push( a[i][ prop ][ prop2 ] );
        }
      }
    }
    else {
      for ( ; i<ien ; i++ ) {
        if ( a[i] ) {
          out.push( a[i][ prop ] );
        }
      }
    }
  
    return out;
  };
  
  
  // Basically the same as _pluck, but rather than looping over `a` we use `order`
  // as the indexes to pick from `a`
  var _pluck_order = function ( a, order, prop, prop2 )
  {
    var out = [];
    var i=0, ien=order.length;
  
    // Could have the test in the loop for slightly smaller code, but speed
    // is essential here
    if ( prop2 !== undefined ) {
      for ( ; i<ien ; i++ ) {
        out.push( a[ order[i] ][ prop ][ prop2 ] );
      }
    }
    else {
      for ( ; i<ien ; i++ ) {
        out.push( a[ order[i] ][ prop ] );
      }
    }
  
    return out;
  };
  
  
  var _range = function ( len, start )
  {
    var out = [];
    var end;
  
    if ( start === undefined ) {
      start = 0;
      end = len;
    }
    else {
      end = start;
      start = len;
    }
  
    for ( var i=start ; i<end ; i++ ) {
      out.push( i );
    }
  
    return out;
  };
  
  
  var _stripHtml = function ( d ) {
    return d.replace( _re_html, '' );
  };
  
  
  /**
   * Find the unique elements in a source array.
   *
   * @param  {array} src Source array
   * @return {array} Array of unique items
   * @ignore
   */
  var _unique = function ( src )
  {
    // A faster unique method is to use object keys to identify used values,
    // but this doesn't work with arrays or objects, which we must also
    // consider. See jsperf.com/compare-array-unique-versions/4 for more
    // information.
    var
      out = [],
      val,
      i, ien=src.length,
      j, k=0;
  
    again: for ( i=0 ; i<ien ; i++ ) {
      val = src[i];
  
      for ( j=0 ; j<k ; j++ ) {
        if ( out[j] === val ) {
          continue again;
        }
      }
  
      out.push( val );
      k++;
    }
  
    return out;
  };
  
  
  
  /**
   * Create a mapping object that allows camel case parameters to be looked up
   * for their Hungarian counterparts. The mapping is stored in a private
   * parameter called `_hungarianMap` which can be accessed on the source object.
   *  @param {object} o
   *  @memberof DataTable#oApi
   */
  function _fnHungarianMap ( o )
  {
    var
      hungarian = 'a aa ai ao as b fn i m o s ',
      match,
      newKey,
      map = {};
  
    $.each( o, function (key, val) {
      match = key.match(/^([^A-Z]+?)([A-Z])/);
  
      if ( match && hungarian.indexOf(match[1]+' ') !== -1 )
      {
        newKey = key.replace( match[0], match[2].toLowerCase() );
        map[ newKey ] = key;
  
        //console.log( key, match );
        if ( match[1] === 'o' )
        {
          _fnHungarianMap( o[key] );
        }
      }
    } );
  
    o._hungarianMap = map;
  }
  
  
  /**
   * Convert from camel case parameters to Hungarian, based on a Hungarian map
   * created by _fnHungarianMap.
   *  @param {object} src The model object which holds all parameters that can be
   *    mapped.
   *  @param {object} user The object to convert from camel case to Hungarian.
   *  @param {boolean} force When set to `true`, properties which already have a
   *    Hungarian value in the `user` object will be overwritten. Otherwise they
   *    won't be.
   *  @memberof DataTable#oApi
   */
  function _fnCamelToHungarian ( src, user, force )
  {
    if ( ! src._hungarianMap ) {
      _fnHungarianMap( src );
    }
  
    var hungarianKey;
  
    $.each( user, function (key, val) {
      hungarianKey = src._hungarianMap[ key ];
  
      if ( hungarianKey !== undefined && (force || user[hungarianKey] === undefined) )
      {
        // For objects, we need to buzz down into the object to copy parameters
        if ( hungarianKey.charAt(0) === 'o' )
        {
          // Copy the camelCase options over to the hungarian
          if ( ! user[ hungarianKey ] ) {
            user[ hungarianKey ] = {};
          }
          $.extend( true, user[hungarianKey], user[key] );
  
          _fnCamelToHungarian( src[hungarianKey], user[hungarianKey], force );
        }
        else {
          user[hungarianKey] = user[ key ];
        }
      }
    } );
  }
  
  
  /**
   * Language compatibility - when certain options are given, and others aren't, we
   * need to duplicate the values over, in order to provide backwards compatibility
   * with older language files.
   *  @param {object} oSettings dataTables settings object
   *  @memberof DataTable#oApi
   */
  function _fnLanguageCompat( lang )
  {
    var defaults = DataTable.defaults.oLanguage;
    var zeroRecords = lang.sZeroRecords;
  
    /* Backwards compatibility - if there is no sEmptyTable given, then use the same as
     * sZeroRecords - assuming that is given.
     */
    if ( ! lang.sEmptyTable && zeroRecords &&
      defaults.sEmptyTable === "No data available in table" )
    {
      _fnMap( lang, lang, 'sZeroRecords', 'sEmptyTable' );
    }
  
    /* Likewise with loading records */
    if ( ! lang.sLoadingRecords && zeroRecords &&
      defaults.sLoadingRecords === "Loading..." )
    {
      _fnMap( lang, lang, 'sZeroRecords', 'sLoadingRecords' );
    }
  
    // Old parameter name of the thousands separator mapped onto the new
    if ( lang.sInfoThousands ) {
      lang.sThousands = lang.sInfoThousands;
    }
  
    var decimal = lang.sDecimal;
    if ( decimal ) {
      _addNumericSort( decimal );
    }
  }
  
  
  /**
   * Map one parameter onto another
   *  @param {object} o Object to map
   *  @param {*} knew The new parameter name
   *  @param {*} old The old parameter name
   */
  var _fnCompatMap = function ( o, knew, old ) {
    if ( o[ knew ] !== undefined ) {
      o[ old ] = o[ knew ];
    }
  };
  
  
  /**
   * Provide backwards compatibility for the main DT options. Note that the new
   * options are mapped onto the old parameters, so this is an external interface
   * change only.
   *  @param {object} init Object to map
   */
  function _fnCompatOpts ( init )
  {
    _fnCompatMap( init, 'ordering',      'bSort' );
    _fnCompatMap( init, 'orderMulti',    'bSortMulti' );
    _fnCompatMap( init, 'orderClasses',  'bSortClasses' );
    _fnCompatMap( init, 'orderCellsTop', 'bSortCellsTop' );
    _fnCompatMap( init, 'order',         'aaSorting' );
    _fnCompatMap( init, 'orderFixed',    'aaSortingFixed' );
    _fnCompatMap( init, 'paging',        'bPaginate' );
    _fnCompatMap( init, 'pagingType',    'sPaginationType' );
    _fnCompatMap( init, 'pageLength',    'iDisplayLength' );
    _fnCompatMap( init, 'searching',     'bFilter' );
  
    // Column search objects are in an array, so it needs to be converted
    // element by element
    var searchCols = init.aoSearchCols;
  
    if ( searchCols ) {
      for ( var i=0, ien=searchCols.length ; i<ien ; i++ ) {
        if ( searchCols[i] ) {
          _fnCamelToHungarian( DataTable.models.oSearch, searchCols[i] );
        }
      }
    }
  }
  
  
  /**
   * Provide backwards compatibility for column options. Note that the new options
   * are mapped onto the old parameters, so this is an external interface change
   * only.
   *  @param {object} init Object to map
   */
  function _fnCompatCols ( init )
  {
    _fnCompatMap( init, 'orderable',     'bSortable' );
    _fnCompatMap( init, 'orderData',     'aDataSort' );
    _fnCompatMap( init, 'orderSequence', 'asSorting' );
    _fnCompatMap( init, 'orderDataType', 'sortDataType' );
  }
  
  
  /**
   * Browser feature detection for capabilities, quirks
   *  @param {object} settings dataTables settings object
   *  @memberof DataTable#oApi
   */
  function _fnBrowserDetect( settings )
  {
    var browser = settings.oBrowser;
  
    // Scrolling feature / quirks detection
    var n = $('<div/>')
      .css( {
        position: 'absolute',
        top: 0,
        left: 0,
        height: 1,
        width: 1,
        overflow: 'hidden'
      } )
      .append(
        $('<div/>')
          .css( {
            position: 'absolute',
            top: 1,
            left: 1,
            width: 100,
            overflow: 'scroll'
          } )
          .append(
            $('<div class="test"/>')
              .css( {
                width: '100%',
                height: 10
              } )
          )
      )
      .appendTo( 'body' );
  
    var test = n.find('.test');
  
    // IE6/7 will oversize a width 100% element inside a scrolling element, to
    // include the width of the scrollbar, while other browsers ensure the inner
    // element is contained without forcing scrolling
    browser.bScrollOversize = test[0].offsetWidth === 100;
  
    // In rtl text layout, some browsers (most, but not all) will place the
    // scrollbar on the left, rather than the right.
    browser.bScrollbarLeft = test.offset().left !== 1;
  
    n.remove();
  }
  
  
  /**
   * Array.prototype reduce[Right] method, used for browsers which don't support
   * JS 1.6. Done this way to reduce code size, since we iterate either way
   *  @param {object} settings dataTables settings object
   *  @memberof DataTable#oApi
   */
  function _fnReduce ( that, fn, init, start, end, inc )
  {
    var
      i = start,
      value,
      isSet = false;
  
    if ( init !== undefined ) {
      value = init;
      isSet = true;
    }
  
    while ( i !== end ) {
      if ( ! that.hasOwnProperty(i) ) {
        continue;
      }
  
      value = isSet ?
        fn( value, that[i], i, that ) :
        that[i];
  
      isSet = true;
      i += inc;
    }
  
    return value;
  }
  
  /**
   * Add a column to the list used for the table with default values
   *  @param {object} oSettings dataTables settings object
   *  @param {node} nTh The th element for this column
   *  @memberof DataTable#oApi
   */
  function _fnAddColumn( oSettings, nTh )
  {
    // Add column to aoColumns array
    var oDefaults = DataTable.defaults.column;
    var iCol = oSettings.aoColumns.length;
    var oCol = $.extend( {}, DataTable.models.oColumn, oDefaults, {
      "nTh": nTh ? nTh : document.createElement('th'),
      "sTitle":    oDefaults.sTitle    ? oDefaults.sTitle    : nTh ? nTh.innerHTML : '',
      "aDataSort": oDefaults.aDataSort ? oDefaults.aDataSort : [iCol],
      "mData": oDefaults.mData ? oDefaults.mData : iCol,
      idx: iCol
    } );
    oSettings.aoColumns.push( oCol );
  
    // Add search object for column specific search. Note that the `searchCols[ iCol ]`
    // passed into extend can be undefined. This allows the user to give a default
    // with only some of the parameters defined, and also not give a default
    var searchCols = oSettings.aoPreSearchCols;
    searchCols[ iCol ] = $.extend( {}, DataTable.models.oSearch, searchCols[ iCol ] );
  
    // Use the default column options function to initialise classes etc
    _fnColumnOptions( oSettings, iCol, null );
  }
  
  
  /**
   * Apply options for a column
   *  @param {object} oSettings dataTables settings object
   *  @param {int} iCol column index to consider
   *  @param {object} oOptions object with sType, bVisible and bSearchable etc
   *  @memberof DataTable#oApi
   */
  function _fnColumnOptions( oSettings, iCol, oOptions )
  {
    var oCol = oSettings.aoColumns[ iCol ];
    var oClasses = oSettings.oClasses;
    var th = $(oCol.nTh);
  
    // Try to get width information from the DOM. We can't get it from CSS
    // as we'd need to parse the CSS stylesheet. `width` option can override
    if ( ! oCol.sWidthOrig ) {
      // Width attribute
      oCol.sWidthOrig = th.attr('width') || null;
  
      // Style attribute
      var t = (th.attr('style') || '').match(/width:\s*(\d+[pxem%]+)/);
      if ( t ) {
        oCol.sWidthOrig = t[1];
      }
    }
  
    /* User specified column options */
    if ( oOptions !== undefined && oOptions !== null )
    {
      // Backwards compatibility
      _fnCompatCols( oOptions );
  
      // Map camel case parameters to their Hungarian counterparts
      _fnCamelToHungarian( DataTable.defaults.column, oOptions );
  
      /* Backwards compatibility for mDataProp */
      if ( oOptions.mDataProp !== undefined && !oOptions.mData )
      {
        oOptions.mData = oOptions.mDataProp;
      }
  
      if ( oOptions.sType )
      {
        oCol._sManualType = oOptions.sType;
      }
  
      // `class` is a reserved word in Javascript, so we need to provide
      // the ability to use a valid name for the camel case input
      if ( oOptions.className && ! oOptions.sClass )
      {
        oOptions.sClass = oOptions.className;
      }
  
      $.extend( oCol, oOptions );
      _fnMap( oCol, oOptions, "sWidth", "sWidthOrig" );
  
      /* iDataSort to be applied (backwards compatibility), but aDataSort will take
       * priority if defined
       */
      if ( typeof oOptions.iDataSort === 'number' )
      {
        oCol.aDataSort = [ oOptions.iDataSort ];
      }
      _fnMap( oCol, oOptions, "aDataSort" );
    }
  
    /* Cache the data get and set functions for speed */
    var mDataSrc = oCol.mData;
    var mData = _fnGetObjectDataFn( mDataSrc );
    var mRender = oCol.mRender ? _fnGetObjectDataFn( oCol.mRender ) : null;
  
    var attrTest = function( src ) {
      return typeof src === 'string' && src.indexOf('@') !== -1;
    };
    oCol._bAttrSrc = $.isPlainObject( mDataSrc ) && (
      attrTest(mDataSrc.sort) || attrTest(mDataSrc.type) || attrTest(mDataSrc.filter)
    );
  
    oCol.fnGetData = function (rowData, type, meta) {
      var innerData = mData( rowData, type, undefined, meta );
  
      return mRender && type ?
        mRender( innerData, type, rowData, meta ) :
        innerData;
    };
    oCol.fnSetData = function ( rowData, val, meta ) {
      return _fnSetObjectDataFn( mDataSrc )( rowData, val, meta );
    };
  
    /* Feature sorting overrides column specific when off */
    if ( !oSettings.oFeatures.bSort )
    {
      oCol.bSortable = false;
      th.addClass( oClasses.sSortableNone ); // Have to add class here as order event isn't called
    }
  
    /* Check that the class assignment is correct for sorting */
    var bAsc = $.inArray('asc', oCol.asSorting) !== -1;
    var bDesc = $.inArray('desc', oCol.asSorting) !== -1;
    if ( !oCol.bSortable || (!bAsc && !bDesc) )
    {
      oCol.sSortingClass = oClasses.sSortableNone;
      oCol.sSortingClassJUI = "";
    }
    else if ( bAsc && !bDesc )
    {
      oCol.sSortingClass = oClasses.sSortableAsc;
      oCol.sSortingClassJUI = oClasses.sSortJUIAscAllowed;
    }
    else if ( !bAsc && bDesc )
    {
      oCol.sSortingClass = oClasses.sSortableDesc;
      oCol.sSortingClassJUI = oClasses.sSortJUIDescAllowed;
    }
    else
    {
      oCol.sSortingClass = oClasses.sSortable;
      oCol.sSortingClassJUI = oClasses.sSortJUI;
    }
  }
  
  
  /**
   * Adjust the table column widths for new data. Note: you would probably want to
   * do a redraw after calling this function!
   *  @param {object} settings dataTables settings object
   *  @memberof DataTable#oApi
   */
  function _fnAdjustColumnSizing ( settings )
  {
    /* Not interested in doing column width calculation if auto-width is disabled */
    if ( settings.oFeatures.bAutoWidth !== false )
    {
      var columns = settings.aoColumns;
  
      _fnCalculateColumnWidths( settings );
      for ( var i=0 , iLen=columns.length ; i<iLen ; i++ )
      {
        columns[i].nTh.style.width = columns[i].sWidth;
      }
    }
  
    var scroll = settings.oScroll;
    if ( scroll.sY !== '' || scroll.sX !== '')
    {
      _fnScrollDraw( settings );
    }
  
    _fnCallbackFire( settings, null, 'column-sizing', [settings] );
  }
  
  
  /**
   * Covert the index of a visible column to the index in the data array (take account
   * of hidden columns)
   *  @param {object} oSettings dataTables settings object
   *  @param {int} iMatch Visible column index to lookup
   *  @returns {int} i the data index
   *  @memberof DataTable#oApi
   */
  function _fnVisibleToColumnIndex( oSettings, iMatch )
  {
    var aiVis = _fnGetColumns( oSettings, 'bVisible' );
  
    return typeof aiVis[iMatch] === 'number' ?
      aiVis[iMatch] :
      null;
  }
  
  
  /**
   * Covert the index of an index in the data array and convert it to the visible
   *   column index (take account of hidden columns)
   *  @param {int} iMatch Column index to lookup
   *  @param {object} oSettings dataTables settings object
   *  @returns {int} i the data index
   *  @memberof DataTable#oApi
   */
  function _fnColumnIndexToVisible( oSettings, iMatch )
  {
    var aiVis = _fnGetColumns( oSettings, 'bVisible' );
    var iPos = $.inArray( iMatch, aiVis );
  
    return iPos !== -1 ? iPos : null;
  }
  
  
  /**
   * Get the number of visible columns
   *  @param {object} oSettings dataTables settings object
   *  @returns {int} i the number of visible columns
   *  @memberof DataTable#oApi
   */
  function _fnVisbleColumns( oSettings )
  {
    return _fnGetColumns( oSettings, 'bVisible' ).length;
  }
  
  
  /**
   * Get an array of column indexes that match a given property
   *  @param {object} oSettings dataTables settings object
   *  @param {string} sParam Parameter in aoColumns to look for - typically
   *    bVisible or bSearchable
   *  @returns {array} Array of indexes with matched properties
   *  @memberof DataTable#oApi
   */
  function _fnGetColumns( oSettings, sParam )
  {
    var a = [];
  
    $.map( oSettings.aoColumns, function(val, i) {
      if ( val[sParam] ) {
        a.push( i );
      }
    } );
  
    return a;
  }
  
  
  /**
   * Calculate the 'type' of a column
   *  @param {object} settings dataTables settings object
   *  @memberof DataTable#oApi
   */
  function _fnColumnTypes ( settings )
  {
    var columns = settings.aoColumns;
    var data = settings.aoData;
    var types = DataTable.ext.type.detect;
    var i, ien, j, jen, k, ken;
    var col, cell, detectedType, cache;
  
    // For each column, spin over the 
    for ( i=0, ien=columns.length ; i<ien ; i++ ) {
      col = columns[i];
      cache = [];
  
      if ( ! col.sType && col._sManualType ) {
        col.sType = col._sManualType;
      }
      else if ( ! col.sType ) {
        for ( j=0, jen=types.length ; j<jen ; j++ ) {
          for ( k=0, ken=data.length ; k<ken ; k++ ) {
            // Use a cache array so we only need to get the type data
            // from the formatter once (when using multiple detectors)
            if ( cache[k] === undefined ) {
              cache[k] = _fnGetCellData( settings, k, i, 'type' );
            }
  
            detectedType = types[j]( cache[k], settings );
  
            // Doesn't match, so break early, since this type can't
            // apply to this column. Also, HTML is a special case since
            // it is so similar to `string`. Just a single match is
            // needed for a column to be html type
            if ( ! detectedType || detectedType === 'html' ) {
              break;
            }
          }
  
          // Type is valid for all data points in the column - use this
          // type
          if ( detectedType ) {
            col.sType = detectedType;
            break;
          }
        }
  
        // Fall back - if no type was detected, always use string
        if ( ! col.sType ) {
          col.sType = 'string';
        }
      }
    }
  }
  
  
  /**
   * Take the column definitions and static columns arrays and calculate how
   * they relate to column indexes. The callback function will then apply the
   * definition found for a column to a suitable configuration object.
   *  @param {object} oSettings dataTables settings object
   *  @param {array} aoColDefs The aoColumnDefs array that is to be applied
   *  @param {array} aoCols The aoColumns array that defines columns individually
   *  @param {function} fn Callback function - takes two parameters, the calculated
   *    column index and the definition for that column.
   *  @memberof DataTable#oApi
   */
  function _fnApplyColumnDefs( oSettings, aoColDefs, aoCols, fn )
  {
    var i, iLen, j, jLen, k, kLen, def;
    var columns = oSettings.aoColumns;
  
    // Column definitions with aTargets
    if ( aoColDefs )
    {
      /* Loop over the definitions array - loop in reverse so first instance has priority */
      for ( i=aoColDefs.length-1 ; i>=0 ; i-- )
      {
        def = aoColDefs[i];
  
        /* Each definition can target multiple columns, as it is an array */
        var aTargets = def.targets !== undefined ?
          def.targets :
          def.aTargets;
  
        if ( ! $.isArray( aTargets ) )
        {
          aTargets = [ aTargets ];
        }
  
        for ( j=0, jLen=aTargets.length ; j<jLen ; j++ )
        {
          if ( typeof aTargets[j] === 'number' && aTargets[j] >= 0 )
          {
            /* Add columns that we don't yet know about */
            while( columns.length <= aTargets[j] )
            {
              _fnAddColumn( oSettings );
            }
  
            /* Integer, basic index */
            fn( aTargets[j], def );
          }
          else if ( typeof aTargets[j] === 'number' && aTargets[j] < 0 )
          {
            /* Negative integer, right to left column counting */
            fn( columns.length+aTargets[j], def );
          }
          else if ( typeof aTargets[j] === 'string' )
          {
            /* Class name matching on TH element */
            for ( k=0, kLen=columns.length ; k<kLen ; k++ )
            {
              if ( aTargets[j] == "_all" ||
                   $(columns[k].nTh).hasClass( aTargets[j] ) )
              {
                fn( k, def );
              }
            }
          }
        }
      }
    }
  
    // Statically defined columns array
    if ( aoCols )
    {
      for ( i=0, iLen=aoCols.length ; i<iLen ; i++ )
      {
        fn( i, aoCols[i] );
      }
    }
  }
  
  /**
   * Add a data array to the table, creating DOM node etc. This is the parallel to
   * _fnGatherData, but for adding rows from a Javascript source, rather than a
   * DOM source.
   *  @param {object} oSettings dataTables settings object
   *  @param {array} aData data array to be added
   *  @param {node} [nTr] TR element to add to the table - optional. If not given,
   *    DataTables will create a row automatically
   *  @param {array} [anTds] Array of TD|TH elements for the row - must be given
   *    if nTr is.
   *  @returns {int} >=0 if successful (index of new aoData entry), -1 if failed
   *  @memberof DataTable#oApi
   */
  function _fnAddData ( oSettings, aDataIn, nTr, anTds )
  {
    /* Create the object for storing information about this new row */
    var iRow = oSettings.aoData.length;
    var oData = $.extend( true, {}, DataTable.models.oRow, {
      src: nTr ? 'dom' : 'data'
    } );
  
    oData._aData = aDataIn;
    oSettings.aoData.push( oData );
  
    /* Create the cells */
    var nTd, sThisType;
    var columns = oSettings.aoColumns;
    for ( var i=0, iLen=columns.length ; i<iLen ; i++ )
    {
      // When working with a row, the data source object must be populated. In
      // all other cases, the data source object is already populated, so we
      // don't overwrite it, which might break bindings etc
      if ( nTr ) {
        _fnSetCellData( oSettings, iRow, i, _fnGetCellData( oSettings, iRow, i ) );
      }
      columns[i].sType = null;
    }
  
    /* Add to the display array */
    oSettings.aiDisplayMaster.push( iRow );
  
    /* Create the DOM information, or register it if already present */
    if ( nTr || ! oSettings.oFeatures.bDeferRender )
    {
      _fnCreateTr( oSettings, iRow, nTr, anTds );
    }
  
    return iRow;
  }
  
  
  /**
   * Add one or more TR elements to the table. Generally we'd expect to
   * use this for reading data from a DOM sourced table, but it could be
   * used for an TR element. Note that if a TR is given, it is used (i.e.
   * it is not cloned).
   *  @param {object} settings dataTables settings object
   *  @param {array|node|jQuery} trs The TR element(s) to add to the table
   *  @returns {array} Array of indexes for the added rows
   *  @memberof DataTable#oApi
   */
  function _fnAddTr( settings, trs )
  {
    var row;
  
    // Allow an individual node to be passed in
    if ( ! (trs instanceof $) ) {
      trs = $(trs);
    }
  
    return trs.map( function (i, el) {
      row = _fnGetRowElements( settings, el );
      return _fnAddData( settings, row.data, el, row.cells );
    } );
  }
  
  
  /**
   * Take a TR element and convert it to an index in aoData
   *  @param {object} oSettings dataTables settings object
   *  @param {node} n the TR element to find
   *  @returns {int} index if the node is found, null if not
   *  @memberof DataTable#oApi
   */
  function _fnNodeToDataIndex( oSettings, n )
  {
    return (n._DT_RowIndex!==undefined) ? n._DT_RowIndex : null;
  }
  
  
  /**
   * Take a TD element and convert it into a column data index (not the visible index)
   *  @param {object} oSettings dataTables settings object
   *  @param {int} iRow The row number the TD/TH can be found in
   *  @param {node} n The TD/TH element to find
   *  @returns {int} index if the node is found, -1 if not
   *  @memberof DataTable#oApi
   */
  function _fnNodeToColumnIndex( oSettings, iRow, n )
  {
    return $.inArray( n, oSettings.aoData[ iRow ].anCells );
  }
  
  
  /**
   * Get the data for a given cell from the internal cache, taking into account data mapping
   *  @param {object} settings dataTables settings object
   *  @param {int} rowIdx aoData row id
   *  @param {int} colIdx Column index
   *  @param {string} type data get type ('display', 'type' 'filter' 'sort')
   *  @returns {*} Cell data
   *  @memberof DataTable#oApi
   */
  function _fnGetCellData( settings, rowIdx, colIdx, type )
  {
    var draw           = settings.iDraw;
    var col            = settings.aoColumns[colIdx];
    var rowData        = settings.aoData[rowIdx]._aData;
    var defaultContent = col.sDefaultContent;
    var cellData       = col.fnGetData( rowData, type, {
      settings: settings,
      row:      rowIdx,
      col:      colIdx
    } );
  
    if ( cellData === undefined ) {
      if ( settings.iDrawError != draw && defaultContent === null ) {
        _fnLog( settings, 0, "Requested unknown parameter "+
          (typeof col.mData=='function' ? '{function}' : "'"+col.mData+"'")+
          " for row "+rowIdx, 4 );
        settings.iDrawError = draw;
      }
      return defaultContent;
    }
  
    /* When the data source is null, we can use default column data */
    if ( (cellData === rowData || cellData === null) && defaultContent !== null ) {
      cellData = defaultContent;
    }
    else if ( typeof cellData === 'function' ) {
      // If the data source is a function, then we run it and use the return,
      // executing in the scope of the data object (for instances)
      return cellData.call( rowData );
    }
  
    if ( cellData === null && type == 'display' ) {
      return '';
    }
    return cellData;
  }
  
  
  /**
   * Set the value for a specific cell, into the internal data cache
   *  @param {object} settings dataTables settings object
   *  @param {int} rowIdx aoData row id
   *  @param {int} colIdx Column index
   *  @param {*} val Value to set
   *  @memberof DataTable#oApi
   */
  function _fnSetCellData( settings, rowIdx, colIdx, val )
  {
    var col     = settings.aoColumns[colIdx];
    var rowData = settings.aoData[rowIdx]._aData;
  
    col.fnSetData( rowData, val, {
      settings: settings,
      row:      rowIdx,
      col:      colIdx
    }  );
  }
  
  
  // Private variable that is used to match action syntax in the data property object
  var __reArray = /\[.*?\]$/;
  var __reFn = /\(\)$/;
  
  /**
   * Split string on periods, taking into account escaped periods
   * @param  {string} str String to split
   * @return {array} Split string
   */
  function _fnSplitObjNotation( str )
  {
    return $.map( str.match(/(\\.|[^\.])+/g), function ( s ) {
      return s.replace(/\\./g, '.');
    } );
  }
  
  
  /**
   * Return a function that can be used to get data from a source object, taking
   * into account the ability to use nested objects as a source
   *  @param {string|int|function} mSource The data source for the object
   *  @returns {function} Data get function
   *  @memberof DataTable#oApi
   */
  function _fnGetObjectDataFn( mSource )
  {
    if ( $.isPlainObject( mSource ) )
    {
      /* Build an object of get functions, and wrap them in a single call */
      var o = {};
      $.each( mSource, function (key, val) {
        if ( val ) {
          o[key] = _fnGetObjectDataFn( val );
        }
      } );
  
      return function (data, type, row, meta) {
        var t = o[type] || o._;
        return t !== undefined ?
          t(data, type, row, meta) :
          data;
      };
    }
    else if ( mSource === null )
    {
      /* Give an empty string for rendering / sorting etc */
      return function (data) { // type, row and meta also passed, but not used
        return data;
      };
    }
    else if ( typeof mSource === 'function' )
    {
      return function (data, type, row, meta) {
        return mSource( data, type, row, meta );
      };
    }
    else if ( typeof mSource === 'string' && (mSource.indexOf('.') !== -1 ||
            mSource.indexOf('[') !== -1 || mSource.indexOf('(') !== -1) )
    {
      /* If there is a . in the source string then the data source is in a
       * nested object so we loop over the data for each level to get the next
       * level down. On each loop we test for undefined, and if found immediately
       * return. This allows entire objects to be missing and sDefaultContent to
       * be used if defined, rather than throwing an error
       */
      var fetchData = function (data, type, src) {
        var arrayNotation, funcNotation, out, innerSrc;
  
        if ( src !== "" )
        {
          var a = _fnSplitObjNotation( src );
  
          for ( var i=0, iLen=a.length ; i<iLen ; i++ )
          {
            // Check if we are dealing with special notation
            arrayNotation = a[i].match(__reArray);
            funcNotation = a[i].match(__reFn);
  
            if ( arrayNotation )
            {
              // Array notation
              a[i] = a[i].replace(__reArray, '');
  
              // Condition allows simply [] to be passed in
              if ( a[i] !== "" ) {
                data = data[ a[i] ];
              }
              out = [];
  
              // Get the remainder of the nested object to get
              a.splice( 0, i+1 );
              innerSrc = a.join('.');
  
              // Traverse each entry in the array getting the properties requested
              for ( var j=0, jLen=data.length ; j<jLen ; j++ ) {
                out.push( fetchData( data[j], type, innerSrc ) );
              }
  
              // If a string is given in between the array notation indicators, that
              // is used to join the strings together, otherwise an array is returned
              var join = arrayNotation[0].substring(1, arrayNotation[0].length-1);
              data = (join==="") ? out : out.join(join);
  
              // The inner call to fetchData has already traversed through the remainder
              // of the source requested, so we exit from the loop
              break;
            }
            else if ( funcNotation )
            {
              // Function call
              a[i] = a[i].replace(__reFn, '');
              data = data[ a[i] ]();
              continue;
            }
  
            if ( data === null || data[ a[i] ] === undefined )
            {
              return undefined;
            }
            data = data[ a[i] ];
          }
        }
  
        return data;
      };
  
      return function (data, type) { // row and meta also passed, but not used
        return fetchData( data, type, mSource );
      };
    }
    else
    {
      /* Array or flat object mapping */
      return function (data, type) { // row and meta also passed, but not used
        return data[mSource];
      };
    }
  }
  
  
  /**
   * Return a function that can be used to set data from a source object, taking
   * into account the ability to use nested objects as a source
   *  @param {string|int|function} mSource The data source for the object
   *  @returns {function} Data set function
   *  @memberof DataTable#oApi
   */
  function _fnSetObjectDataFn( mSource )
  {
    if ( $.isPlainObject( mSource ) )
    {
      /* Unlike get, only the underscore (global) option is used for for
       * setting data since we don't know the type here. This is why an object
       * option is not documented for `mData` (which is read/write), but it is
       * for `mRender` which is read only.
       */
      return _fnSetObjectDataFn( mSource._ );
    }
    else if ( mSource === null )
    {
      /* Nothing to do when the data source is null */
      return function () {};
    }
    else if ( typeof mSource === 'function' )
    {
      return function (data, val, meta) {
        mSource( data, 'set', val, meta );
      };
    }
    else if ( typeof mSource === 'string' && (mSource.indexOf('.') !== -1 ||
            mSource.indexOf('[') !== -1 || mSource.indexOf('(') !== -1) )
    {
      /* Like the get, we need to get data from a nested object */
      var setData = function (data, val, src) {
        var a = _fnSplitObjNotation( src ), b;
        var aLast = a[a.length-1];
        var arrayNotation, funcNotation, o, innerSrc;
  
        for ( var i=0, iLen=a.length-1 ; i<iLen ; i++ )
        {
          // Check if we are dealing with an array notation request
          arrayNotation = a[i].match(__reArray);
          funcNotation = a[i].match(__reFn);
  
          if ( arrayNotation )
          {
            a[i] = a[i].replace(__reArray, '');
            data[ a[i] ] = [];
  
            // Get the remainder of the nested object to set so we can recurse
            b = a.slice();
            b.splice( 0, i+1 );
            innerSrc = b.join('.');
  
            // Traverse each entry in the array setting the properties requested
            for ( var j=0, jLen=val.length ; j<jLen ; j++ )
            {
              o = {};
              setData( o, val[j], innerSrc );
              data[ a[i] ].push( o );
            }
  
            // The inner call to setData has already traversed through the remainder
            // of the source and has set the data, thus we can exit here
            return;
          }
          else if ( funcNotation )
          {
            // Function call
            a[i] = a[i].replace(__reFn, '');
            data = data[ a[i] ]( val );
          }
  
          // If the nested object doesn't currently exist - since we are
          // trying to set the value - create it
          if ( data[ a[i] ] === null || data[ a[i] ] === undefined )
          {
            data[ a[i] ] = {};
          }
          data = data[ a[i] ];
        }
  
        // Last item in the input - i.e, the actual set
        if ( aLast.match(__reFn ) )
        {
          // Function call
          data = data[ aLast.replace(__reFn, '') ]( val );
        }
        else
        {
          // If array notation is used, we just want to strip it and use the property name
          // and assign the value. If it isn't used, then we get the result we want anyway
          data[ aLast.replace(__reArray, '') ] = val;
        }
      };
  
      return function (data, val) { // meta is also passed in, but not used
        return setData( data, val, mSource );
      };
    }
    else
    {
      /* Array or flat object mapping */
      return function (data, val) { // meta is also passed in, but not used
        data[mSource] = val;
      };
    }
  }
  
  
  /**
   * Return an array with the full table data
   *  @param {object} oSettings dataTables settings object
   *  @returns array {array} aData Master data array
   *  @memberof DataTable#oApi
   */
  function _fnGetDataMaster ( settings )
  {
    return _pluck( settings.aoData, '_aData' );
  }
  
  
  /**
   * Nuke the table
   *  @param {object} oSettings dataTables settings object
   *  @memberof DataTable#oApi
   */
  function _fnClearTable( settings )
  {
    settings.aoData.length = 0;
    settings.aiDisplayMaster.length = 0;
    settings.aiDisplay.length = 0;
  }
  
  
   /**
   * Take an array of integers (index array) and remove a target integer (value - not
   * the key!)
   *  @param {array} a Index array to target
   *  @param {int} iTarget value to find
   *  @memberof DataTable#oApi
   */
  function _fnDeleteIndex( a, iTarget, splice )
  {
    var iTargetIndex = -1;
  
    for ( var i=0, iLen=a.length ; i<iLen ; i++ )
    {
      if ( a[i] == iTarget )
      {
        iTargetIndex = i;
      }
      else if ( a[i] > iTarget )
      {
        a[i]--;
      }
    }
  
    if ( iTargetIndex != -1 && splice === undefined )
    {
      a.splice( iTargetIndex, 1 );
    }
  }
  
  
  /**
   * Mark cached data as invalid such that a re-read of the data will occur when
   * the cached data is next requested. Also update from the data source object.
   *
   * @param {object} settings DataTables settings object
   * @param  {int}    rowIdx   Row index to invalidate
   * @memberof DataTable#oApi
   *
   * @todo For the modularisation of v1.11 this will need to become a callback, so
   *   the sort and filter methods can subscribe to it. That will required
   *   initialisation options for sorting, which is why it is not already baked in
   */
  function _fnInvalidateRow( settings, rowIdx, src, column )
  {
    var row = settings.aoData[ rowIdx ];
    var i, ien;
  
    // Are we reading last data from DOM or the data object?
    if ( src === 'dom' || ((! src || src === 'auto') && row.src === 'dom') ) {
      // Read the data from the DOM
      row._aData = _fnGetRowElements( settings, row ).data;
    }
    else {
      // Reading from data object, update the DOM
      var cells = row.anCells;
      var cell;
  
      if ( cells ) {
        for ( i=0, ien=cells.length ; i<ien ; i++ ) {
          cell = cells[i];
  
          // This is very frustrating, but in IE if you just write directly
          // to innerHTML, and elements that are overwritten are GC'ed,
          // even if there is a reference to them elsewhere
          while ( cell.childNodes.length ) {
            cell.removeChild( cell.firstChild );
          }
  
          cells[i].innerHTML = _fnGetCellData( settings, rowIdx, i, 'display' );
        }
      }
    }
  
    row._aSortData = null;
    row._aFilterData = null;
  
    // Invalidate the type for a specific column (if given) or all columns since
    // the data might have changed
    var cols = settings.aoColumns;
    if ( column !== undefined ) {
      cols[ column ].sType = null;
    }
    else {
      for ( i=0, ien=cols.length ; i<ien ; i++ ) {
        cols[i].sType = null;
      }
    }
  
    // Update DataTables special `DT_*` attributes for the row
    _fnRowAttributes( row );
  }
  
  
  /**
   * Build a data source object from an HTML row, reading the contents of the
   * cells that are in the row.
   *
   * @param {object} settings DataTables settings object
   * @param {node|object} TR element from which to read data or existing row
   *   object from which to re-read the data from the cells
   * @returns {object} Object with two parameters: `data` the data read, in
   *   document order, and `cells` and array of nodes (they can be useful to the
   *   caller, so rather than needing a second traversal to get them, just return
   *   them from here).
   * @memberof DataTable#oApi
   */
  function _fnGetRowElements( settings, row )
  {
    var
      d = [],
      tds = [],
      td = row.firstChild,
      name, col, o, i=0, contents,
      columns = settings.aoColumns;
  
    var attr = function ( str, data, td  ) {
      if ( typeof str === 'string' ) {
        var idx = str.indexOf('@');
  
        if ( idx !== -1 ) {
          var src = str.substring( idx+1 );
          o[ '@'+src ] = td.getAttribute( src );
        }
      }
    };
  
    var cellProcess = function ( cell ) {
      col = columns[i];
      contents = $.trim(cell.innerHTML);
  
      if ( col && col._bAttrSrc ) {
        o = {
          display: contents
        };
  
        attr( col.mData.sort, o, cell );
        attr( col.mData.type, o, cell );
        attr( col.mData.filter, o, cell );
  
        d.push( o );
      }
      else {
        d.push( contents );
      }
  
      i++;
    };
  
    if ( td ) {
      // `tr` element passed in
      while ( td ) {
        name = td.nodeName.toUpperCase();
  
        if ( name == "TD" || name == "TH" ) {
          cellProcess( td );
          tds.push( td );
        }
  
        td = td.nextSibling;
      }
    }
    else {
      // Existing row object passed in
      tds = row.anCells;
      
      for ( var j=0, jen=tds.length ; j<jen ; j++ ) {
        cellProcess( tds[j] );
      }
    }
  
    return {
      data: d,
      cells: tds
    };
  }
  /**
   * Create a new TR element (and it's TD children) for a row
   *  @param {object} oSettings dataTables settings object
   *  @param {int} iRow Row to consider
   *  @param {node} [nTrIn] TR element to add to the table - optional. If not given,
   *    DataTables will create a row automatically
   *  @param {array} [anTds] Array of TD|TH elements for the row - must be given
   *    if nTr is.
   *  @memberof DataTable#oApi
   */
  function _fnCreateTr ( oSettings, iRow, nTrIn, anTds )
  {
    var
      row = oSettings.aoData[iRow],
      rowData = row._aData,
      cells = [],
      nTr, nTd, oCol,
      i, iLen;
  
    if ( row.nTr === null )
    {
      nTr = nTrIn || document.createElement('tr');
  
      row.nTr = nTr;
      row.anCells = cells;
  
      /* Use a private property on the node to allow reserve mapping from the node
       * to the aoData array for fast look up
       */
      nTr._DT_RowIndex = iRow;
  
      /* Special parameters can be given by the data source to be used on the row */
      _fnRowAttributes( row );
  
      /* Process each column */
      for ( i=0, iLen=oSettings.aoColumns.length ; i<iLen ; i++ )
      {
        oCol = oSettings.aoColumns[i];
  
        nTd = nTrIn ? anTds[i] : document.createElement( oCol.sCellType );
        cells.push( nTd );
  
        // Need to create the HTML if new, or if a rendering function is defined
        if ( !nTrIn || oCol.mRender || oCol.mData !== i )
        {
          nTd.innerHTML = _fnGetCellData( oSettings, iRow, i, 'display' );
        }
  
        /* Add user defined class */
        if ( oCol.sClass )
        {
          nTd.className += ' '+oCol.sClass;
        }
  
        // Visibility - add or remove as required
        if ( oCol.bVisible && ! nTrIn )
        {
          nTr.appendChild( nTd );
        }
        else if ( ! oCol.bVisible && nTrIn )
        {
          nTd.parentNode.removeChild( nTd );
        }
  
        if ( oCol.fnCreatedCell )
        {
          oCol.fnCreatedCell.call( oSettings.oInstance,
            nTd, _fnGetCellData( oSettings, iRow, i ), rowData, iRow, i
          );
        }
      }
  
      _fnCallbackFire( oSettings, 'aoRowCreatedCallback', null, [nTr, rowData, iRow] );
    }
  
    // Remove once webkit bug 131819 and Chromium bug 365619 have been resolved
    // and deployed
    row.nTr.setAttribute( 'role', 'row' );
  }
  
  
  /**
   * Add attributes to a row based on the special `DT_*` parameters in a data
   * source object.
   *  @param {object} DataTables row object for the row to be modified
   *  @memberof DataTable#oApi
   */
  function _fnRowAttributes( row )
  {
    var tr = row.nTr;
    var data = row._aData;
  
    if ( tr ) {
      if ( data.DT_RowId ) {
        tr.id = data.DT_RowId;
      }
  
      if ( data.DT_RowClass ) {
        // Remove any classes added by DT_RowClass before
        var a = data.DT_RowClass.split(' ');
        row.__rowc = row.__rowc ?
          _unique( row.__rowc.concat( a ) ) :
          a;
  
        $(tr)
          .removeClass( row.__rowc.join(' ') )
          .addClass( data.DT_RowClass );
      }
  
      if ( data.DT_RowData ) {
        $(tr).data( data.DT_RowData );
      }
    }
  }
  
  
  /**
   * Create the HTML header for the table
   *  @param {object} oSettings dataTables settings object
   *  @memberof DataTable#oApi
   */
  function _fnBuildHead( oSettings )
  {
    var i, ien, cell, row, column;
    var thead = oSettings.nTHead;
    var tfoot = oSettings.nTFoot;
    var createHeader = $('th, td', thead).length === 0;
    var classes = oSettings.oClasses;
    var columns = oSettings.aoColumns;
  
    if ( createHeader ) {
      row = $('<tr/>').appendTo( thead );
    }
  
    for ( i=0, ien=columns.length ; i<ien ; i++ ) {
      column = columns[i];
      cell = $( column.nTh ).addClass( column.sClass );
  
      if ( createHeader ) {
        cell.appendTo( row );
      }
  
      // 1.11 move into sorting
      if ( oSettings.oFeatures.bSort ) {
        cell.addClass( column.sSortingClass );
  
        if ( column.bSortable !== false ) {
          cell
            .attr( 'tabindex', oSettings.iTabIndex )
            .attr( 'aria-controls', oSettings.sTableId );
  
          _fnSortAttachListener( oSettings, column.nTh, i );
        }
      }
  
      if ( column.sTitle != cell.html() ) {
        cell.html( column.sTitle );
      }
  
      _fnRenderer( oSettings, 'header' )(
        oSettings, cell, column, classes
      );
    }
  
    if ( createHeader ) {
      _fnDetectHeader( oSettings.aoHeader, thead );
    }
    
    /* ARIA role for the rows */
    $(thead).find('>tr').attr('role', 'row');
  
    /* Deal with the footer - add classes if required */
    $(thead).find('>tr>th, >tr>td').addClass( classes.sHeaderTH );
    $(tfoot).find('>tr>th, >tr>td').addClass( classes.sFooterTH );
  
    // Cache the footer cells. Note that we only take the cells from the first
    // row in the footer. If there is more than one row the user wants to
    // interact with, they need to use the table().foot() method. Note also this
    // allows cells to be used for multiple columns using colspan
    if ( tfoot !== null ) {
      var cells = oSettings.aoFooter[0];
  
      for ( i=0, ien=cells.length ; i<ien ; i++ ) {
        column = columns[i];
        column.nTf = cells[i].cell;
  
        if ( column.sClass ) {
          $(column.nTf).addClass( column.sClass );
        }
      }
    }
  }
  
  
  /**
   * Draw the header (or footer) element based on the column visibility states. The
   * methodology here is to use the layout array from _fnDetectHeader, modified for
   * the instantaneous column visibility, to construct the new layout. The grid is
   * traversed over cell at a time in a rows x columns grid fashion, although each
   * cell insert can cover multiple elements in the grid - which is tracks using the
   * aApplied array. Cell inserts in the grid will only occur where there isn't
   * already a cell in that position.
   *  @param {object} oSettings dataTables settings object
   *  @param array {objects} aoSource Layout array from _fnDetectHeader
   *  @param {boolean} [bIncludeHidden=false] If true then include the hidden columns in the calc,
   *  @memberof DataTable#oApi
   */
  function _fnDrawHead( oSettings, aoSource, bIncludeHidden )
  {
    var i, iLen, j, jLen, k, kLen, n, nLocalTr;
    var aoLocal = [];
    var aApplied = [];
    var iColumns = oSettings.aoColumns.length;
    var iRowspan, iColspan;
  
    if ( ! aoSource )
    {
      return;
    }
  
    if (  bIncludeHidden === undefined )
    {
      bIncludeHidden = false;
    }
  
    /* Make a copy of the master layout array, but without the visible columns in it */
    for ( i=0, iLen=aoSource.length ; i<iLen ; i++ )
    {
      aoLocal[i] = aoSource[i].slice();
      aoLocal[i].nTr = aoSource[i].nTr;
  
      /* Remove any columns which are currently hidden */
      for ( j=iColumns-1 ; j>=0 ; j-- )
      {
        if ( !oSettings.aoColumns[j].bVisible && !bIncludeHidden )
        {
          aoLocal[i].splice( j, 1 );
        }
      }
  
      /* Prep the applied array - it needs an element for each row */
      aApplied.push( [] );
    }
  
    for ( i=0, iLen=aoLocal.length ; i<iLen ; i++ )
    {
      nLocalTr = aoLocal[i].nTr;
  
      /* All cells are going to be replaced, so empty out the row */
      if ( nLocalTr )
      {
        while( (n = nLocalTr.firstChild) )
        {
          nLocalTr.removeChild( n );
        }
      }
  
      for ( j=0, jLen=aoLocal[i].length ; j<jLen ; j++ )
      {
        iRowspan = 1;
        iColspan = 1;
  
        /* Check to see if there is already a cell (row/colspan) covering our target
         * insert point. If there is, then there is nothing to do.
         */
        if ( aApplied[i][j] === undefined )
        {
          nLocalTr.appendChild( aoLocal[i][j].cell );
          aApplied[i][j] = 1;
  
          /* Expand the cell to cover as many rows as needed */
          while ( aoLocal[i+iRowspan] !== undefined &&
                  aoLocal[i][j].cell == aoLocal[i+iRowspan][j].cell )
          {
            aApplied[i+iRowspan][j] = 1;
            iRowspan++;
          }
  
          /* Expand the cell to cover as many columns as needed */
          while ( aoLocal[i][j+iColspan] !== undefined &&
                  aoLocal[i][j].cell == aoLocal[i][j+iColspan].cell )
          {
            /* Must update the applied array over the rows for the columns */
            for ( k=0 ; k<iRowspan ; k++ )
            {
              aApplied[i+k][j+iColspan] = 1;
            }
            iColspan++;
          }
  
          /* Do the actual expansion in the DOM */
          $(aoLocal[i][j].cell)
            .attr('rowspan', iRowspan)
            .attr('colspan', iColspan);
        }
      }
    }
  }
  
  
  /**
   * Insert the required TR nodes into the table for display
   *  @param {object} oSettings dataTables settings object
   *  @memberof DataTable#oApi
   */
  function _fnDraw( oSettings )
  {
    /* Provide a pre-callback function which can be used to cancel the draw is false is returned */
    var aPreDraw = _fnCallbackFire( oSettings, 'aoPreDrawCallback', 'preDraw', [oSettings] );
    if ( $.inArray( false, aPreDraw ) !== -1 )
    {
      _fnProcessingDisplay( oSettings, false );
      return;
    }
  
    var i, iLen, n;
    var anRows = [];
    var iRowCount = 0;
    var asStripeClasses = oSettings.asStripeClasses;
    var iStripes = asStripeClasses.length;
    var iOpenRows = oSettings.aoOpenRows.length;
    var oLang = oSettings.oLanguage;
    var iInitDisplayStart = oSettings.iInitDisplayStart;
    var bServerSide = _fnDataSource( oSettings ) == 'ssp';
    var aiDisplay = oSettings.aiDisplay;
  
    oSettings.bDrawing = true;
  
    /* Check and see if we have an initial draw position from state saving */
    if ( iInitDisplayStart !== undefined && iInitDisplayStart !== -1 )
    {
      oSettings._iDisplayStart = bServerSide ?
        iInitDisplayStart :
        iInitDisplayStart >= oSettings.fnRecordsDisplay() ?
          0 :
          iInitDisplayStart;
  
      oSettings.iInitDisplayStart = -1;
    }
  
    var iDisplayStart = oSettings._iDisplayStart;
    var iDisplayEnd = oSettings.fnDisplayEnd();
  
    /* Server-side processing draw intercept */
    if ( oSettings.bDeferLoading )
    {
      oSettings.bDeferLoading = false;
      oSettings.iDraw++;
      _fnProcessingDisplay( oSettings, false );
    }
    else if ( !bServerSide )
    {
      oSettings.iDraw++;
    }
    else if ( !oSettings.bDestroying && !_fnAjaxUpdate( oSettings ) )
    {
      return;
    }
  
    if ( aiDisplay.length !== 0 )
    {
      var iStart = bServerSide ? 0 : iDisplayStart;
      var iEnd = bServerSide ? oSettings.aoData.length : iDisplayEnd;
  
      for ( var j=iStart ; j<iEnd ; j++ )
      {
        var iDataIndex = aiDisplay[j];
        var aoData = oSettings.aoData[ iDataIndex ];
        if ( aoData.nTr === null )
        {
          _fnCreateTr( oSettings, iDataIndex );
        }
  
        var nRow = aoData.nTr;
  
        /* Remove the old striping classes and then add the new one */
        if ( iStripes !== 0 )
        {
          var sStripe = asStripeClasses[ iRowCount % iStripes ];
          if ( aoData._sRowStripe != sStripe )
          {
            $(nRow).removeClass( aoData._sRowStripe ).addClass( sStripe );
            aoData._sRowStripe = sStripe;
          }
        }
  
        /* Row callback functions - might want to manipulate the row */
        _fnCallbackFire( oSettings, 'aoRowCallback', null,
          [nRow, aoData._aData, iRowCount, j] );
  
        anRows.push( nRow );
        iRowCount++;
      }
    }
    else
    {
      /* Table is empty - create a row with an empty message in it */
      var sZero = oLang.sZeroRecords;
      if ( oSettings.iDraw == 1 &&  _fnDataSource( oSettings ) == 'ajax' )
      {
        sZero = oLang.sLoadingRecords;
      }
      else if ( oLang.sEmptyTable && oSettings.fnRecordsTotal() === 0 )
      {
        sZero = oLang.sEmptyTable;
      }
  
      anRows[ 0 ] = $( '<tr/>', { 'class': iStripes ? asStripeClasses[0] : '' } )
        .append( $('<td />', {
          'valign':  'top',
          'colSpan': _fnVisbleColumns( oSettings ),
          'class':   oSettings.oClasses.sRowEmpty
        } ).html( sZero ) )[0];
    }
  
    /* Header and footer callbacks */
    _fnCallbackFire( oSettings, 'aoHeaderCallback', 'header', [ $(oSettings.nTHead).children('tr')[0],
      _fnGetDataMaster( oSettings ), iDisplayStart, iDisplayEnd, aiDisplay ] );
  
    _fnCallbackFire( oSettings, 'aoFooterCallback', 'footer', [ $(oSettings.nTFoot).children('tr')[0],
      _fnGetDataMaster( oSettings ), iDisplayStart, iDisplayEnd, aiDisplay ] );
  
    var body = $(oSettings.nTBody);
  
    body.children().detach();
    body.append( $(anRows) );
  
    /* Call all required callback functions for the end of a draw */
    _fnCallbackFire( oSettings, 'aoDrawCallback', 'draw', [oSettings] );
  
    /* Draw is complete, sorting and filtering must be as well */
    oSettings.bSorted = false;
    oSettings.bFiltered = false;
    oSettings.bDrawing = false;
  }
  
  
  /**
   * Redraw the table - taking account of the various features which are enabled
   *  @param {object} oSettings dataTables settings object
   *  @param {boolean} [holdPosition] Keep the current paging position. By default
   *    the paging is reset to the first page
   *  @memberof DataTable#oApi
   */
  function _fnReDraw( settings, holdPosition )
  {
    var
      features = settings.oFeatures,
      sort     = features.bSort,
      filter   = features.bFilter;
  
    if ( sort ) {
      _fnSort( settings );
    }
  
    if ( filter ) {
      _fnFilterComplete( settings, settings.oPreviousSearch );
    }
    else {
      // No filtering, so we want to just use the display master
      settings.aiDisplay = settings.aiDisplayMaster.slice();
    }
  
    if ( holdPosition !== true ) {
      settings._iDisplayStart = 0;
    }
  
    // Let any modules know about the draw hold position state (used by
    // scrolling internally)
    settings._drawHold = holdPosition;
  
    _fnDraw( settings );
  
    settings._drawHold = false;
  }
  
  
  /**
   * Add the options to the page HTML for the table
   *  @param {object} oSettings dataTables settings object
   *  @memberof DataTable#oApi
   */
  function _fnAddOptionsHtml ( oSettings )
  {
    var classes = oSettings.oClasses;
    var table = $(oSettings.nTable);
    var holding = $('<div/>').insertBefore( table ); // Holding element for speed
    var features = oSettings.oFeatures;
  
    // All DataTables are wrapped in a div
    var insert = $('<div/>', {
      id:      oSettings.sTableId+'_wrapper',
      'class': classes.sWrapper + (oSettings.nTFoot ? '' : ' '+classes.sNoFooter)
    } );
  
    oSettings.nHolding = holding[0];
    oSettings.nTableWrapper = insert[0];
    oSettings.nTableReinsertBefore = oSettings.nTable.nextSibling;
  
    /* Loop over the user set positioning and place the elements as needed */
    var aDom = oSettings.sDom.split('');
    var featureNode, cOption, nNewNode, cNext, sAttr, j;
    for ( var i=0 ; i<aDom.length ; i++ )
    {
      featureNode = null;
      cOption = aDom[i];
  
      if ( cOption == '<' )
      {
        /* New container div */
        nNewNode = $('<div/>')[0];
  
        /* Check to see if we should append an id and/or a class name to the container */
        cNext = aDom[i+1];
        if ( cNext == "'" || cNext == '"' )
        {
          sAttr = "";
          j = 2;
          while ( aDom[i+j] != cNext )
          {
            sAttr += aDom[i+j];
            j++;
          }
  
          /* Replace jQuery UI constants @todo depreciated */
          if ( sAttr == "H" )
          {
            sAttr = classes.sJUIHeader;
          }
          else if ( sAttr == "F" )
          {
            sAttr = classes.sJUIFooter;
          }
  
          /* The attribute can be in the format of "#id.class", "#id" or "class" This logic
           * breaks the string into parts and applies them as needed
           */
          if ( sAttr.indexOf('.') != -1 )
          {
            var aSplit = sAttr.split('.');
            nNewNode.id = aSplit[0].substr(1, aSplit[0].length-1);
            nNewNode.className = aSplit[1];
          }
          else if ( sAttr.charAt(0) == "#" )
          {
            nNewNode.id = sAttr.substr(1, sAttr.length-1);
          }
          else
          {
            nNewNode.className = sAttr;
          }
  
          i += j; /* Move along the position array */
        }
  
        insert.append( nNewNode );
        insert = $(nNewNode);
      }
      else if ( cOption == '>' )
      {
        /* End container div */
        insert = insert.parent();
      }
      // @todo Move options into their own plugins?
      else if ( cOption == 'l' && features.bPaginate && features.bLengthChange )
      {
        /* Length */
        featureNode = _fnFeatureHtmlLength( oSettings );
      }
      else if ( cOption == 'f' && features.bFilter )
      {
        /* Filter */
        featureNode = _fnFeatureHtmlFilter( oSettings );
      }
      else if ( cOption == 'r' && features.bProcessing )
      {
        /* pRocessing */
        featureNode = _fnFeatureHtmlProcessing( oSettings );
      }
      else if ( cOption == 't' )
      {
        /* Table */
        featureNode = _fnFeatureHtmlTable( oSettings );
      }
      else if ( cOption ==  'i' && features.bInfo )
      {
        /* Info */
        featureNode = _fnFeatureHtmlInfo( oSettings );
      }
      else if ( cOption == 'p' && features.bPaginate )
      {
        /* Pagination */
        featureNode = _fnFeatureHtmlPaginate( oSettings );
      }
      else if ( DataTable.ext.feature.length !== 0 )
      {
        /* Plug-in features */
        var aoFeatures = DataTable.ext.feature;
        for ( var k=0, kLen=aoFeatures.length ; k<kLen ; k++ )
        {
          if ( cOption == aoFeatures[k].cFeature )
          {
            featureNode = aoFeatures[k].fnInit( oSettings );
            break;
          }
        }
      }
  
      /* Add to the 2D features array */
      if ( featureNode )
      {
        var aanFeatures = oSettings.aanFeatures;
  
        if ( ! aanFeatures[cOption] )
        {
          aanFeatures[cOption] = [];
        }
  
        aanFeatures[cOption].push( featureNode );
        insert.append( featureNode );
      }
    }
  
    /* Built our DOM structure - replace the holding div with what we want */
    holding.replaceWith( insert );
  }
  
  
  /**
   * Use the DOM source to create up an array of header cells. The idea here is to
   * create a layout grid (array) of rows x columns, which contains a reference
   * to the cell that that point in the grid (regardless of col/rowspan), such that
   * any column / row could be removed and the new grid constructed
   *  @param array {object} aLayout Array to store the calculated layout in
   *  @param {node} nThead The header/footer element for the table
   *  @memberof DataTable#oApi
   */
  function _fnDetectHeader ( aLayout, nThead )
  {
    var nTrs = $(nThead).children('tr');
    var nTr, nCell;
    var i, k, l, iLen, jLen, iColShifted, iColumn, iColspan, iRowspan;
    var bUnique;
    var fnShiftCol = function ( a, i, j ) {
      var k = a[i];
                  while ( k[j] ) {
        j++;
      }
      return j;
    };
  
    aLayout.splice( 0, aLayout.length );
  
    /* We know how many rows there are in the layout - so prep it */
    for ( i=0, iLen=nTrs.length ; i<iLen ; i++ )
    {
      aLayout.push( [] );
    }
  
    /* Calculate a layout array */
    for ( i=0, iLen=nTrs.length ; i<iLen ; i++ )
    {
      nTr = nTrs[i];
      iColumn = 0;
  
      /* For every cell in the row... */
      nCell = nTr.firstChild;
      while ( nCell ) {
        if ( nCell.nodeName.toUpperCase() == "TD" ||
             nCell.nodeName.toUpperCase() == "TH" )
        {
          /* Get the col and rowspan attributes from the DOM and sanitise them */
          iColspan = nCell.getAttribute('colspan') * 1;
          iRowspan = nCell.getAttribute('rowspan') * 1;
          iColspan = (!iColspan || iColspan===0 || iColspan===1) ? 1 : iColspan;
          iRowspan = (!iRowspan || iRowspan===0 || iRowspan===1) ? 1 : iRowspan;
  
          /* There might be colspan cells already in this row, so shift our target
           * accordingly
           */
          iColShifted = fnShiftCol( aLayout, i, iColumn );
  
          /* Cache calculation for unique columns */
          bUnique = iColspan === 1 ? true : false;
  
          /* If there is col / rowspan, copy the information into the layout grid */
          for ( l=0 ; l<iColspan ; l++ )
          {
            for ( k=0 ; k<iRowspan ; k++ )
            {
              aLayout[i+k][iColShifted+l] = {
                "cell": nCell,
                "unique": bUnique
              };
              aLayout[i+k].nTr = nTr;
            }
          }
        }
        nCell = nCell.nextSibling;
      }
    }
  }
  
  
  /**
   * Get an array of unique th elements, one for each column
   *  @param {object} oSettings dataTables settings object
   *  @param {node} nHeader automatically detect the layout from this node - optional
   *  @param {array} aLayout thead/tfoot layout from _fnDetectHeader - optional
   *  @returns array {node} aReturn list of unique th's
   *  @memberof DataTable#oApi
   */
  function _fnGetUniqueThs ( oSettings, nHeader, aLayout )
  {
    var aReturn = [];
    if ( !aLayout )
    {
      aLayout = oSettings.aoHeader;
      if ( nHeader )
      {
        aLayout = [];
        _fnDetectHeader( aLayout, nHeader );
      }
    }
  
    for ( var i=0, iLen=aLayout.length ; i<iLen ; i++ )
    {
      for ( var j=0, jLen=aLayout[i].length ; j<jLen ; j++ )
      {
        if ( aLayout[i][j].unique &&
           (!aReturn[j] || !oSettings.bSortCellsTop) )
        {
          aReturn[j] = aLayout[i][j].cell;
        }
      }
    }
  
    return aReturn;
  }
  
  
  
  /**
   * Create an Ajax call based on the table's settings, taking into account that
   * parameters can have multiple forms, and backwards compatibility.
   *
   * @param {object} oSettings dataTables settings object
   * @param {array} data Data to send to the server, required by
   *     DataTables - may be augmented by developer callbacks
   * @param {function} fn Callback function to run when data is obtained
   */
  function _fnBuildAjax( oSettings, data, fn )
  {
    // Compatibility with 1.9-, allow fnServerData and event to manipulate
    _fnCallbackFire( oSettings, 'aoServerParams', 'serverParams', [data] );
  
    // Convert to object based for 1.10+ if using the old array scheme which can
    // come from server-side processing or serverParams
    if ( data && $.isArray(data) ) {
      var tmp = {};
      var rbracket = /(.*?)\[\]$/;
  
      $.each( data, function (key, val) {
        var match = val.name.match(rbracket);
  
        if ( match ) {
          // Support for arrays
          var name = match[0];
  
          if ( ! tmp[ name ] ) {
            tmp[ name ] = [];
          }
          tmp[ name ].push( val.value );
        }
        else {
          tmp[val.name] = val.value;
        }
      } );
      data = tmp;
    }
  
    var ajaxData;
    var ajax = oSettings.ajax;
    var instance = oSettings.oInstance;
  
    if ( $.isPlainObject( ajax ) && ajax.data )
    {
      ajaxData = ajax.data;
  
      var newData = $.isFunction( ajaxData ) ?
        ajaxData( data ) :  // fn can manipulate data or return an object
        ajaxData;           // object or array to merge
  
      // If the function returned an object, use that alone
      data = $.isFunction( ajaxData ) && newData ?
        newData :
        $.extend( true, data, newData );
  
      // Remove the data property as we've resolved it already and don't want
      // jQuery to do it again (it is restored at the end of the function)
      delete ajax.data;
    }
  
    var baseAjax = {
      "data": data,
      "success": function (json) {
        var error = json.error || json.sError;
        if ( error ) {
          oSettings.oApi._fnLog( oSettings, 0, error );
        }
  
        oSettings.json = json;
        _fnCallbackFire( oSettings, null, 'xhr', [oSettings, json] );
        fn( json );
      },
      "dataType": "json",
      "cache": false,
      "type": oSettings.sServerMethod,
      "error": function (xhr, error, thrown) {
        var log = oSettings.oApi._fnLog;
  
        if ( error == "parsererror" ) {
          log( oSettings, 0, 'Invalid JSON response', 1 );
        }
        else if ( xhr.readyState === 4 ) {
          log( oSettings, 0, 'Ajax error', 7 );
        }
  
        _fnProcessingDisplay( oSettings, false );
      }
    };
  
    // Store the data submitted for the API
    oSettings.oAjaxData = data;
  
    // Allow plug-ins and external processes to modify the data
    _fnCallbackFire( oSettings, null, 'preXhr', [oSettings, data] );
  
    if ( oSettings.fnServerData )
    {
      // DataTables 1.9- compatibility
      oSettings.fnServerData.call( instance,
        oSettings.sAjaxSource,
        $.map( data, function (val, key) { // Need to convert back to 1.9 trad format
          return { name: key, value: val };
        } ),
        fn,
        oSettings
      );
    }
    else if ( oSettings.sAjaxSource || typeof ajax === 'string' )
    {
      // DataTables 1.9- compatibility
      oSettings.jqXHR = $.ajax( $.extend( baseAjax, {
        url: ajax || oSettings.sAjaxSource
      } ) );
    }
    else if ( $.isFunction( ajax ) )
    {
      // Is a function - let the caller define what needs to be done
      oSettings.jqXHR = ajax.call( instance, data, fn, oSettings );
    }
    else
    {
      // Object to extend the base settings
      oSettings.jqXHR = $.ajax( $.extend( baseAjax, ajax ) );
  
      // Restore for next time around
      ajax.data = ajaxData;
    }
  }
  
  
  /**
   * Update the table using an Ajax call
   *  @param {object} settings dataTables settings object
   *  @returns {boolean} Block the table drawing or not
   *  @memberof DataTable#oApi
   */
  function _fnAjaxUpdate( settings )
  {
    if ( settings.bAjaxDataGet ) {
      settings.iDraw++;
      _fnProcessingDisplay( settings, true );
  
      _fnBuildAjax(
        settings,
        _fnAjaxParameters( settings ),
        function(json) {
          _fnAjaxUpdateDraw( settings, json );
        }
      );
  
      return false;
    }
    return true;
  }
  
  
  /**
   * Build up the parameters in an object needed for a server-side processing
   * request. Note that this is basically done twice, is different ways - a modern
   * method which is used by default in DataTables 1.10 which uses objects and
   * arrays, or the 1.9- method with is name / value pairs. 1.9 method is used if
   * the sAjaxSource option is used in the initialisation, or the legacyAjax
   * option is set.
   *  @param {object} oSettings dataTables settings object
   *  @returns {bool} block the table drawing or not
   *  @memberof DataTable#oApi
   */
  function _fnAjaxParameters( settings )
  {
    var
      columns = settings.aoColumns,
      columnCount = columns.length,
      features = settings.oFeatures,
      preSearch = settings.oPreviousSearch,
      preColSearch = settings.aoPreSearchCols,
      i, data = [], dataProp, column, columnSearch,
      sort = _fnSortFlatten( settings ),
      displayStart = settings._iDisplayStart,
      displayLength = features.bPaginate !== false ?
        settings._iDisplayLength :
        -1;
  
    var param = function ( name, value ) {
      data.push( { 'name': name, 'value': value } );
    };
  
    // DataTables 1.9- compatible method
    param( 'sEcho',          settings.iDraw );
    param( 'iColumns',       columnCount );
    param( 'sColumns',       _pluck( columns, 'sName' ).join(',') );
    param( 'iDisplayStart',  displayStart );
    param( 'iDisplayLength', displayLength );
  
    // DataTables 1.10+ method
    var d = {
      draw:    settings.iDraw,
      columns: [],
      order:   [],
      start:   displayStart,
      length:  displayLength,
      search:  {
        value: preSearch.sSearch,
        regex: preSearch.bRegex
      }
    };
  
    for ( i=0 ; i<columnCount ; i++ ) {
      column = columns[i];
      columnSearch = preColSearch[i];
      dataProp = typeof column.mData=="function" ? 'function' : column.mData ;
  
      d.columns.push( {
        data:       dataProp,
        name:       column.sName,
        searchable: column.bSearchable,
        orderable:  column.bSortable,
        search:     {
          value: columnSearch.sSearch,
          regex: columnSearch.bRegex
        }
      } );
  
      param( "mDataProp_"+i, dataProp );
  
      if ( features.bFilter ) {
        param( 'sSearch_'+i,     columnSearch.sSearch );
        param( 'bRegex_'+i,      columnSearch.bRegex );
        param( 'bSearchable_'+i, column.bSearchable );
      }
  
      if ( features.bSort ) {
        param( 'bSortable_'+i, column.bSortable );
      }
    }
  
    if ( features.bFilter ) {
      param( 'sSearch', preSearch.sSearch );
      param( 'bRegex', preSearch.bRegex );
    }
  
    if ( features.bSort ) {
      $.each( sort, function ( i, val ) {
        d.order.push( { column: val.col, dir: val.dir } );
  
        param( 'iSortCol_'+i, val.col );
        param( 'sSortDir_'+i, val.dir );
      } );
  
      param( 'iSortingCols', sort.length );
    }
  
    // If the legacy.ajax parameter is null, then we automatically decide which
    // form to use, based on sAjaxSource
    var legacy = DataTable.ext.legacy.ajax;
    if ( legacy === null ) {
      return settings.sAjaxSource ? data : d;
    }
  
    // Otherwise, if legacy has been specified then we use that to decide on the
    // form
    return legacy ? data : d;
  }
  
  
  /**
   * Data the data from the server (nuking the old) and redraw the table
   *  @param {object} oSettings dataTables settings object
   *  @param {object} json json data return from the server.
   *  @param {string} json.sEcho Tracking flag for DataTables to match requests
   *  @param {int} json.iTotalRecords Number of records in the data set, not accounting for filtering
   *  @param {int} json.iTotalDisplayRecords Number of records in the data set, accounting for filtering
   *  @param {array} json.aaData The data to display on this page
   *  @param {string} [json.sColumns] Column ordering (sName, comma separated)
   *  @memberof DataTable#oApi
   */
  function _fnAjaxUpdateDraw ( settings, json )
  {
    // v1.10 uses camelCase variables, while 1.9 uses Hungarian notation.
    // Support both
    var compat = function ( old, modern ) {
      return json[old] !== undefined ? json[old] : json[modern];
    };
  
    var draw            = compat( 'sEcho',                'draw' );
    var recordsTotal    = compat( 'iTotalRecords',        'recordsTotal' );
    var rocordsFiltered = compat( 'iTotalDisplayRecords', 'recordsFiltered' );
  
    if ( draw ) {
      // Protect against out of sequence returns
      if ( draw*1 < settings.iDraw ) {
        return;
      }
      settings.iDraw = draw * 1;
    }
  
    _fnClearTable( settings );
    settings._iRecordsTotal   = parseInt(recordsTotal, 10);
    settings._iRecordsDisplay = parseInt(rocordsFiltered, 10);
  
    var data = _fnAjaxDataSrc( settings, json );
    for ( var i=0, ien=data.length ; i<ien ; i++ ) {
      _fnAddData( settings, data[i] );
    }
    settings.aiDisplay = settings.aiDisplayMaster.slice();
  
    settings.bAjaxDataGet = false;
    _fnDraw( settings );
  
    if ( ! settings._bInitComplete ) {
      _fnInitComplete( settings, json );
    }
  
    settings.bAjaxDataGet = true;
    _fnProcessingDisplay( settings, false );
  }
  
  
  /**
   * Get the data from the JSON data source to use for drawing a table. Using
   * `_fnGetObjectDataFn` allows the data to be sourced from a property of the
   * source object, or from a processing function.
   *  @param {object} oSettings dataTables settings object
   *  @param  {object} json Data source object / array from the server
   *  @return {array} Array of data to use
   */
  function _fnAjaxDataSrc ( oSettings, json )
  {
    var dataSrc = $.isPlainObject( oSettings.ajax ) && oSettings.ajax.dataSrc !== undefined ?
      oSettings.ajax.dataSrc :
      oSettings.sAjaxDataProp; // Compatibility with 1.9-.
  
    // Compatibility with 1.9-. In order to read from aaData, check if the
    // default has been changed, if not, check for aaData
    if ( dataSrc === 'data' ) {
      return json.aaData || json[dataSrc];
    }
  
    return dataSrc !== "" ?
      _fnGetObjectDataFn( dataSrc )( json ) :
      json;
  }
  
  
  /**
   * Generate the node required for filtering text
   *  @returns {node} Filter control element
   *  @param {object} oSettings dataTables settings object
   *  @memberof DataTable#oApi
   */
  function _fnFeatureHtmlFilter ( settings )
  {
    var classes = settings.oClasses;
    var tableId = settings.sTableId;
    var language = settings.oLanguage;
    var previousSearch = settings.oPreviousSearch;
    var features = settings.aanFeatures;
    var input = '<input type="search" class="'+classes.sFilterInput+'"/>';
  
    var str = '';
    str = str.match(/_INPUT_/) ?
      str.replace('_INPUT_', input) :
      str+input;
  
    var filter = $('<div/>', {
        'id': ! features.f ? tableId+'_filter' : null,
        'class': classes.sFilter
      } )
      .append( $('<label/>' ).append( str ) );
  
    var searchFn = function() {
      /* Update all other filter input elements for the new display */
      var n = features.f;
      var val = !this.value ? "" : this.value; // mental IE8 fix :-(
  
      /* Now do the filter */
      if ( val != previousSearch.sSearch ) {
        _fnFilterComplete( settings, {
          "sSearch": val,
          "bRegex": previousSearch.bRegex,
          "bSmart": previousSearch.bSmart ,
          "bCaseInsensitive": previousSearch.bCaseInsensitive
        } );
  
        // Need to redraw, without resorting
        settings._iDisplayStart = 0;
        _fnDraw( settings );
      }
    };
    var jqFilter = $('input', filter)
      .val( previousSearch.sSearch )
      .attr( 'placeholder', language.sSearchPlaceholder )
      .bind(
        'keyup.DT search.DT input.DT paste.DT cut.DT',
        _fnDataSource( settings ) === 'ssp' ?
          _fnThrottle( searchFn, 400 ):
          searchFn
      )
      .bind( 'keypress.DT', function(e) {
        /* Prevent form submission */
        if ( e.keyCode == 13 ) {
          return false;
        }
      } )
      .attr('aria-controls', tableId);
  
    // Update the input elements whenever the table is filtered
    $(settings.nTable).on( 'search.dt.DT', function ( ev, s ) {
      if ( settings === s ) {
        // IE9 throws an 'unknown error' if document.activeElement is used
        // inside an iframe or frame...
        try {
          if ( jqFilter[0] !== document.activeElement ) {
            jqFilter.val( previousSearch.sSearch );
          }
        }
        catch ( e ) {}
      }
    } );
  
    return filter[0];
  }
  
  
  /**
   * Filter the table using both the global filter and column based filtering
   *  @param {object} oSettings dataTables settings object
   *  @param {object} oSearch search information
   *  @param {int} [iForce] force a research of the master array (1) or not (undefined or 0)
   *  @memberof DataTable#oApi
   */
  function _fnFilterComplete ( oSettings, oInput, iForce )
  {
    var oPrevSearch = oSettings.oPreviousSearch;
    var aoPrevSearch = oSettings.aoPreSearchCols;
    var fnSaveFilter = function ( oFilter ) {
      /* Save the filtering values */
      oPrevSearch.sSearch = oFilter.sSearch;
      oPrevSearch.bRegex = oFilter.bRegex;
      oPrevSearch.bSmart = oFilter.bSmart;
      oPrevSearch.bCaseInsensitive = oFilter.bCaseInsensitive;
    };
    var fnRegex = function ( o ) {
      // Backwards compatibility with the bEscapeRegex option
      return o.bEscapeRegex !== undefined ? !o.bEscapeRegex : o.bRegex;
    };
  
    // Resolve any column types that are unknown due to addition or invalidation
    // @todo As per sort - can this be moved into an event handler?
    _fnColumnTypes( oSettings );
  
    /* In server-side processing all filtering is done by the server, so no point hanging around here */
    if ( _fnDataSource( oSettings ) != 'ssp' )
    {
      /* Global filter */
      _fnFilter( oSettings, oInput.sSearch, iForce, fnRegex(oInput), oInput.bSmart, oInput.bCaseInsensitive );
      fnSaveFilter( oInput );
  
      /* Now do the individual column filter */
      for ( var i=0 ; i<aoPrevSearch.length ; i++ )
      {
        _fnFilterColumn( oSettings, aoPrevSearch[i].sSearch, i, fnRegex(aoPrevSearch[i]),
          aoPrevSearch[i].bSmart, aoPrevSearch[i].bCaseInsensitive );
      }
  
      /* Custom filtering */
      _fnFilterCustom( oSettings );
    }
    else
    {
      fnSaveFilter( oInput );
    }
  
    /* Tell the draw function we have been filtering */
    oSettings.bFiltered = true;
    _fnCallbackFire( oSettings, null, 'search', [oSettings] );
  }
  
  
  /**
   * Apply custom filtering functions
   *  @param {object} oSettings dataTables settings object
   *  @memberof DataTable#oApi
   */
  function _fnFilterCustom( settings )
  {
    var filters = DataTable.ext.search;
    var displayRows = settings.aiDisplay;
    var row, rowIdx;
  
    for ( var i=0, ien=filters.length ; i<ien ; i++ ) {
      var rows = [];
  
      // Loop over each row and see if it should be included
      for ( var j=0, jen=displayRows.length ; j<jen ; j++ ) {
        rowIdx = displayRows[ j ];
        row = settings.aoData[ rowIdx ];
  
        if ( filters[i]( settings, row._aFilterData, rowIdx, row._aData, j ) ) {
          rows.push( rowIdx );
        }
      }
  
      // So the array reference doesn't break set the results into the
      // existing array
      displayRows.length = 0;
      displayRows.push.apply( displayRows, rows );
    }
  }
  
  
  /**
   * Filter the table on a per-column basis
   *  @param {object} oSettings dataTables settings object
   *  @param {string} sInput string to filter on
   *  @param {int} iColumn column to filter
   *  @param {bool} bRegex treat search string as a regular expression or not
   *  @param {bool} bSmart use smart filtering or not
   *  @param {bool} bCaseInsensitive Do case insenstive matching or not
   *  @memberof DataTable#oApi
   */
  function _fnFilterColumn ( settings, searchStr, colIdx, regex, smart, caseInsensitive )
  {
    if ( searchStr === '' ) {
      return;
    }
  
    var data;
    var display = settings.aiDisplay;
    var rpSearch = _fnFilterCreateSearch( searchStr, regex, smart, caseInsensitive );
  
    for ( var i=display.length-1 ; i>=0 ; i-- ) {
      data = settings.aoData[ display[i] ]._aFilterData[ colIdx ];
  
      if ( ! rpSearch.test( data ) ) {
        display.splice( i, 1 );
      }
    }
  }
  
  
  /**
   * Filter the data table based on user input and draw the table
   *  @param {object} settings dataTables settings object
   *  @param {string} input string to filter on
   *  @param {int} force optional - force a research of the master array (1) or not (undefined or 0)
   *  @param {bool} regex treat as a regular expression or not
   *  @param {bool} smart perform smart filtering or not
   *  @param {bool} caseInsensitive Do case insenstive matching or not
   *  @memberof DataTable#oApi
   */
  function _fnFilter( settings, input, force, regex, smart, caseInsensitive )
  {
    var rpSearch = _fnFilterCreateSearch( input, regex, smart, caseInsensitive );
    var prevSearch = settings.oPreviousSearch.sSearch;
    var displayMaster = settings.aiDisplayMaster;
    var display, invalidated, i;
  
    // Need to take account of custom filtering functions - always filter
    if ( DataTable.ext.search.length !== 0 ) {
      force = true;
    }
  
    // Check if any of the rows were invalidated
    invalidated = _fnFilterData( settings );
  
    // If the input is blank - we just want the full data set
    if ( input.length <= 0 ) {
      settings.aiDisplay = displayMaster.slice();
    }
    else {
      // New search - start from the master array
      if ( invalidated ||
         force ||
         prevSearch.length > input.length ||
         input.indexOf(prevSearch) !== 0 ||
         settings.bSorted // On resort, the display master needs to be
                          // re-filtered since indexes will have changed
      ) {
        settings.aiDisplay = displayMaster.slice();
      }
  
      // Search the display array
      display = settings.aiDisplay;
  
      for ( i=display.length-1 ; i>=0 ; i-- ) {
        if ( ! rpSearch.test( settings.aoData[ display[i] ]._sFilterRow ) ) {
          display.splice( i, 1 );
        }
      }
    }
  }
  
  
  /**
   * Build a regular expression object suitable for searching a table
   *  @param {string} sSearch string to search for
   *  @param {bool} bRegex treat as a regular expression or not
   *  @param {bool} bSmart perform smart filtering or not
   *  @param {bool} bCaseInsensitive Do case insensitive matching or not
   *  @returns {RegExp} constructed object
   *  @memberof DataTable#oApi
   */
  function _fnFilterCreateSearch( search, regex, smart, caseInsensitive )
  {
    search = regex ?
      search :
      _fnEscapeRegex( search );
    
    if ( smart ) {
      /* For smart filtering we want to allow the search to work regardless of
       * word order. We also want double quoted text to be preserved, so word
       * order is important - a la google. So this is what we want to
       * generate:
       * 
       * ^(?=.*?\bone\b)(?=.*?\btwo three\b)(?=.*?\bfour\b).*$
       */
      var a = $.map( search.match( /"[^"]+"|[^ ]+/g ) || '', function ( word ) {
        return word.charAt(0) === '"' ?
          word.match( /^"(.*)"$/ )[1] :
          word;
      } );
  
      search = '^(?=.*?'+a.join( ')(?=.*?' )+').*$';
    }
  
    return new RegExp( search, caseInsensitive ? 'i' : '' );
  }
  
  
  /**
   * scape a string such that it can be used in a regular expression
   *  @param {string} sVal string to escape
   *  @returns {string} escaped string
   *  @memberof DataTable#oApi
   */
  function _fnEscapeRegex ( sVal )
  {
    return sVal.replace( _re_escape_regex, '\\$1' );
  }
  
  
  
  var __filter_div = $('<div>')[0];
  var __filter_div_textContent = __filter_div.textContent !== undefined;
  
  // Update the filtering data for each row if needed (by invalidation or first run)
  function _fnFilterData ( settings )
  {
    var columns = settings.aoColumns;
    var column;
    var i, j, ien, jen, filterData, cellData, row;
    var fomatters = DataTable.ext.type.search;
    var wasInvalidated = false;
  
    for ( i=0, ien=settings.aoData.length ; i<ien ; i++ ) {
      row = settings.aoData[i];
  
      if ( ! row._aFilterData ) {
        filterData = [];
  
        for ( j=0, jen=columns.length ; j<jen ; j++ ) {
          column = columns[j];
  
          if ( column.bSearchable ) {
            cellData = _fnGetCellData( settings, i, j, 'filter' );
  
            if ( fomatters[ column.sType ] ) {
              cellData = fomatters[ column.sType ]( cellData );
            }
  
            // Search in DataTables 1.10 is string based. In 1.11 this
            // should be altered to also allow strict type checking.
            if ( cellData === null ) {
              cellData = '';
            }
  
            if ( typeof cellData !== 'string' && cellData.toString ) {
              cellData = cellData.toString();
            }
          }
          else {
            cellData = '';
          }
  
          // If it looks like there is an HTML entity in the string,
          // attempt to decode it so sorting works as expected. Note that
          // we could use a single line of jQuery to do this, but the DOM
          // method used here is much faster http://jsperf.com/html-decode
          if ( cellData.indexOf && cellData.indexOf('&') !== -1 ) {
            __filter_div.innerHTML = cellData;
            cellData = __filter_div_textContent ?
              __filter_div.textContent :
              __filter_div.innerText;
          }
  
          if ( cellData.replace ) {
            cellData = cellData.replace(/[\r\n]/g, '');
          }
  
          filterData.push( cellData );
        }
  
        row._aFilterData = filterData;
        row._sFilterRow = filterData.join('  ');
        wasInvalidated = true;
      }
    }
  
    return wasInvalidated;
  }
  
  
  /**
   * Convert from the internal Hungarian notation to camelCase for external
   * interaction
   *  @param {object} obj Object to convert
   *  @returns {object} Inverted object
   *  @memberof DataTable#oApi
   */
  function _fnSearchToCamel ( obj )
  {
    return {
      search:          obj.sSearch,
      smart:           obj.bSmart,
      regex:           obj.bRegex,
      caseInsensitive: obj.bCaseInsensitive
    };
  }
  
  
  
  /**
   * Convert from camelCase notation to the internal Hungarian. We could use the
   * Hungarian convert function here, but this is cleaner
   *  @param {object} obj Object to convert
   *  @returns {object} Inverted object
   *  @memberof DataTable#oApi
   */
  function _fnSearchToHung ( obj )
  {
    return {
      sSearch:          obj.search,
      bSmart:           obj.smart,
      bRegex:           obj.regex,
      bCaseInsensitive: obj.caseInsensitive
    };
  }
  
  /**
   * Generate the node required for the info display
   *  @param {object} oSettings dataTables settings object
   *  @returns {node} Information element
   *  @memberof DataTable#oApi
   */
  function _fnFeatureHtmlInfo ( settings )
  {
    var
      tid = settings.sTableId,
      nodes = settings.aanFeatures.i,
      n = $('<div/>', {
        'class': settings.oClasses.sInfo,
        'id': ! nodes ? tid+'_info' : null
      } );
  
    if ( ! nodes ) {
      // Update display on each draw
      settings.aoDrawCallback.push( {
        "fn": _fnUpdateInfo,
        "sName": "information"
      } );
  
      n
        .attr( 'role', 'status' )
        .attr( 'aria-live', 'polite' );
  
      // Table is described by our info div
      $(settings.nTable).attr( 'aria-describedby', tid+'_info' );
    }
  
    return n[0];
  }
  
  
  /**
   * Update the information elements in the display
   *  @param {object} settings dataTables settings object
   *  @memberof DataTable#oApi
   */
  function _fnUpdateInfo ( settings )
  {
    /* Show information about the table */
    var nodes = settings.aanFeatures.i;
    if ( nodes.length === 0 ) {
      return;
    }
  
    var
      lang  = settings.oLanguage,
      start = settings._iDisplayStart+1,
      end   = settings.fnDisplayEnd(),
      max   = settings.fnRecordsTotal(),
      total = settings.fnRecordsDisplay(),
      out   = total ?
        lang.sInfo :
        lang.sInfoEmpty;
  
    if ( total !== max ) {
      /* Record set after filtering */
      out += ' ' + lang.sInfoFiltered;
    }
  
    // Convert the macros
    out += lang.sInfoPostFix;
    out = _fnInfoMacros( settings, out );
  
    var callback = lang.fnInfoCallback;
    if ( callback !== null ) {
      out = callback.call( settings.oInstance,
        settings, start, end, max, total, out
      );
    }
  
    $(nodes).html( out );
  }
  
  
  function _fnInfoMacros ( settings, str )
  {
    // When infinite scrolling, we are always starting at 1. _iDisplayStart is used only
    // internally
    var
      formatter  = settings.fnFormatNumber,
      start      = settings._iDisplayStart+1,
      len        = settings._iDisplayLength,
      vis        = settings.fnRecordsDisplay(),
      all        = len === -1;
  
    return str.
      replace(/_START_/g, formatter.call( settings, start ) ).
      replace(/_END_/g,   formatter.call( settings, settings.fnDisplayEnd() ) ).
      replace(/_MAX_/g,   formatter.call( settings, settings.fnRecordsTotal() ) ).
      replace(/_TOTAL_/g, formatter.call( settings, vis ) ).
      replace(/_PAGE_/g,  formatter.call( settings, all ? 1 : Math.ceil( start / len ) ) ).
      replace(/_PAGES_/g, formatter.call( settings, all ? 1 : Math.ceil( vis / len ) ) );
  }
  
  
  
  /**
   * Draw the table for the first time, adding all required features
   *  @param {object} settings dataTables settings object
   *  @memberof DataTable#oApi
   */
  function _fnInitialise ( settings )
  {
    var i, iLen, iAjaxStart=settings.iInitDisplayStart;
    var columns = settings.aoColumns, column;
    var features = settings.oFeatures;
  
    /* Ensure that the table data is fully initialised */
    if ( ! settings.bInitialised ) {
      setTimeout( function(){ _fnInitialise( settings ); }, 200 );
      return;
    }
  
    /* Show the display HTML options */
    _fnAddOptionsHtml( settings );
  
    /* Build and draw the header / footer for the table */
    _fnBuildHead( settings );
    _fnDrawHead( settings, settings.aoHeader );
    _fnDrawHead( settings, settings.aoFooter );
  
    /* Okay to show that something is going on now */
    _fnProcessingDisplay( settings, true );
  
    /* Calculate sizes for columns */
    if ( features.bAutoWidth ) {
      _fnCalculateColumnWidths( settings );
    }
  
    for ( i=0, iLen=columns.length ; i<iLen ; i++ ) {
      column = columns[i];
  
      if ( column.sWidth ) {
        column.nTh.style.width = _fnStringToCss( column.sWidth );
      }
    }
  
    // If there is default sorting required - let's do it. The sort function
    // will do the drawing for us. Otherwise we draw the table regardless of the
    // Ajax source - this allows the table to look initialised for Ajax sourcing
    // data (show 'loading' message possibly)
    _fnReDraw( settings );
  
    // Server-side processing init complete is done by _fnAjaxUpdateDraw
    var dataSrc = _fnDataSource( settings );
    if ( dataSrc != 'ssp' ) {
      // if there is an ajax source load the data
      if ( dataSrc == 'ajax' ) {
        _fnBuildAjax( settings, [], function(json) {
          var aData = _fnAjaxDataSrc( settings, json );
  
          // Got the data - add it to the table
          for ( i=0 ; i<aData.length ; i++ ) {
            _fnAddData( settings, aData[i] );
          }
  
          // Reset the init display for cookie saving. We've already done
          // a filter, and therefore cleared it before. So we need to make
          // it appear 'fresh'
          settings.iInitDisplayStart = iAjaxStart;
  
          _fnReDraw( settings );
  
          _fnProcessingDisplay( settings, false );
          _fnInitComplete( settings, json );
        }, settings );
      }
      else {
        _fnProcessingDisplay( settings, false );
        _fnInitComplete( settings );
      }
    }
  }
  
  
  /**
   * Draw the table for the first time, adding all required features
   *  @param {object} oSettings dataTables settings object
   *  @param {object} [json] JSON from the server that completed the table, if using Ajax source
   *    with client-side processing (optional)
   *  @memberof DataTable#oApi
   */
  function _fnInitComplete ( settings, json )
  {
    settings._bInitComplete = true;
  
    // On an Ajax load we now have data and therefore want to apply the column
    // sizing
    if ( json ) {
      _fnAdjustColumnSizing( settings );
    }
  
    _fnCallbackFire( settings, 'aoInitComplete', 'init', [settings, json] );
  }
  
  
  function _fnLengthChange ( settings, val )
  {
    var len = parseInt( val, 10 );
    settings._iDisplayLength = len;
  
    _fnLengthOverflow( settings );
  
    // Fire length change event
    _fnCallbackFire( settings, null, 'length', [settings, len] );
  }
  
  
  /**
   * Generate the node required for user display length changing
   *  @param {object} settings dataTables settings object
   *  @returns {node} Display length feature node
   *  @memberof DataTable#oApi
   */
  function _fnFeatureHtmlLength ( settings )
  {
    var
      classes  = settings.oClasses,
      tableId  = settings.sTableId,
      menu     = settings.aLengthMenu,
      d2       = $.isArray( menu[0] ),
      lengths  = d2 ? menu[0] : menu,
      language = d2 ? menu[1] : menu;
  
    var select = $('<select/>', {
      'name':          tableId+'_length',
      'aria-controls': tableId,
      'class':         classes.sLengthSelect
    } );
  
    for ( var i=0, ien=lengths.length ; i<ien ; i++ ) {
      select[0][ i ] = new Option( language[i], lengths[i] );
    }
  
    var div = $('<div><label/></div>').addClass( classes.sLength );
    if ( ! settings.aanFeatures.l ) {
      div[0].id = tableId+'_length';
    }
  
    div.children().append(
      settings.oLanguage.sLengthMenu.replace( '_MENU_', select[0].outerHTML )
    );
  
    // Can't use `select` variable as user might provide their own and the
    // reference is broken by the use of outerHTML
    $('select', div)
      .val( settings._iDisplayLength )
      .bind( 'change.DT', function(e) {
        _fnLengthChange( settings, $(this).val() );
        _fnDraw( settings );
      } );
  
    // Update node value whenever anything changes the table's length
    $(settings.nTable).bind( 'length.dt.DT', function (e, s, len) {
      if ( settings === s ) {
        $('select', div).val( len );
      }
    } );
  
    return div[0];
  }
  
  
  
  /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
   * Note that most of the paging logic is done in
   * DataTable.ext.pager
   */
  
  /**
   * Generate the node required for default pagination
   *  @param {object} oSettings dataTables settings object
   *  @returns {node} Pagination feature node
   *  @memberof DataTable#oApi
   */
  function _fnFeatureHtmlPaginate ( settings )
  {
    var
      type   = settings.sPaginationType,
      plugin = DataTable.ext.pager[ type ],
      modern = typeof plugin === 'function',
      redraw = function( settings ) {
        _fnDraw( settings );
      },
      node = $('<div/>').addClass( settings.oClasses.sPaging + type )[0],
      features = settings.aanFeatures;
  
    if ( ! modern ) {
      plugin.fnInit( settings, node, redraw );
    }
  
    /* Add a draw callback for the pagination on first instance, to update the paging display */
    if ( ! features.p )
    {
      node.id = settings.sTableId+'_paginate';
  
      settings.aoDrawCallback.push( {
        "fn": function( settings ) {
          if ( modern ) {
            var
              start      = settings._iDisplayStart,
              len        = settings._iDisplayLength,
              visRecords = settings.fnRecordsDisplay(),
              all        = len === -1,
              page = all ? 0 : Math.ceil( start / len ),
              pages = all ? 1 : Math.ceil( visRecords / len ),
              buttons = plugin(page, pages),
              i, ien;
  
            for ( i=0, ien=features.p.length ; i<ien ; i++ ) {
              _fnRenderer( settings, 'pageButton' )(
                settings, features.p[i], i, buttons, page, pages
              );
            }
          }
          else {
            plugin.fnUpdate( settings, redraw );
          }
        },
        "sName": "pagination"
      } );
    }
  
    return node;
  }
  
  
  /**
   * Alter the display settings to change the page
   *  @param {object} settings DataTables settings object
   *  @param {string|int} action Paging action to take: "first", "previous",
   *    "next" or "last" or page number to jump to (integer)
   *  @param [bool] redraw Automatically draw the update or not
   *  @returns {bool} true page has changed, false - no change
   *  @memberof DataTable#oApi
   */
  function _fnPageChange ( settings, action, redraw )
  {
    var
      start     = settings._iDisplayStart,
      len       = 1,//settings._iDisplayLength,
      records   = settings.fnRecordsDisplay();
  
    if ( records === 0 || len === -1 )
    {
      start = 0;
    }
    else if ( typeof action === "number" )
    {
      start = action * len;
  
      if ( start > records )
      {
        start = 0;
      }
    }
    else if ( action == "first" )
    {
      start = 0;
    }
    else if ( action == "previous" )
    {
      start = len >= 0 ?
        start - len :
        0;
  
      if ( start < 0 )
      {
        start = 0;
      }
    }
    else if ( action == "next" )
    {
      if ( start + len < records )
      {
        start += len;
      }
    }
    else if ( action == "last" )
    {
      start = Math.floor( (records-1) / len) * len;
    }
    else
    {
      _fnLog( settings, 0, "Unknown paging action: "+action, 5 );
    }
  
    var changed = settings._iDisplayStart !== start;
    settings._iDisplayStart = start;
  
    if ( changed ) {
      _fnCallbackFire( settings, null, 'page', [settings] );
  
      if ( redraw ) {
        _fnDraw( settings );
      }
    }
  
    return changed;
  }
  
  
  
  /**
   * Generate the node required for the processing node
   *  @param {object} settings dataTables settings object
   *  @returns {node} Processing element
   *  @memberof DataTable#oApi
   */
  function _fnFeatureHtmlProcessing ( settings )
  {
    return $('<div/>', {
        'id': ! settings.aanFeatures.r ? settings.sTableId+'_processing' : null,
        'class': settings.oClasses.sProcessing
      } )
      .html( settings.oLanguage.sProcessing )
      .insertBefore( settings.nTable )[0];
  }
  
  
  /**
   * Display or hide the processing indicator
   *  @param {object} settings dataTables settings object
   *  @param {bool} show Show the processing indicator (true) or not (false)
   *  @memberof DataTable#oApi
   */
  function _fnProcessingDisplay ( settings, show )
  {
    if ( settings.oFeatures.bProcessing ) {
      $(settings.aanFeatures.r).css( 'display', show ? 'block' : 'none' );
    }
  
    _fnCallbackFire( settings, null, 'processing', [settings, show] );
  }
  
  /**
   * Add any control elements for the table - specifically scrolling
   *  @param {object} settings dataTables settings object
   *  @returns {node} Node to add to the DOM
   *  @memberof DataTable#oApi
   */
  function _fnFeatureHtmlTable ( settings )
  {
    var table = $(settings.nTable);
  
    // Add the ARIA grid role to the table
    table.attr( 'role', 'grid' );
  
    // Scrolling from here on in
    var scroll = settings.oScroll;
  
    if ( scroll.sX === '' && scroll.sY === '' ) {
      return settings.nTable;
    }
  
    var scrollX = scroll.sX;
    var scrollY = scroll.sY;
    var classes = settings.oClasses;
    var caption = table.children('caption');
    var captionSide = caption.length ? caption[0]._captionSide : null;
    var headerClone = $( table[0].cloneNode(false) );
    var footerClone = $( table[0].cloneNode(false) );
    var footer = table.children('tfoot');
    var _div = '<div/>';
    var size = function ( s ) {
      return !s ? null : _fnStringToCss( s );
    };
  
    // This is fairly messy, but with x scrolling enabled, if the table has a
    // width attribute, regardless of any width applied using the column width
    // options, the browser will shrink or grow the table as needed to fit into
    // that 100%. That would make the width options useless. So we remove it.
    // This is okay, under the assumption that width:100% is applied to the
    // table in CSS (it is in the default stylesheet) which will set the table
    // width as appropriate (the attribute and css behave differently...)
    if ( scroll.sX && table.attr('width') === '100%' ) {
      table.removeAttr('width');
    }
  
    if ( ! footer.length ) {
      footer = null;
    }
  
    /*
     * The HTML structure that we want to generate in this function is:
     *  div - scroller
     *    div - scroll head
     *      div - scroll head inner
     *        table - scroll head table
     *          thead - thead
     *    div - scroll body
     *      table - table (master table)
     *        thead - thead clone for sizing
     *        tbody - tbody
     *    div - scroll foot
     *      div - scroll foot inner
     *        table - scroll foot table
     *          tfoot - tfoot
     */
    var scroller = $( _div, { 'class': classes.sScrollWrapper } )
      .append(
        $(_div, { 'class': classes.sScrollHead } )
          .css( {
            overflow: 'hidden',
            position: 'relative',
            border: 0,
            width: scrollX ? size(scrollX) : '100%'
          } )
          .append(
            $(_div, { 'class': classes.sScrollHeadInner } )
              .css( {
                'box-sizing': 'content-box',
                width: scroll.sXInner || '100%'
              } )
              .append(
                headerClone
                  .removeAttr('id')
                  .css( 'margin-left', 0 )
                  .append(
                    table.children('thead')
                  )
              )
          )
          .append( captionSide === 'top' ? caption : null )
      )
      .append(
        $(_div, { 'class': classes.sScrollBody } )
          .css( {
            overflow: 'auto',
            height: size( scrollY ),
            width: size( scrollX )
          } )
          .append( table )
      );
  
    if ( footer ) {
      scroller.append(
        $(_div, { 'class': classes.sScrollFoot } )
          .css( {
            overflow: 'hidden',
            border: 0,
            width: scrollX ? size(scrollX) : '100%'
          } )
          .append(
            $(_div, { 'class': classes.sScrollFootInner } )
              .append(
                footerClone
                  .removeAttr('id')
                  .css( 'margin-left', 0 )
                  .append(
                    table.children('tfoot')
                  )
              )
          )
          .append( captionSide === 'bottom' ? caption : null )
      );
    }
  
    var children = scroller.children();
    var scrollHead = children[0];
    var scrollBody = children[1];
    var scrollFoot = footer ? children[2] : null;
  
    // When the body is scrolled, then we also want to scroll the headers
    if ( scrollX ) {
      $(scrollBody).scroll( function (e) {
        var scrollLeft = this.scrollLeft;
  
        scrollHead.scrollLeft = scrollLeft;
  
        if ( footer ) {
          scrollFoot.scrollLeft = scrollLeft;
        }
      } );
    }
  
    settings.nScrollHead = scrollHead;
    settings.nScrollBody = scrollBody;
    settings.nScrollFoot = scrollFoot;
  
    // On redraw - align columns
    settings.aoDrawCallback.push( {
      "fn": _fnScrollDraw,
      "sName": "scrolling"
    } );
  
    return scroller[0];
  }
  
  
  
  /**
   * Update the header, footer and body tables for resizing - i.e. column
   * alignment.
   *
   * Welcome to the most horrible function DataTables. The process that this
   * function follows is basically:
   *   1. Re-create the table inside the scrolling div
   *   2. Take live measurements from the DOM
   *   3. Apply the measurements to align the columns
   *   4. Clean up
   *
   *  @param {object} settings dataTables settings object
   *  @memberof DataTable#oApi
   */
  function _fnScrollDraw ( settings )
  {
    // Given that this is such a monster function, a lot of variables are use
    // to try and keep the minimised size as small as possible
    var
      scroll         = settings.oScroll,
      scrollX        = scroll.sX,
      scrollXInner   = scroll.sXInner,
      scrollY        = scroll.sY,
      barWidth       = scroll.iBarWidth,
      divHeader      = $(settings.nScrollHead),
      divHeaderStyle = divHeader[0].style,
      divHeaderInner = divHeader.children('div'),
      divHeaderInnerStyle = divHeaderInner[0].style,
      divHeaderTable = divHeaderInner.children('table'),
      divBodyEl      = settings.nScrollBody,
      divBody        = $(divBodyEl),
      divBodyStyle   = divBodyEl.style,
      divFooter      = $(settings.nScrollFoot),
      divFooterInner = divFooter.children('div'),
      divFooterTable = divFooterInner.children('table'),
      header         = $(settings.nTHead),
      table          = $(settings.nTable),
      tableEl        = table[0],
      tableStyle     = tableEl.style,
      footer         = settings.nTFoot ? $(settings.nTFoot) : null,
      browser        = settings.oBrowser,
      ie67           = browser.bScrollOversize,
      headerTrgEls, footerTrgEls,
      headerSrcEls, footerSrcEls,
      headerCopy, footerCopy,
      headerWidths=[], footerWidths=[],
      headerContent=[],
      idx, correction, sanityWidth,
      zeroOut = function(nSizer) {
        var style = nSizer.style;
        style.paddingTop = "0";
        style.paddingBottom = "0";
        style.borderTopWidth = "0";
        style.borderBottomWidth = "0";
        style.height = 0;
      };
  
    /*
     * 1. Re-create the table inside the scrolling div
     */
  
    // Remove the old minimised thead and tfoot elements in the inner table
    table.children('thead, tfoot').remove();
  
    // Clone the current header and footer elements and then place it into the inner table
    headerCopy = header.clone().prependTo( table );
    headerTrgEls = header.find('tr'); // original header is in its own table
    headerSrcEls = headerCopy.find('tr');
    headerCopy.find('th, td').removeAttr('tabindex');
  
    if ( footer ) {
      footerCopy = footer.clone().prependTo( table );
      footerTrgEls = footer.find('tr'); // the original tfoot is in its own table and must be sized
      footerSrcEls = footerCopy.find('tr');
    }
  
  
    /*
     * 2. Take live measurements from the DOM - do not alter the DOM itself!
     */
  
    // Remove old sizing and apply the calculated column widths
    // Get the unique column headers in the newly created (cloned) header. We want to apply the
    // calculated sizes to this header
    if ( ! scrollX )
    {
      divBodyStyle.width = '100%';
      divHeader[0].style.width = '100%';
    }
  
    $.each( _fnGetUniqueThs( settings, headerCopy ), function ( i, el ) {
      idx = _fnVisibleToColumnIndex( settings, i );
      el.style.width = settings.aoColumns[idx].sWidth;
    } );
  
    if ( footer ) {
      _fnApplyToChildren( function(n) {
        n.style.width = "";
      }, footerSrcEls );
    }
  
    // If scroll collapse is enabled, when we put the headers back into the body for sizing, we
    // will end up forcing the scrollbar to appear, making our measurements wrong for when we
    // then hide it (end of this function), so add the header height to the body scroller.
    if ( scroll.bCollapse && scrollY !== "" ) {
      divBodyStyle.height = (divBody[0].offsetHeight + header[0].offsetHeight)+"px";
    }
  
    // Size the table as a whole
    sanityWidth = table.outerWidth();
    if ( scrollX === "" ) {
      // No x scrolling
      tableStyle.width = "100%";
  
      // IE7 will make the width of the table when 100% include the scrollbar
      // - which is shouldn't. When there is a scrollbar we need to take this
      // into account.
      if ( ie67 && (table.find('tbody').height() > divBodyEl.offsetHeight ||
        divBody.css('overflow-y') == "scroll")
      ) {
        tableStyle.width = _fnStringToCss( table.outerWidth() - barWidth);
      }
    }
    else
    {
      // x scrolling
      if ( scrollXInner !== "" ) {
        // x scroll inner has been given - use it
        tableStyle.width = _fnStringToCss(scrollXInner);
      }
      else if ( sanityWidth == divBody.width() && divBody.height() < table.height() ) {
        // There is y-scrolling - try to take account of the y scroll bar
        tableStyle.width = _fnStringToCss( sanityWidth-barWidth );
        if ( table.outerWidth() > sanityWidth-barWidth ) {
          // Not possible to take account of it
          tableStyle.width = _fnStringToCss( sanityWidth );
        }
      }
      else {
        // When all else fails
        tableStyle.width = _fnStringToCss( sanityWidth );
      }
    }
  
    // Recalculate the sanity width - now that we've applied the required width,
    // before it was a temporary variable. This is required because the column
    // width calculation is done before this table DOM is created.
    sanityWidth = table.outerWidth();
  
    // Hidden header should have zero height, so remove padding and borders. Then
    // set the width based on the real headers
  
    // Apply all styles in one pass
    _fnApplyToChildren( zeroOut, headerSrcEls );
  
    // Read all widths in next pass
    _fnApplyToChildren( function(nSizer) {
      headerContent.push( nSizer.innerHTML );
      headerWidths.push( _fnStringToCss( $(nSizer).css('width') ) );
    }, headerSrcEls );
  
    // Apply all widths in final pass
    _fnApplyToChildren( function(nToSize, i) {
      nToSize.style.width = headerWidths[i];
    }, headerTrgEls );
  
    $(headerSrcEls).height(0);
  
    /* Same again with the footer if we have one */
    if ( footer )
    {
      _fnApplyToChildren( zeroOut, footerSrcEls );
  
      _fnApplyToChildren( function(nSizer) {
        footerWidths.push( _fnStringToCss( $(nSizer).css('width') ) );
      }, footerSrcEls );
  
      _fnApplyToChildren( function(nToSize, i) {
        nToSize.style.width = footerWidths[i];
      }, footerTrgEls );
  
      $(footerSrcEls).height(0);
    }
  
  
    /*
     * 3. Apply the measurements
     */
  
    // "Hide" the header and footer that we used for the sizing. We need to keep
    // the content of the cell so that the width applied to the header and body
    // both match, but we want to hide it completely. We want to also fix their
    // width to what they currently are
    _fnApplyToChildren( function(nSizer, i) {
      nSizer.innerHTML = '<div class="dataTables_sizing" style="height:0;overflow:hidden;">'+headerContent[i]+'</div>';
      nSizer.style.width = headerWidths[i];
    }, headerSrcEls );
  
    if ( footer )
    {
      _fnApplyToChildren( function(nSizer, i) {
        nSizer.innerHTML = "";
        nSizer.style.width = footerWidths[i];
      }, footerSrcEls );
    }
  
    // Sanity check that the table is of a sensible width. If not then we are going to get
    // misalignment - try to prevent this by not allowing the table to shrink below its min width
    if ( table.outerWidth() < sanityWidth )
    {
      // The min width depends upon if we have a vertical scrollbar visible or not */
      correction = ((divBodyEl.scrollHeight > divBodyEl.offsetHeight ||
        divBody.css('overflow-y') == "scroll")) ?
          sanityWidth+barWidth :
          sanityWidth;
  
      // IE6/7 are a law unto themselves...
      if ( ie67 && (divBodyEl.scrollHeight >
        divBodyEl.offsetHeight || divBody.css('overflow-y') == "scroll")
      ) {
        tableStyle.width = _fnStringToCss( correction-barWidth );
      }
  
      // And give the user a warning that we've stopped the table getting too small
      if ( scrollX === "" || scrollXInner !== "" ) {
        _fnLog( settings, 1, 'Possible column misalignment', 6 );
      }
    }
    else
    {
      correction = '100%';
    }
  
    // Apply to the container elements
    divBodyStyle.width = _fnStringToCss( correction );
    divHeaderStyle.width = _fnStringToCss( correction );
  
    if ( footer ) {
      settings.nScrollFoot.style.width = _fnStringToCss( correction );
    }
  
  
    /*
     * 4. Clean up
     */
    if ( ! scrollY ) {
      /* IE7< puts a vertical scrollbar in place (when it shouldn't be) due to subtracting
       * the scrollbar height from the visible display, rather than adding it on. We need to
       * set the height in order to sort this. Don't want to do it in any other browsers.
       */
      if ( ie67 ) {
        divBodyStyle.height = _fnStringToCss( tableEl.offsetHeight+barWidth );
      }
    }
  
    if ( scrollY && scroll.bCollapse ) {
      divBodyStyle.height = _fnStringToCss( scrollY );
  
      var iExtra = (scrollX && tableEl.offsetWidth > divBodyEl.offsetWidth) ?
        barWidth :
        0;
  
      if ( tableEl.offsetHeight < divBodyEl.offsetHeight ) {
        divBodyStyle.height = _fnStringToCss( tableEl.offsetHeight+iExtra );
      }
    }
  
    /* Finally set the width's of the header and footer tables */
    var iOuterWidth = table.outerWidth();
    divHeaderTable[0].style.width = _fnStringToCss( iOuterWidth );
    divHeaderInnerStyle.width = _fnStringToCss( iOuterWidth );
  
    // Figure out if there are scrollbar present - if so then we need a the header and footer to
    // provide a bit more space to allow "overflow" scrolling (i.e. past the scrollbar)
    var bScrolling = table.height() > divBodyEl.clientHeight || divBody.css('overflow-y') == "scroll";
    var padding = 'padding' + (browser.bScrollbarLeft ? 'Left' : 'Right' );
    divHeaderInnerStyle[ padding ] = bScrolling ? barWidth+"px" : "0px";
  
    if ( footer ) {
      divFooterTable[0].style.width = _fnStringToCss( iOuterWidth );
      divFooterInner[0].style.width = _fnStringToCss( iOuterWidth );
      divFooterInner[0].style[padding] = bScrolling ? barWidth+"px" : "0px";
    }
  
    /* Adjust the position of the header in case we loose the y-scrollbar */
    divBody.scroll();
  
    // If sorting or filtering has occurred, jump the scrolling back to the top
    // only if we aren't holding the position
    if ( (settings.bSorted || settings.bFiltered) && ! settings._drawHold ) {
      divBodyEl.scrollTop = 0;
    }
  }
  
  
  
  /**
   * Apply a given function to the display child nodes of an element array (typically
   * TD children of TR rows
   *  @param {function} fn Method to apply to the objects
   *  @param array {nodes} an1 List of elements to look through for display children
   *  @param array {nodes} an2 Another list (identical structure to the first) - optional
   *  @memberof DataTable#oApi
   */
  function _fnApplyToChildren( fn, an1, an2 )
  {
    var index=0, i=0, iLen=an1.length;
    var nNode1, nNode2;
  
    while ( i < iLen ) {
      nNode1 = an1[i].firstChild;
      nNode2 = an2 ? an2[i].firstChild : null;
  
      while ( nNode1 ) {
        if ( nNode1.nodeType === 1 ) {
          if ( an2 ) {
            fn( nNode1, nNode2, index );
          }
          else {
            fn( nNode1, index );
          }
  
          index++;
        }
  
        nNode1 = nNode1.nextSibling;
        nNode2 = an2 ? nNode2.nextSibling : null;
      }
  
      i++;
    }
  }
  
  
  
  var __re_html_remove = /<.*?>/g;
  
  
  /**
   * Calculate the width of columns for the table
   *  @param {object} oSettings dataTables settings object
   *  @memberof DataTable#oApi
   */
  function _fnCalculateColumnWidths ( oSettings )
  {
    var
      table = oSettings.nTable,
      columns = oSettings.aoColumns,
      scroll = oSettings.oScroll,
      scrollY = scroll.sY,
      scrollX = scroll.sX,
      scrollXInner = scroll.sXInner,
      columnCount = columns.length,
      visibleColumns = _fnGetColumns( oSettings, 'bVisible' ),
      headerCells = $('th', oSettings.nTHead),
      tableWidthAttr = table.getAttribute('width'),
      tableContainer = table.parentNode,
      userInputs = false,
      i, column, columnIdx, width, outerWidth;
  
    /* Convert any user input sizes into pixel sizes */
    for ( i=0 ; i<visibleColumns.length ; i++ ) {
      column = columns[ visibleColumns[i] ];
  
      if ( column.sWidth !== null ) {
        column.sWidth = _fnConvertToWidth( column.sWidthOrig, tableContainer );
  
        userInputs = true;
      }
    }
  
    /* If the number of columns in the DOM equals the number that we have to
     * process in DataTables, then we can use the offsets that are created by
     * the web- browser. No custom sizes can be set in order for this to happen,
     * nor scrolling used
     */
    if ( ! userInputs && ! scrollX && ! scrollY &&
        columnCount == _fnVisbleColumns( oSettings ) &&
      columnCount == headerCells.length
    ) {
      for ( i=0 ; i<columnCount ; i++ ) {
        columns[i].sWidth = _fnStringToCss( headerCells.eq(i).width() );
      }
    }
    else
    {
      // Otherwise construct a single row table with the widest node in the
      // data, assign any user defined widths, then insert it into the DOM and
      // allow the browser to do all the hard work of calculating table widths
      var tmpTable = $(table).clone() // don't use cloneNode - IE8 will remove events on the main table
        .empty()
        .css( 'visibility', 'hidden' )
        .removeAttr( 'id' )
        .append( $(oSettings.nTHead).clone( false ) )
        .append( $(oSettings.nTFoot).clone( false ) )
        .append( $('<tbody><tr/></tbody>') );
  
      // Remove any assigned widths from the footer (from scrolling)
      tmpTable.find('tfoot th, tfoot td').css('width', '');
  
      var tr = tmpTable.find( 'tbody tr' );
  
      // Apply custom sizing to the cloned header
      headerCells = _fnGetUniqueThs( oSettings, tmpTable.find('thead')[0] );
  
      for ( i=0 ; i<visibleColumns.length ; i++ ) {
        column = columns[ visibleColumns[i] ];
  
        headerCells[i].style.width = column.sWidthOrig !== null && column.sWidthOrig !== '' ?
          _fnStringToCss( column.sWidthOrig ) :
          '';
      }
  
      // Find the widest cell for each column and put it into the table
      if ( oSettings.aoData.length ) {
        for ( i=0 ; i<visibleColumns.length ; i++ ) {
          columnIdx = visibleColumns[i];
          column = columns[ columnIdx ];
  
          $( _fnGetWidestNode( oSettings, columnIdx ) )
            .clone( false )
            .append( column.sContentPadding )
            .appendTo( tr );
        }
      }
  
      // Table has been built, attach to the document so we can work with it
      tmpTable.appendTo( tableContainer );
  
      // When scrolling (X or Y) we want to set the width of the table as 
      // appropriate. However, when not scrolling leave the table width as it
      // is. This results in slightly different, but I think correct behaviour
      if ( scrollX && scrollXInner ) {
        tmpTable.width( scrollXInner );
      }
      else if ( scrollX ) {
        tmpTable.css( 'width', 'auto' );
  
        if ( tmpTable.width() < tableContainer.offsetWidth ) {
          tmpTable.width( tableContainer.offsetWidth );
        }
      }
      else if ( scrollY ) {
        tmpTable.width( tableContainer.offsetWidth );
      }
      else if ( tableWidthAttr ) {
        tmpTable.width( tableWidthAttr );
      }
  
      // Take into account the y scrollbar
      _fnScrollingWidthAdjust( oSettings, tmpTable[0] );
  
      // Browsers need a bit of a hand when a width is assigned to any columns
      // when x-scrolling as they tend to collapse the table to the min-width,
      // even if we sent the column widths. So we need to keep track of what
      // the table width should be by summing the user given values, and the
      // automatic values
      if ( scrollX )
      {
        var total = 0;
  
        for ( i=0 ; i<visibleColumns.length ; i++ ) {
          column = columns[ visibleColumns[i] ];
          outerWidth = $(headerCells[i]).outerWidth();
  
          total += column.sWidthOrig === null ?
            outerWidth :
            parseInt( column.sWidth, 10 ) + outerWidth - $(headerCells[i]).width();
        }
  
        tmpTable.width( _fnStringToCss( total ) );
        table.style.width = _fnStringToCss( total );
      }
  
      // Get the width of each column in the constructed table
      for ( i=0 ; i<visibleColumns.length ; i++ ) {
        column = columns[ visibleColumns[i] ];
        width = $(headerCells[i]).width();
  
        if ( width ) {
          column.sWidth = _fnStringToCss( width );
        }
      }
  
      table.style.width = _fnStringToCss( tmpTable.css('width') );
  
      // Finished with the table - ditch it
      tmpTable.remove();
    }
  
    // If there is a width attr, we want to attach an event listener which
    // allows the table sizing to automatically adjust when the window is
    // resized. Use the width attr rather than CSS, since we can't know if the
    // CSS is a relative value or absolute - DOM read is always px.
    if ( tableWidthAttr ) {
      table.style.width = _fnStringToCss( tableWidthAttr );
    }
  
    if ( (tableWidthAttr || scrollX) && ! oSettings._reszEvt ) {
      $(window).bind('resize.DT-'+oSettings.sInstance, _fnThrottle( function () {
        _fnAdjustColumnSizing( oSettings );
      } ) );
  
      oSettings._reszEvt = true;
    }
  }
  
  
  /**
   * Throttle the calls to a function. Arguments and context are maintained for
   * the throttled function
   *  @param {function} fn Function to be called
   *  @param {int} [freq=200] call frequency in mS
   *  @returns {function} wrapped function
   *  @memberof DataTable#oApi
   */
  function _fnThrottle( fn, freq ) {
    var
      frequency = freq || 200,
      last,
      timer;
  
    return function () {
      var
        that = this,
        now  = +new Date(),
        args = arguments;
  
      if ( last && now < last + frequency ) {
        clearTimeout( timer );
  
        timer = setTimeout( function () {
          last = undefined;
          fn.apply( that, args );
        }, frequency );
      }
      else if ( last ) {
        last = now;
        fn.apply( that, args );
      }
      else {
        last = now;
      }
    };
  }
  
  
  /**
   * Convert a CSS unit width to pixels (e.g. 2em)
   *  @param {string} width width to be converted
   *  @param {node} parent parent to get the with for (required for relative widths) - optional
   *  @returns {int} width in pixels
   *  @memberof DataTable#oApi
   */
  function _fnConvertToWidth ( width, parent )
  {
    if ( ! width ) {
      return 0;
    }
  
    var n = $('<div/>')
      .css( 'width', _fnStringToCss( width ) )
      .appendTo( parent || document.body );
  
    var val = n[0].offsetWidth;
    n.remove();
  
    return val;
  }
  
  
  /**
   * Adjust a table's width to take account of vertical scroll bar
   *  @param {object} oSettings dataTables settings object
   *  @param {node} n table node
   *  @memberof DataTable#oApi
   */
  
  function _fnScrollingWidthAdjust ( settings, n )
  {
    var scroll = settings.oScroll;
  
    if ( scroll.sX || scroll.sY ) {
      // When y-scrolling only, we want to remove the width of the scroll bar
      // so the table + scroll bar will fit into the area available, otherwise
      // we fix the table at its current size with no adjustment
      var correction = ! scroll.sX ? scroll.iBarWidth : 0;
      n.style.width = _fnStringToCss( $(n).outerWidth() - correction );
    }
  }
  
  
  /**
   * Get the widest node
   *  @param {object} settings dataTables settings object
   *  @param {int} colIdx column of interest
   *  @returns {node} widest table node
   *  @memberof DataTable#oApi
   */
  function _fnGetWidestNode( settings, colIdx )
  {
    var idx = _fnGetMaxLenString( settings, colIdx );
    if ( idx < 0 ) {
      return null;
    }
  
    var data = settings.aoData[ idx ];
    return ! data.nTr ? // Might not have been created when deferred rendering
      $('<td/>').html( _fnGetCellData( settings, idx, colIdx, 'display' ) )[0] :
      data.anCells[ colIdx ];
  }
  
  
  /**
   * Get the maximum strlen for each data column
   *  @param {object} settings dataTables settings object
   *  @param {int} colIdx column of interest
   *  @returns {string} max string length for each column
   *  @memberof DataTable#oApi
   */
  function _fnGetMaxLenString( settings, colIdx )
  {
    var s, max=-1, maxIdx = -1;
  
    for ( var i=0, ien=settings.aoData.length ; i<ien ; i++ ) {
      s = _fnGetCellData( settings, i, colIdx, 'display' )+'';
      s = s.replace( __re_html_remove, '' );
  
      if ( s.length > max ) {
        max = s.length;
        maxIdx = i;
      }
    }
  
    return maxIdx;
  }
  
  
  /**
   * Append a CSS unit (only if required) to a string
   *  @param {string} value to css-ify
   *  @returns {string} value with css unit
   *  @memberof DataTable#oApi
   */
  function _fnStringToCss( s )
  {
    if ( s === null ) {
      return '0px';
    }
  
    if ( typeof s == 'number' ) {
      return s < 0 ?
        '0px' :
        s+'px';
    }
  
    // Check it has a unit character already
    return s.match(/\d$/) ?
      s+'px' :
      s;
  }
  
  
  /**
   * Get the width of a scroll bar in this browser being used
   *  @returns {int} width in pixels
   *  @memberof DataTable#oApi
   */
  function _fnScrollBarWidth ()
  {
    // On first run a static variable is set, since this is only needed once.
    // Subsequent runs will just use the previously calculated value
    if ( ! DataTable.__scrollbarWidth ) {
      var inner = $('<p/>').css( {
        width: '100%',
        height: 200,
        padding: 0
      } )[0];
  
      var outer = $('<div/>')
        .css( {
          position: 'absolute',
          top: 0,
          left: 0,
          width: 200,
          height: 150,
          padding: 0,
          overflow: 'hidden',
          visibility: 'hidden'
        } )
        .append( inner )
        .appendTo( 'body' );
  
      var w1 = inner.offsetWidth;
      outer.css( 'overflow', 'scroll' );
      var w2 = inner.offsetWidth;
  
      if ( w1 === w2 ) {
        w2 = outer[0].clientWidth;
      }
  
      outer.remove();
  
      DataTable.__scrollbarWidth = w1 - w2;
    }
  
    return DataTable.__scrollbarWidth;
  }
  
  
  
  function _fnSortFlatten ( settings )
  {
    var
      i, iLen, k, kLen,
      aSort = [],
      aiOrig = [],
      aoColumns = settings.aoColumns,
      aDataSort, iCol, sType, srcCol,
      fixed = settings.aaSortingFixed,
      fixedObj = $.isPlainObject( fixed ),
      nestedSort = [],
      add = function ( a ) {
        if ( a.length && ! $.isArray( a[0] ) ) {
          // 1D array
          nestedSort.push( a );
        }
        else {
          // 2D array
          nestedSort.push.apply( nestedSort, a );
        }
      };
  
    // Build the sort array, with pre-fix and post-fix options if they have been
    // specified
    if ( $.isArray( fixed ) ) {
      add( fixed );
    }
  
    if ( fixedObj && fixed.pre ) {
      add( fixed.pre );
    }
  
    add( settings.aaSorting );
  
    if (fixedObj && fixed.post ) {
      add( fixed.post );
    }
  
    for ( i=0 ; i<nestedSort.length ; i++ )
    {
      srcCol = nestedSort[i][0];
      aDataSort = aoColumns[ srcCol ].aDataSort;
  
      for ( k=0, kLen=aDataSort.length ; k<kLen ; k++ )
      {
        iCol = aDataSort[k];
        sType = aoColumns[ iCol ].sType || 'string';
  
        aSort.push( {
          src:       srcCol,
          col:       iCol,
          dir:       nestedSort[i][1],
          index:     nestedSort[i][2],
          type:      sType,
          formatter: DataTable.ext.type.order[ sType+"-pre" ]
        } );
      }
    }
  
    return aSort;
  }
  
  /**
   * Change the order of the table
   *  @param {object} oSettings dataTables settings object
   *  @memberof DataTable#oApi
   *  @todo This really needs split up!
   */
  function _fnSort ( oSettings )
  {
    var
      i, ien, iLen, j, jLen, k, kLen,
      sDataType, nTh,
      aiOrig = [],
      oExtSort = DataTable.ext.type.order,
      aoData = oSettings.aoData,
      aoColumns = oSettings.aoColumns,
      aDataSort, data, iCol, sType, oSort,
      formatters = 0,
      sortCol,
      displayMaster = oSettings.aiDisplayMaster,
      aSort;
  
    // Resolve any column types that are unknown due to addition or invalidation
    // @todo Can this be moved into a 'data-ready' handler which is called when
    //   data is going to be used in the table?
    _fnColumnTypes( oSettings );
  
    aSort = _fnSortFlatten( oSettings );
  
    for ( i=0, ien=aSort.length ; i<ien ; i++ ) {
      sortCol = aSort[i];
  
      // Track if we can use the fast sort algorithm
      if ( sortCol.formatter ) {
        formatters++;
      }
  
      // Load the data needed for the sort, for each cell
      _fnSortData( oSettings, sortCol.col );
    }
  
    /* No sorting required if server-side or no sorting array */
    if ( _fnDataSource( oSettings ) != 'ssp' && aSort.length !== 0 )
    {
      // Create a value - key array of the current row positions such that we can use their
      // current position during the sort, if values match, in order to perform stable sorting
      for ( i=0, iLen=displayMaster.length ; i<iLen ; i++ ) {
        aiOrig[ displayMaster[i] ] = i;
      }
  
      /* Do the sort - here we want multi-column sorting based on a given data source (column)
       * and sorting function (from oSort) in a certain direction. It's reasonably complex to
       * follow on it's own, but this is what we want (example two column sorting):
       *  fnLocalSorting = function(a,b){
       *    var iTest;
       *    iTest = oSort['string-asc']('data11', 'data12');
       *      if (iTest !== 0)
       *        return iTest;
       *    iTest = oSort['numeric-desc']('data21', 'data22');
       *    if (iTest !== 0)
       *      return iTest;
       *    return oSort['numeric-asc']( aiOrig[a], aiOrig[b] );
       *  }
       * Basically we have a test for each sorting column, if the data in that column is equal,
       * test the next column. If all columns match, then we use a numeric sort on the row
       * positions in the original data array to provide a stable sort.
       *
       * Note - I know it seems excessive to have two sorting methods, but the first is around
       * 15% faster, so the second is only maintained for backwards compatibility with sorting
       * methods which do not have a pre-sort formatting function.
       */
      if ( formatters === aSort.length ) {
        // All sort types have formatting functions
        displayMaster.sort( function ( a, b ) {
          var
            x, y, k, test, sort,
            len=aSort.length,
            dataA = aoData[a]._aSortData,
            dataB = aoData[b]._aSortData;
  
          for ( k=0 ; k<len ; k++ ) {
            sort = aSort[k];
  
            x = dataA[ sort.col ];
            y = dataB[ sort.col ];
  
            test = x<y ? -1 : x>y ? 1 : 0;
            if ( test !== 0 ) {
              return sort.dir === 'asc' ? test : -test;
            }
          }
  
          x = aiOrig[a];
          y = aiOrig[b];
          return x<y ? -1 : x>y ? 1 : 0;
        } );
      }
      else {
        // Depreciated - remove in 1.11 (providing a plug-in option)
        // Not all sort types have formatting methods, so we have to call their sorting
        // methods.
        displayMaster.sort( function ( a, b ) {
          var
            x, y, k, l, test, sort, fn,
            len=aSort.length,
            dataA = aoData[a]._aSortData,
            dataB = aoData[b]._aSortData;
  
          for ( k=0 ; k<len ; k++ ) {
            sort = aSort[k];
  
            x = dataA[ sort.col ];
            y = dataB[ sort.col ];
  
            fn = oExtSort[ sort.type+"-"+sort.dir ] || oExtSort[ "string-"+sort.dir ];
            test = fn( x, y );
            if ( test !== 0 ) {
              return test;
            }
          }
  
          x = aiOrig[a];
          y = aiOrig[b];
          return x<y ? -1 : x>y ? 1 : 0;
        } );
      }
    }
  
    /* Tell the draw function that we have sorted the data */
    oSettings.bSorted = true;
  }
  
  
  function _fnSortAria ( settings )
  {
    var label;
    var nextSort;
    var columns = settings.aoColumns;
    var aSort = _fnSortFlatten( settings );
    var oAria = settings.oLanguage.oAria;
  
    // ARIA attributes - need to loop all columns, to update all (removing old
    // attributes as needed)
    for ( var i=0, iLen=columns.length ; i<iLen ; i++ )
    {
      var col = columns[i];
      var asSorting = col.asSorting;
      var sTitle = col.sTitle.replace( /<.*?>/g, "" );
      var th = col.nTh;
  
      // IE7 is throwing an error when setting these properties with jQuery's
      // attr() and removeAttr() methods...
      th.removeAttribute('aria-sort');
  
      /* In ARIA only the first sorting column can be marked as sorting - no multi-sort option */
      if ( col.bSortable ) {
        if ( aSort.length > 0 && aSort[0].col == i ) {
          th.setAttribute('aria-sort', aSort[0].dir=="asc" ? "ascending" : "descending" );
          nextSort = asSorting[ aSort[0].index+1 ] || asSorting[0];
        }
        else {
          nextSort = asSorting[0];
        }
  
        label = sTitle + ( nextSort === "asc" ?
          oAria.sSortAscending :
          oAria.sSortDescending
        );
      }
      else {
        label = sTitle;
      }
  
      th.setAttribute('aria-label', label);
    }
  }
  
  
  /**
   * Function to run on user sort request
   *  @param {object} settings dataTables settings object
   *  @param {node} attachTo node to attach the handler to
   *  @param {int} colIdx column sorting index
   *  @param {boolean} [append=false] Append the requested sort to the existing
   *    sort if true (i.e. multi-column sort)
   *  @param {function} [callback] callback function
   *  @memberof DataTable#oApi
   */
  function _fnSortListener ( settings, colIdx, append, callback )
  {
    var col = settings.aoColumns[ colIdx ];
    var sorting = settings.aaSorting;
    var asSorting = col.asSorting;
    var nextSortIdx;
    var next = function ( a ) {
      var idx = a._idx;
      if ( idx === undefined ) {
        idx = $.inArray( a[1], asSorting );
      }
  
      return idx+1 >= asSorting.length ? 0 : idx+1;
    };
  
    // Convert to 2D array if needed
    if ( typeof sorting[0] === 'number' ) {
      sorting = settings.aaSorting = [ sorting ];
    }
  
    // If appending the sort then we are multi-column sorting
    if ( append && settings.oFeatures.bSortMulti ) {
      // Are we already doing some kind of sort on this column?
      var sortIdx = $.inArray( colIdx, _pluck(sorting, '0') );
  
      if ( sortIdx !== -1 ) {
        // Yes, modify the sort
        nextSortIdx = next( sorting[sortIdx] );
  
        sorting[sortIdx][1] = asSorting[ nextSortIdx ];
        sorting[sortIdx]._idx = nextSortIdx;
      }
      else {
        // No sort on this column yet
        sorting.push( [ colIdx, asSorting[0], 0 ] );
        sorting[sorting.length-1]._idx = 0;
      }
    }
    else if ( sorting.length && sorting[0][0] == colIdx ) {
      // Single column - already sorting on this column, modify the sort
      nextSortIdx = next( sorting[0] );
  
      sorting.length = 1;
      sorting[0][1] = asSorting[ nextSortIdx ];
      sorting[0]._idx = nextSortIdx;
    }
    else {
      // Single column - sort only on this column
      sorting.length = 0;
      sorting.push( [ colIdx, asSorting[0] ] );
      sorting[0]._idx = 0;
    }
  
    // Run the sort by calling a full redraw
    _fnReDraw( settings );
  
    // callback used for async user interaction
    if ( typeof callback == 'function' ) {
      callback( settings );
    }
  }
  
  
  /**
   * Attach a sort handler (click) to a node
   *  @param {object} settings dataTables settings object
   *  @param {node} attachTo node to attach the handler to
   *  @param {int} colIdx column sorting index
   *  @param {function} [callback] callback function
   *  @memberof DataTable#oApi
   */
  function _fnSortAttachListener ( settings, attachTo, colIdx, callback )
  {
    var col = settings.aoColumns[ colIdx ];
  
    _fnBindAction( attachTo, {}, function (e) {
      /* If the column is not sortable - don't to anything */
      if ( col.bSortable === false ) {
        return;
      }
  
      // If processing is enabled use a timeout to allow the processing
      // display to be shown - otherwise to it synchronously
      if ( settings.oFeatures.bProcessing ) {
        _fnProcessingDisplay( settings, true );
  
        setTimeout( function() {
          _fnSortListener( settings, colIdx, e.shiftKey, callback );
  
          // In server-side processing, the draw callback will remove the
          // processing display
          if ( _fnDataSource( settings ) !== 'ssp' ) {
            _fnProcessingDisplay( settings, false );
          }
        }, 0 );
      }
      else {
        _fnSortListener( settings, colIdx, e.shiftKey, callback );
      }
    } );
  }
  
  
  /**
   * Set the sorting classes on table's body, Note: it is safe to call this function
   * when bSort and bSortClasses are false
   *  @param {object} oSettings dataTables settings object
   *  @memberof DataTable#oApi
   */
  function _fnSortingClasses( settings )
  {
    var oldSort = settings.aLastSort;
    var sortClass = settings.oClasses.sSortColumn;
    var sort = _fnSortFlatten( settings );
    var features = settings.oFeatures;
    var i, ien, colIdx;
  
    if ( features.bSort && features.bSortClasses ) {
      // Remove old sorting classes
      for ( i=0, ien=oldSort.length ; i<ien ; i++ ) {
        colIdx = oldSort[i].src;
  
        // Remove column sorting
        $( _pluck( settings.aoData, 'anCells', colIdx ) )
          .removeClass( sortClass + (i<2 ? i+1 : 3) );
      }
  
      // Add new column sorting
      for ( i=0, ien=sort.length ; i<ien ; i++ ) {
        colIdx = sort[i].src;
  
        $( _pluck( settings.aoData, 'anCells', colIdx ) )
          .addClass( sortClass + (i<2 ? i+1 : 3) );
      }
    }
  
    settings.aLastSort = sort;
  }
  
  
  // Get the data to sort a column, be it from cache, fresh (populating the
  // cache), or from a sort formatter
  function _fnSortData( settings, idx )
  {
    // Custom sorting function - provided by the sort data type
    var column = settings.aoColumns[ idx ];
    var customSort = DataTable.ext.order[ column.sSortDataType ];
    var customData;
  
    if ( customSort ) {
      customData = customSort.call( settings.oInstance, settings, idx,
        _fnColumnIndexToVisible( settings, idx )
      );
    }
  
    // Use / populate cache
    var row, cellData;
    var formatter = DataTable.ext.type.order[ column.sType+"-pre" ];
  
    for ( var i=0, ien=settings.aoData.length ; i<ien ; i++ ) {
      row = settings.aoData[i];
  
      if ( ! row._aSortData ) {
        row._aSortData = [];
      }
  
      if ( ! row._aSortData[idx] || customSort ) {
        cellData = customSort ?
          customData[i] : // If there was a custom sort function, use data from there
          _fnGetCellData( settings, i, idx, 'sort' );
  
        row._aSortData[ idx ] = formatter ?
          formatter( cellData ) :
          cellData;
      }
    }
  }
  
  
  
  /**
   * Save the state of a table
   *  @param {object} oSettings dataTables settings object
   *  @memberof DataTable#oApi
   */
  function _fnSaveState ( settings )
  {
    if ( !settings.oFeatures.bStateSave || settings.bDestroying )
    {
      return;
    }
  
    /* Store the interesting variables */
    var state = {
      time:    +new Date(),
      start:   settings._iDisplayStart,
      length:  settings._iDisplayLength,
      order:   $.extend( true, [], settings.aaSorting ),
      search:  _fnSearchToCamel( settings.oPreviousSearch ),
      columns: $.map( settings.aoColumns, function ( col, i ) {
        return {
          visible: col.bVisible,
          search: _fnSearchToCamel( settings.aoPreSearchCols[i] )
        };
      } )
    };
  
    _fnCallbackFire( settings, "aoStateSaveParams", 'stateSaveParams', [settings, state] );
  
    settings.oSavedState = state;
    settings.fnStateSaveCallback.call( settings.oInstance, settings, state );
  }
  
  
  /**
   * Attempt to load a saved table state
   *  @param {object} oSettings dataTables settings object
   *  @param {object} oInit DataTables init object so we can override settings
   *  @memberof DataTable#oApi
   */
  function _fnLoadState ( settings, oInit )
  {
    var i, ien;
    var columns = settings.aoColumns;
  
    if ( ! settings.oFeatures.bStateSave ) {
      return;
    }
  
    var state = settings.fnStateLoadCallback.call( settings.oInstance, settings );
    if ( ! state || ! state.time ) {
      return;
    }
  
    /* Allow custom and plug-in manipulation functions to alter the saved data set and
     * cancelling of loading by returning false
     */
    var abStateLoad = _fnCallbackFire( settings, 'aoStateLoadParams', 'stateLoadParams', [settings, state] );
    if ( $.inArray( false, abStateLoad ) !== -1 ) {
      return;
    }
  
    /* Reject old data */
    var duration = settings.iStateDuration;
    if ( duration > 0 && state.time < +new Date() - (duration*1000) ) {
      return;
    }
  
    // Number of columns have changed - all bets are off, no restore of settings
    if ( columns.length !== state.columns.length ) {
      return;
    }
  
    // Store the saved state so it might be accessed at any time
    settings.oLoadedState = $.extend( true, {}, state );
  
    // Restore key features - todo - for 1.11 this needs to be done by
    // subscribed events
    settings._iDisplayStart    = state.start;
    settings.iInitDisplayStart = state.start;
    settings._iDisplayLength   = state.length;
    settings.aaSorting = [];
  
    // Order
    $.each( state.order, function ( i, col ) {
      settings.aaSorting.push( col[0] >= columns.length ?
        [ 0, col[1] ] :
        col
      );
    } );
  
    // Search
    $.extend( settings.oPreviousSearch, _fnSearchToHung( state.search ) );
  
    // Columns
    for ( i=0, ien=state.columns.length ; i<ien ; i++ ) {
      var col = state.columns[i];
  
      // Visibility
      columns[i].bVisible = col.visible;
  
      // Search
      $.extend( settings.aoPreSearchCols[i], _fnSearchToHung( col.search ) );
    }
  
    _fnCallbackFire( settings, 'aoStateLoaded', 'stateLoaded', [settings, state] );
  }
  
  
  /**
   * Return the settings object for a particular table
   *  @param {node} table table we are using as a dataTable
   *  @returns {object} Settings object - or null if not found
   *  @memberof DataTable#oApi
   */
  function _fnSettingsFromNode ( table )
  {
    var settings = DataTable.settings;
    var idx = $.inArray( table, _pluck( settings, 'nTable' ) );
  
    return idx !== -1 ?
      settings[ idx ] :
      null;
  }
  
  
  /**
   * Log an error message
   *  @param {object} settings dataTables settings object
   *  @param {int} level log error messages, or display them to the user
   *  @param {string} msg error message
   *  @param {int} tn Technical note id to get more information about the error.
   *  @memberof DataTable#oApi
   */
  function _fnLog( settings, level, msg, tn )
  {
    msg = 'DataTables warning: '+
      (settings!==null ? 'table id='+settings.sTableId+' - ' : '')+msg;
  
    if ( tn ) {
      msg += '. For more information about this error, please see '+
      'http://datatables.net/tn/'+tn;
    }
  
    if ( ! level  ) {
      // Backwards compatibility pre 1.10
      var ext = DataTable.ext;
      var type = ext.sErrMode || ext.errMode;
  
      if ( type == 'alert' ) {
        alert( msg );
      }
      else {
        throw new Error(msg);
      }
    }
    else if ( window.console && console.log ) {
      console.log( msg );
    }
  }
  
  
  /**
   * See if a property is defined on one object, if so assign it to the other object
   *  @param {object} ret target object
   *  @param {object} src source object
   *  @param {string} name property
   *  @param {string} [mappedName] name to map too - optional, name used if not given
   *  @memberof DataTable#oApi
   */
  function _fnMap( ret, src, name, mappedName )
  {
    if ( $.isArray( name ) ) {
      $.each( name, function (i, val) {
        if ( $.isArray( val ) ) {
          _fnMap( ret, src, val[0], val[1] );
        }
        else {
          _fnMap( ret, src, val );
        }
      } );
  
      return;
    }
  
    if ( mappedName === undefined ) {
      mappedName = name;
    }
  
    if ( src[name] !== undefined ) {
      ret[mappedName] = src[name];
    }
  }
  
  
  /**
   * Extend objects - very similar to jQuery.extend, but deep copy objects, and
   * shallow copy arrays. The reason we need to do this, is that we don't want to
   * deep copy array init values (such as aaSorting) since the dev wouldn't be
   * able to override them, but we do want to deep copy arrays.
   *  @param {object} out Object to extend
   *  @param {object} extender Object from which the properties will be applied to
   *      out
   *  @param {boolean} breakRefs If true, then arrays will be sliced to take an
   *      independent copy with the exception of the `data` or `aaData` parameters
   *      if they are present. This is so you can pass in a collection to
   *      DataTables and have that used as your data source without breaking the
   *      references
   *  @returns {object} out Reference, just for convenience - out === the return.
   *  @memberof DataTable#oApi
   *  @todo This doesn't take account of arrays inside the deep copied objects.
   */
  function _fnExtend( out, extender, breakRefs )
  {
    var val;
  
    for ( var prop in extender ) {
      if ( extender.hasOwnProperty(prop) ) {
        val = extender[prop];
  
        if ( $.isPlainObject( val ) ) {
          if ( ! $.isPlainObject( out[prop] ) ) {
            out[prop] = {};
          }
          $.extend( true, out[prop], val );
        }
        else if ( breakRefs && prop !== 'data' && prop !== 'aaData' && $.isArray(val) ) {
          out[prop] = val.slice();
        }
        else {
          out[prop] = val;
        }
      }
    }
  
    return out;
  }
  
  
  /**
   * Bind an event handers to allow a click or return key to activate the callback.
   * This is good for accessibility since a return on the keyboard will have the
   * same effect as a click, if the element has focus.
   *  @param {element} n Element to bind the action to
   *  @param {object} oData Data object to pass to the triggered function
   *  @param {function} fn Callback function for when the event is triggered
   *  @memberof DataTable#oApi
   */
  function _fnBindAction( n, oData, fn )
  {
    $(n)
      .bind( 'click.DT', oData, function (e) {
          n.blur(); // Remove focus outline for mouse users
          fn(e);
        } )
      .bind( 'keypress.DT', oData, function (e){
          if ( e.which === 13 ) {
            e.preventDefault();
            fn(e);
          }
        } )
      .bind( 'selectstart.DT', function () {
          /* Take the brutal approach to cancelling text selection */
          return false;
        } );
  }
  
  
  /**
   * Register a callback function. Easily allows a callback function to be added to
   * an array store of callback functions that can then all be called together.
   *  @param {object} oSettings dataTables settings object
   *  @param {string} sStore Name of the array storage for the callbacks in oSettings
   *  @param {function} fn Function to be called back
   *  @param {string} sName Identifying name for the callback (i.e. a label)
   *  @memberof DataTable#oApi
   */
  function _fnCallbackReg( oSettings, sStore, fn, sName )
  {
    if ( fn )
    {
      oSettings[sStore].push( {
        "fn": fn,
        "sName": sName
      } );
    }
  }
  
  
  /**
   * Fire callback functions and trigger events. Note that the loop over the
   * callback array store is done backwards! Further note that you do not want to
   * fire off triggers in time sensitive applications (for example cell creation)
   * as its slow.
   *  @param {object} settings dataTables settings object
   *  @param {string} callbackArr Name of the array storage for the callbacks in
   *      oSettings
   *  @param {string} event Name of the jQuery custom event to trigger. If null no
   *      trigger is fired
   *  @param {array} args Array of arguments to pass to the callback function /
   *      trigger
   *  @memberof DataTable#oApi
   */
  function _fnCallbackFire( settings, callbackArr, e, args )
  {
    var ret = [];
  
    if ( callbackArr ) {
      ret = $.map( settings[callbackArr].slice().reverse(), function (val, i) {
        return val.fn.apply( settings.oInstance, args );
      } );
    }
  
    if ( e !== null ) {
      $(settings.nTable).trigger( e+'.dt', args );
    }
  
    return ret;
  }
  
  
  function _fnLengthOverflow ( settings )
  {
    var
      start = settings._iDisplayStart,
      end = settings.fnDisplayEnd(),
      len = settings._iDisplayLength;
  
    /* If we have space to show extra rows (backing up from the end point - then do so */
    if ( end === settings.fnRecordsDisplay() )
    {
      start = end - len;
    }
  
    if ( len === -1 || start < 0 )
    {
      start = 0;
    }
  
    settings._iDisplayStart = start;
  }
  
  
  function _fnRenderer( settings, type )
  {
    var renderer = settings.renderer;
    var host = DataTable.ext.renderer[type];
  
    if ( $.isPlainObject( renderer ) && renderer[type] ) {
      // Specific renderer for this type. If available use it, otherwise use
      // the default.
      return host[renderer[type]] || host._;
    }
    else if ( typeof renderer === 'string' ) {
      // Common renderer - if there is one available for this type use it,
      // otherwise use the default
      return host[renderer] || host._;
    }
  
    // Use the default
    return host._;
  }
  
  
  /**
   * Detect the data source being used for the table. Used to simplify the code
   * a little (ajax) and to make it compress a little smaller.
   *
   *  @param {object} settings dataTables settings object
   *  @returns {string} Data source
   *  @memberof DataTable#oApi
   */
  function _fnDataSource ( settings )
  {
    if ( settings.oFeatures.bServerSide ) {
      return 'ssp';
    }
    else if ( settings.ajax || settings.sAjaxSource ) {
      return 'ajax';
    }
    return 'dom';
  }
  

  DataTable = function( options )
  {
    /**
     * Perform a jQuery selector action on the table's TR elements (from the tbody) and
     * return the resulting jQuery object.
     *  @param {string|node|jQuery} sSelector jQuery selector or node collection to act on
     *  @param {object} [oOpts] Optional parameters for modifying the rows to be included
     *  @param {string} [oOpts.filter=none] Select TR elements that meet the current filter
     *    criterion ("applied") or all TR elements (i.e. no filter).
     *  @param {string} [oOpts.order=current] Order of the TR elements in the processed array.
     *    Can be either 'current', whereby the current sorting of the table is used, or
     *    'original' whereby the original order the data was read into the table is used.
     *  @param {string} [oOpts.page=all] Limit the selection to the currently displayed page
     *    ("current") or not ("all"). If 'current' is given, then order is assumed to be
     *    'current' and filter is 'applied', regardless of what they might be given as.
     *  @returns {object} jQuery object, filtered by the given selector.
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *
     *      // Highlight every second row
     *      oTable.$('tr:odd').css('backgroundColor', 'blue');
     *    } );
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *
     *      // Filter to rows with 'Webkit' in them, add a background colour and then
     *      // remove the filter, thus highlighting the 'Webkit' rows only.
     *      oTable.fnFilter('Webkit');
     *      oTable.$('tr', {"search": "applied"}).css('backgroundColor', 'blue');
     *      oTable.fnFilter('');
     *    } );
     */
    this.$ = function ( sSelector, oOpts )
    {
      return this.api(true).$( sSelector, oOpts );
    };
    
    
    /**
     * Almost identical to $ in operation, but in this case returns the data for the matched
     * rows - as such, the jQuery selector used should match TR row nodes or TD/TH cell nodes
     * rather than any descendants, so the data can be obtained for the row/cell. If matching
     * rows are found, the data returned is the original data array/object that was used to
     * create the row (or a generated array if from a DOM source).
     *
     * This method is often useful in-combination with $ where both functions are given the
     * same parameters and the array indexes will match identically.
     *  @param {string|node|jQuery} sSelector jQuery selector or node collection to act on
     *  @param {object} [oOpts] Optional parameters for modifying the rows to be included
     *  @param {string} [oOpts.filter=none] Select elements that meet the current filter
     *    criterion ("applied") or all elements (i.e. no filter).
     *  @param {string} [oOpts.order=current] Order of the data in the processed array.
     *    Can be either 'current', whereby the current sorting of the table is used, or
     *    'original' whereby the original order the data was read into the table is used.
     *  @param {string} [oOpts.page=all] Limit the selection to the currently displayed page
     *    ("current") or not ("all"). If 'current' is given, then order is assumed to be
     *    'current' and filter is 'applied', regardless of what they might be given as.
     *  @returns {array} Data for the matched elements. If any elements, as a result of the
     *    selector, were not TR, TD or TH elements in the DataTable, they will have a null
     *    entry in the array.
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *
     *      // Get the data from the first row in the table
     *      var data = oTable._('tr:first');
     *
     *      // Do something useful with the data
     *      alert( "First cell is: "+data[0] );
     *    } );
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *
     *      // Filter to 'Webkit' and get all data for
     *      oTable.fnFilter('Webkit');
     *      var data = oTable._('tr', {"search": "applied"});
     *
     *      // Do something with the data
     *      alert( data.length+" rows matched the search" );
     *    } );
     */
    this._ = function ( sSelector, oOpts )
    {
      return this.api(true).rows( sSelector, oOpts ).data();
    };
    
    
    /**
     * Create a DataTables Api instance, with the currently selected tables for
     * the Api's context.
     * @param {boolean} [traditional=false] Set the API instance's context to be
     *   only the table referred to by the `DataTable.ext.iApiIndex` option, as was
     *   used in the API presented by DataTables 1.9- (i.e. the traditional mode),
     *   or if all tables captured in the jQuery object should be used.
     * @return {DataTables.Api}
     */
    this.api = function ( traditional )
    {
      return traditional ?
        new _Api(
          _fnSettingsFromNode( this[ _ext.iApiIndex ] )
        ) :
        new _Api( this );
    };
    
    
    /**
     * Add a single new row or multiple rows of data to the table. Please note
     * that this is suitable for client-side processing only - if you are using
     * server-side processing (i.e. "bServerSide": true), then to add data, you
     * must add it to the data source, i.e. the server-side, through an Ajax call.
     *  @param {array|object} data The data to be added to the table. This can be:
     *    <ul>
     *      <li>1D array of data - add a single row with the data provided</li>
     *      <li>2D array of arrays - add multiple rows in a single call</li>
     *      <li>object - data object when using <i>mData</i></li>
     *      <li>array of objects - multiple data objects when using <i>mData</i></li>
     *    </ul>
     *  @param {bool} [redraw=true] redraw the table or not
     *  @returns {array} An array of integers, representing the list of indexes in
     *    <i>aoData</i> ({@link DataTable.models.oSettings}) that have been added to
     *    the table.
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    // Global var for counter
     *    var giCount = 2;
     *
     *    $(document).ready(function() {
     *      $('#example').dataTable();
     *    } );
     *
     *    function fnClickAddRow() {
     *      $('#example').dataTable().fnAddData( [
     *        giCount+".1",
     *        giCount+".2",
     *        giCount+".3",
     *        giCount+".4" ]
     *      );
     *
     *      giCount++;
     *    }
     */
    this.fnAddData = function( data, redraw )
    {
      var api = this.api( true );
    
      /* Check if we want to add multiple rows or not */
      var rows = $.isArray(data) && ( $.isArray(data[0]) || $.isPlainObject(data[0]) ) ?
        api.rows.add( data ) :
        api.row.add( data );
    
      if ( redraw === undefined || redraw ) {
        api.draw();
      }
    
      return rows.flatten().toArray();
    };
    
    
    /**
     * This function will make DataTables recalculate the column sizes, based on the data
     * contained in the table and the sizes applied to the columns (in the DOM, CSS or
     * through the sWidth parameter). This can be useful when the width of the table's
     * parent element changes (for example a window resize).
     *  @param {boolean} [bRedraw=true] Redraw the table or not, you will typically want to
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable( {
     *        "sScrollY": "200px",
     *        "bPaginate": false
     *      } );
     *
     *      $(window).bind('resize', function () {
     *        oTable.fnAdjustColumnSizing();
     *      } );
     *    } );
     */
    this.fnAdjustColumnSizing = function ( bRedraw )
    {
      var api = this.api( true ).columns.adjust();
      var settings = api.settings()[0];
      var scroll = settings.oScroll;
    
      if ( bRedraw === undefined || bRedraw ) {
        api.draw( false );
      }
      else if ( scroll.sX !== "" || scroll.sY !== "" ) {
        /* If not redrawing, but scrolling, we want to apply the new column sizes anyway */
        _fnScrollDraw( settings );
      }
    };
    
    
    /**
     * Quickly and simply clear a table
     *  @param {bool} [bRedraw=true] redraw the table or not
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *
     *      // Immediately 'nuke' the current rows (perhaps waiting for an Ajax callback...)
     *      oTable.fnClearTable();
     *    } );
     */
    this.fnClearTable = function( bRedraw )
    {
      var api = this.api( true ).clear();
    
      if ( bRedraw === undefined || bRedraw ) {
        api.draw();
      }
    };
    
    
    /**
     * The exact opposite of 'opening' a row, this function will close any rows which
     * are currently 'open'.
     *  @param {node} nTr the table row to 'close'
     *  @returns {int} 0 on success, or 1 if failed (can't find the row)
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable;
     *
     *      // 'open' an information row when a row is clicked on
     *      $('#example tbody tr').click( function () {
     *        if ( oTable.fnIsOpen(this) ) {
     *          oTable.fnClose( this );
     *        } else {
     *          oTable.fnOpen( this, "Temporary row opened", "info_row" );
     *        }
     *      } );
     *
     *      oTable = $('#example').dataTable();
     *    } );
     */
    this.fnClose = function( nTr )
    {
      this.api( true ).row( nTr ).child.hide();
    };
    
    
    /**
     * Remove a row for the table
     *  @param {mixed} target The index of the row from aoData to be deleted, or
     *    the TR element you want to delete
     *  @param {function|null} [callBack] Callback function
     *  @param {bool} [redraw=true] Redraw the table or not
     *  @returns {array} The row that was deleted
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *
     *      // Immediately remove the first row
     *      oTable.fnDeleteRow( 0 );
     *    } );
     */
    this.fnDeleteRow = function( target, callback, redraw )
    {
      var api = this.api( true );
      var rows = api.rows( target );
      var settings = rows.settings()[0];
      var data = settings.aoData[ rows[0][0] ];
    
      rows.remove();
    
      if ( callback ) {
        callback.call( this, settings, data );
      }
    
      if ( redraw === undefined || redraw ) {
        api.draw();
      }
    
      return data;
    };
    
    
    /**
     * Restore the table to it's original state in the DOM by removing all of DataTables
     * enhancements, alterations to the DOM structure of the table and event listeners.
     *  @param {boolean} [remove=false] Completely remove the table from the DOM
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      // This example is fairly pointless in reality, but shows how fnDestroy can be used
     *      var oTable = $('#example').dataTable();
     *      oTable.fnDestroy();
     *    } );
     */
    this.fnDestroy = function ( remove )
    {
      this.api( true ).destroy( remove );
    };
    
    
    /**
     * Redraw the table
     *  @param {bool} [complete=true] Re-filter and resort (if enabled) the table before the draw.
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *
     *      // Re-draw the table - you wouldn't want to do it here, but it's an example :-)
     *      oTable.fnDraw();
     *    } );
     */
    this.fnDraw = function( complete )
    {
      // Note that this isn't an exact match to the old call to _fnDraw - it takes
      // into account the new data, but can old position.
      this.api( true ).draw( ! complete );
    };
    
    
    /**
     * Filter the input based on data
     *  @param {string} sInput String to filter the table on
     *  @param {int|null} [iColumn] Column to limit filtering to
     *  @param {bool} [bRegex=false] Treat as regular expression or not
     *  @param {bool} [bSmart=true] Perform smart filtering or not
     *  @param {bool} [bShowGlobal=true] Show the input global filter in it's input box(es)
     *  @param {bool} [bCaseInsensitive=true] Do case-insensitive matching (true) or not (false)
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *
     *      // Sometime later - filter...
     *      oTable.fnFilter( 'test string' );
     *    } );
     */
    this.fnFilter = function( sInput, iColumn, bRegex, bSmart, bShowGlobal, bCaseInsensitive )
    {
      var api = this.api( true );
    
      if ( iColumn === null || iColumn === undefined ) {
        api.search( sInput, bRegex, bSmart, bCaseInsensitive );
      }
      else {
        api.column( iColumn ).search( sInput, bRegex, bSmart, bCaseInsensitive );
      }
    
      api.draw();
    };
    
    
    /**
     * Get the data for the whole table, an individual row or an individual cell based on the
     * provided parameters.
     *  @param {int|node} [src] A TR row node, TD/TH cell node or an integer. If given as
     *    a TR node then the data source for the whole row will be returned. If given as a
     *    TD/TH cell node then iCol will be automatically calculated and the data for the
     *    cell returned. If given as an integer, then this is treated as the aoData internal
     *    data index for the row (see fnGetPosition) and the data for that row used.
     *  @param {int} [col] Optional column index that you want the data of.
     *  @returns {array|object|string} If mRow is undefined, then the data for all rows is
     *    returned. If mRow is defined, just data for that row, and is iCol is
     *    defined, only data for the designated cell is returned.
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    // Row data
     *    $(document).ready(function() {
     *      oTable = $('#example').dataTable();
     *
     *      oTable.$('tr').click( function () {
     *        var data = oTable.fnGetData( this );
     *        // ... do something with the array / object of data for the row
     *      } );
     *    } );
     *
     *  @example
     *    // Individual cell data
     *    $(document).ready(function() {
     *      oTable = $('#example').dataTable();
     *
     *      oTable.$('td').click( function () {
     *        var sData = oTable.fnGetData( this );
     *        alert( 'The cell clicked on had the value of '+sData );
     *      } );
     *    } );
     */
    this.fnGetData = function( src, col )
    {
      var api = this.api( true );
    
      if ( src !== undefined ) {
        var type = src.nodeName ? src.nodeName.toLowerCase() : '';
    
        return col !== undefined || type == 'td' || type == 'th' ?
          api.cell( src, col ).data() :
          api.row( src ).data() || null;
      }
    
      return api.data().toArray();
    };
    
    
    /**
     * Get an array of the TR nodes that are used in the table's body. Note that you will
     * typically want to use the '$' API method in preference to this as it is more
     * flexible.
     *  @param {int} [iRow] Optional row index for the TR element you want
     *  @returns {array|node} If iRow is undefined, returns an array of all TR elements
     *    in the table's body, or iRow is defined, just the TR element requested.
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *
     *      // Get the nodes from the table
     *      var nNodes = oTable.fnGetNodes( );
     *    } );
     */
    this.fnGetNodes = function( iRow )
    {
      var api = this.api( true );
    
      return iRow !== undefined ?
        api.row( iRow ).node() :
        api.rows().nodes().flatten().toArray();
    };
    
    
    /**
     * Get the array indexes of a particular cell from it's DOM element
     * and column index including hidden columns
     *  @param {node} node this can either be a TR, TD or TH in the table's body
     *  @returns {int} If nNode is given as a TR, then a single index is returned, or
     *    if given as a cell, an array of [row index, column index (visible),
     *    column index (all)] is given.
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      $('#example tbody td').click( function () {
     *        // Get the position of the current data from the node
     *        var aPos = oTable.fnGetPosition( this );
     *
     *        // Get the data array for this row
     *        var aData = oTable.fnGetData( aPos[0] );
     *
     *        // Update the data array and return the value
     *        aData[ aPos[1] ] = 'clicked';
     *        this.innerHTML = 'clicked';
     *      } );
     *
     *      // Init DataTables
     *      oTable = $('#example').dataTable();
     *    } );
     */
    this.fnGetPosition = function( node )
    {
      var api = this.api( true );
      var nodeName = node.nodeName.toUpperCase();
    
      if ( nodeName == 'TR' ) {
        return api.row( node ).index();
      }
      else if ( nodeName == 'TD' || nodeName == 'TH' ) {
        var cell = api.cell( node ).index();
    
        return [
          cell.row,
          cell.columnVisible,
          cell.column
        ];
      }
      return null;
    };
    
    
    /**
     * Check to see if a row is 'open' or not.
     *  @param {node} nTr the table row to check
     *  @returns {boolean} true if the row is currently open, false otherwise
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable;
     *
     *      // 'open' an information row when a row is clicked on
     *      $('#example tbody tr').click( function () {
     *        if ( oTable.fnIsOpen(this) ) {
     *          oTable.fnClose( this );
     *        } else {
     *          oTable.fnOpen( this, "Temporary row opened", "info_row" );
     *        }
     *      } );
     *
     *      oTable = $('#example').dataTable();
     *    } );
     */
    this.fnIsOpen = function( nTr )
    {
      return this.api( true ).row( nTr ).child.isShown();
    };
    
    
    /**
     * This function will place a new row directly after a row which is currently
     * on display on the page, with the HTML contents that is passed into the
     * function. This can be used, for example, to ask for confirmation that a
     * particular record should be deleted.
     *  @param {node} nTr The table row to 'open'
     *  @param {string|node|jQuery} mHtml The HTML to put into the row
     *  @param {string} sClass Class to give the new TD cell
     *  @returns {node} The row opened. Note that if the table row passed in as the
     *    first parameter, is not found in the table, this method will silently
     *    return.
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable;
     *
     *      // 'open' an information row when a row is clicked on
     *      $('#example tbody tr').click( function () {
     *        if ( oTable.fnIsOpen(this) ) {
     *          oTable.fnClose( this );
     *        } else {
     *          oTable.fnOpen( this, "Temporary row opened", "info_row" );
     *        }
     *      } );
     *
     *      oTable = $('#example').dataTable();
     *    } );
     */
    this.fnOpen = function( nTr, mHtml, sClass )
    {
      return this.api( true )
        .row( nTr )
        .child( mHtml, sClass )
        .show()
        .child()[0];
    };
    
    
    /**
     * Change the pagination - provides the internal logic for pagination in a simple API
     * function. With this function you can have a DataTables table go to the next,
     * previous, first or last pages.
     *  @param {string|int} mAction Paging action to take: "first", "previous", "next" or "last"
     *    or page number to jump to (integer), note that page 0 is the first page.
     *  @param {bool} [bRedraw=true] Redraw the table or not
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *      oTable.fnPageChange( 'next' );
     *    } );
     */
    this.fnPageChange = function ( mAction, bRedraw )
    {
      var api = this.api( true ).page( mAction );
    
      if ( bRedraw === undefined || bRedraw ) {
        api.draw(false);
      }
    };
    
    
    /**
     * Show a particular column
     *  @param {int} iCol The column whose display should be changed
     *  @param {bool} bShow Show (true) or hide (false) the column
     *  @param {bool} [bRedraw=true] Redraw the table or not
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *
     *      // Hide the second column after initialisation
     *      oTable.fnSetColumnVis( 1, false );
     *    } );
     */
    this.fnSetColumnVis = function ( iCol, bShow, bRedraw )
    {
      var api = this.api( true ).column( iCol ).visible( bShow );
    
      if ( bRedraw === undefined || bRedraw ) {
        api.columns.adjust().draw();
      }
    };
    
    
    /**
     * Get the settings for a particular table for external manipulation
     *  @returns {object} DataTables settings object. See
     *    {@link DataTable.models.oSettings}
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *      var oSettings = oTable.fnSettings();
     *
     *      // Show an example parameter from the settings
     *      alert( oSettings._iDisplayStart );
     *    } );
     */
    this.fnSettings = function()
    {
      return _fnSettingsFromNode( this[_ext.iApiIndex] );
    };
    
    
    /**
     * Sort the table by a particular column
     *  @param {int} iCol the data index to sort on. Note that this will not match the
     *    'display index' if you have hidden data entries
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *
     *      // Sort immediately with columns 0 and 1
     *      oTable.fnSort( [ [0,'asc'], [1,'asc'] ] );
     *    } );
     */
    this.fnSort = function( aaSort )
    {
      this.api( true ).order( aaSort ).draw();
    };
    
    
    /**
     * Attach a sort listener to an element for a given column
     *  @param {node} nNode the element to attach the sort listener to
     *  @param {int} iColumn the column that a click on this node will sort on
     *  @param {function} [fnCallback] callback function when sort is run
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *
     *      // Sort on column 1, when 'sorter' is clicked on
     *      oTable.fnSortListener( document.getElementById('sorter'), 1 );
     *    } );
     */
    this.fnSortListener = function( nNode, iColumn, fnCallback )
    {
      this.api( true ).order.listener( nNode, iColumn, fnCallback );
    };
    
    
    /**
     * Update a table cell or row - this method will accept either a single value to
     * update the cell with, an array of values with one element for each column or
     * an object in the same format as the original data source. The function is
     * self-referencing in order to make the multi column updates easier.
     *  @param {object|array|string} mData Data to update the cell/row with
     *  @param {node|int} mRow TR element you want to update or the aoData index
     *  @param {int} [iColumn] The column to update, give as null or undefined to
     *    update a whole row.
     *  @param {bool} [bRedraw=true] Redraw the table or not
     *  @param {bool} [bAction=true] Perform pre-draw actions or not
     *  @returns {int} 0 on success, 1 on error
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *      oTable.fnUpdate( 'Example update', 0, 0 ); // Single cell
     *      oTable.fnUpdate( ['a', 'b', 'c', 'd', 'e'], $('tbody tr')[0] ); // Row
     *    } );
     */
    this.fnUpdate = function( mData, mRow, iColumn, bRedraw, bAction )
    {
      var api = this.api( true );
    
      if ( iColumn === undefined || iColumn === null ) {
        api.row( mRow ).data( mData );
      }
      else {
        api.cell( mRow, iColumn ).data( mData );
      }
    
      if ( bAction === undefined || bAction ) {
        api.columns.adjust();
      }
    
      if ( bRedraw === undefined || bRedraw ) {
        api.draw();
      }
      return 0;
    };
    
    
    /**
     * Provide a common method for plug-ins to check the version of DataTables being used, in order
     * to ensure compatibility.
     *  @param {string} sVersion Version string to check for, in the format "X.Y.Z". Note that the
     *    formats "X" and "X.Y" are also acceptable.
     *  @returns {boolean} true if this version of DataTables is greater or equal to the required
     *    version, or false if this version of DataTales is not suitable
     *  @method
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *      alert( oTable.fnVersionCheck( '1.9.0' ) );
     *    } );
     */
    this.fnVersionCheck = _ext.fnVersionCheck;
    

    var _that = this;
    var emptyInit = options === undefined;
    var len = this.length;

    if ( emptyInit ) {
      options = {};
    }

    this.oApi = this.internal = _ext.internal;

    // Extend with old style plug-in API methods
    for ( var fn in DataTable.ext.internal ) {
      if ( fn ) {
        this[fn] = _fnExternApiFunc(fn);
      }
    }

    this.each(function() {
      // For each initialisation we want to give it a clean initialisation
      // object that can be bashed around
      var o = {};
      var oInit = len > 1 ? // optimisation for single table case
        _fnExtend( o, options, true ) :
        options;

      /*global oInit,_that,emptyInit*/
      var i=0, iLen, j, jLen, k, kLen;
      var sId = this.getAttribute( 'id' );
      var bInitHandedOff = false;
      var defaults = DataTable.defaults;
      
      
      /* Sanity check */
      if ( this.nodeName.toLowerCase() != 'table' )
      {
        _fnLog( null, 0, 'Non-table node initialisation ('+this.nodeName+')', 2 );
        return;
      }
      
      /* Backwards compatibility for the defaults */
      _fnCompatOpts( defaults );
      _fnCompatCols( defaults.column );
      
      /* Convert the camel-case defaults to Hungarian */
      _fnCamelToHungarian( defaults, defaults, true );
      _fnCamelToHungarian( defaults.column, defaults.column, true );
      
      /* Setting up the initialisation object */
      _fnCamelToHungarian( defaults, oInit );
      
      /* Check to see if we are re-initialising a table */
      var allSettings = DataTable.settings;
      for ( i=0, iLen=allSettings.length ; i<iLen ; i++ )
      {
        /* Base check on table node */
        if ( allSettings[i].nTable == this )
        {
          var bRetrieve = oInit.bRetrieve !== undefined ? oInit.bRetrieve : defaults.bRetrieve;
          var bDestroy = oInit.bDestroy !== undefined ? oInit.bDestroy : defaults.bDestroy;
      
          if ( emptyInit || bRetrieve )
          {
            return allSettings[i].oInstance;
          }
          else if ( bDestroy )
          {
            allSettings[i].oInstance.fnDestroy();
            break;
          }
          else
          {
            _fnLog( allSettings[i], 0, 'Cannot reinitialise DataTable', 3 );
            return;
          }
        }
      
        /* If the element we are initialising has the same ID as a table which was previously
         * initialised, but the table nodes don't match (from before) then we destroy the old
         * instance by simply deleting it. This is under the assumption that the table has been
         * destroyed by other methods. Anyone using non-id selectors will need to do this manually
         */
        if ( allSettings[i].sTableId == this.id )
        {
          allSettings.splice( i, 1 );
          break;
        }
      }
      
      /* Ensure the table has an ID - required for accessibility */
      if ( sId === null || sId === "" )
      {
        sId = "DataTables_Table_"+(DataTable.ext._unique++);
        this.id = sId;
      }
      
      /* Create the settings object for this table and set some of the default parameters */
      var oSettings = $.extend( true, {}, DataTable.models.oSettings, {
        "nTable":        this,
        "oApi":          _that.internal,
        "oInit":         oInit,
        "sDestroyWidth": $(this)[0].style.width,
        "sInstance":     sId,
        "sTableId":      sId
      } );
      allSettings.push( oSettings );
      
      // Need to add the instance after the instance after the settings object has been added
      // to the settings array, so we can self reference the table instance if more than one
      oSettings.oInstance = (_that.length===1) ? _that : $(this).dataTable();
      
      // Backwards compatibility, before we apply all the defaults
      _fnCompatOpts( oInit );
      
      if ( oInit.oLanguage )
      {
        _fnLanguageCompat( oInit.oLanguage );
      }
      
      // If the length menu is given, but the init display length is not, use the length menu
      if ( oInit.aLengthMenu && ! oInit.iDisplayLength )
      {
        oInit.iDisplayLength = $.isArray( oInit.aLengthMenu[0] ) ?
          oInit.aLengthMenu[0][0] : oInit.aLengthMenu[0];
      }
      
      // Apply the defaults and init options to make a single init object will all
      // options defined from defaults and instance options.
      oInit = _fnExtend( $.extend( true, {}, defaults ), oInit );
      
      
      // Map the initialisation options onto the settings object
      _fnMap( oSettings.oFeatures, oInit, [
        "bPaginate",
        "bLengthChange",
        "bFilter",
        "bSort",
        "bSortMulti",
        "bInfo",
        "bProcessing",
        "bAutoWidth",
        "bSortClasses",
        "bServerSide",
        "bDeferRender"
      ] );
      _fnMap( oSettings, oInit, [
        "asStripeClasses",
        "ajax",
        "fnServerData",
        "fnFormatNumber",
        "sServerMethod",
        "aaSorting",
        "aaSortingFixed",
        "aLengthMenu",
        "sPaginationType",
        "sAjaxSource",
        "sAjaxDataProp",
        "iStateDuration",
        "sDom",
        "bSortCellsTop",
        "iTabIndex",
        "fnStateLoadCallback",
        "fnStateSaveCallback",
        "renderer",
        [ "iCookieDuration", "iStateDuration" ], // backwards compat
        [ "oSearch", "oPreviousSearch" ],
        [ "aoSearchCols", "aoPreSearchCols" ],
        [ "iDisplayLength", "_iDisplayLength" ],
        [ "bJQueryUI", "bJUI" ]
      ] );
      _fnMap( oSettings.oScroll, oInit, [
        [ "sScrollX", "sX" ],
        [ "sScrollXInner", "sXInner" ],
        [ "sScrollY", "sY" ],
        [ "bScrollCollapse", "bCollapse" ]
      ] );
      _fnMap( oSettings.oLanguage, oInit, "fnInfoCallback" );
      
      /* Callback functions which are array driven */
      _fnCallbackReg( oSettings, 'aoDrawCallback',       oInit.fnDrawCallback,      'user' );
      _fnCallbackReg( oSettings, 'aoServerParams',       oInit.fnServerParams,      'user' );
      _fnCallbackReg( oSettings, 'aoStateSaveParams',    oInit.fnStateSaveParams,   'user' );
      _fnCallbackReg( oSettings, 'aoStateLoadParams',    oInit.fnStateLoadParams,   'user' );
      _fnCallbackReg( oSettings, 'aoStateLoaded',        oInit.fnStateLoaded,       'user' );
      _fnCallbackReg( oSettings, 'aoRowCallback',        oInit.fnRowCallback,       'user' );
      _fnCallbackReg( oSettings, 'aoRowCreatedCallback', oInit.fnCreatedRow,        'user' );
      _fnCallbackReg( oSettings, 'aoHeaderCallback',     oInit.fnHeaderCallback,    'user' );
      _fnCallbackReg( oSettings, 'aoFooterCallback',     oInit.fnFooterCallback,    'user' );
      _fnCallbackReg( oSettings, 'aoInitComplete',       oInit.fnInitComplete,      'user' );
      _fnCallbackReg( oSettings, 'aoPreDrawCallback',    oInit.fnPreDrawCallback,   'user' );
      
      var oClasses = oSettings.oClasses;
      
      // @todo Remove in 1.11
      if ( oInit.bJQueryUI )
      {
        /* Use the JUI classes object for display. You could clone the oStdClasses object if
         * you want to have multiple tables with multiple independent classes
         */
        $.extend( oClasses, DataTable.ext.oJUIClasses, oInit.oClasses );
      
        if ( oInit.sDom === defaults.sDom && defaults.sDom === "lfrtip" )
        {
          /* Set the DOM to use a layout suitable for jQuery UI's theming */
          oSettings.sDom = '<"H"lfr>t<"F"ip>';
        }
      
        if ( ! oSettings.renderer ) {
          oSettings.renderer = 'jqueryui';
        }
        else if ( $.isPlainObject( oSettings.renderer ) && ! oSettings.renderer.header ) {
          oSettings.renderer.header = 'jqueryui';
        }
      }
      else
      {
        $.extend( oClasses, DataTable.ext.classes, oInit.oClasses );
      }
      $(this).addClass( oClasses.sTable );
      
      /* Calculate the scroll bar width and cache it for use later on */
      if ( oSettings.oScroll.sX !== "" || oSettings.oScroll.sY !== "" )
      {
        oSettings.oScroll.iBarWidth = _fnScrollBarWidth();
      }
      if ( oSettings.oScroll.sX === true ) { // Easy initialisation of x-scrolling
        oSettings.oScroll.sX = '100%';
      }
      
      if ( oSettings.iInitDisplayStart === undefined )
      {
        /* Display start point, taking into account the save saving */
        oSettings.iInitDisplayStart = oInit.iDisplayStart;
        oSettings._iDisplayStart = oInit.iDisplayStart;
      }
      
      if ( oInit.iDeferLoading !== null )
      {
        oSettings.bDeferLoading = true;
        var tmp = $.isArray( oInit.iDeferLoading );
        oSettings._iRecordsDisplay = tmp ? oInit.iDeferLoading[0] : oInit.iDeferLoading;
        oSettings._iRecordsTotal = tmp ? oInit.iDeferLoading[1] : oInit.iDeferLoading;
      }
      
      /* Language definitions */
      if ( oInit.oLanguage.sUrl !== "" )
      {
        /* Get the language definitions from a file - because this Ajax call makes the language
         * get async to the remainder of this function we use bInitHandedOff to indicate that
         * _fnInitialise will be fired by the returned Ajax handler, rather than the constructor
         */
        oSettings.oLanguage.sUrl = oInit.oLanguage.sUrl;
        $.getJSON( oSettings.oLanguage.sUrl, null, function( json ) {
          _fnLanguageCompat( json );
          _fnCamelToHungarian( defaults.oLanguage, json );
          $.extend( true, oSettings.oLanguage, oInit.oLanguage, json );
          _fnInitialise( oSettings );
        } );
        bInitHandedOff = true;
      }
      else
      {
        $.extend( true, oSettings.oLanguage, oInit.oLanguage );
      }
      
      
      /*
       * Stripes
       */
      if ( oInit.asStripeClasses === null )
      {
        oSettings.asStripeClasses =[
          oClasses.sStripeOdd,
          oClasses.sStripeEven
        ];
      }
      
      /* Remove row stripe classes if they are already on the table row */
      var stripeClasses = oSettings.asStripeClasses;
      var rowOne = $('tbody tr:eq(0)', this);
      if ( $.inArray( true, $.map( stripeClasses, function(el, i) {
        return rowOne.hasClass(el);
      } ) ) !== -1 ) {
        $('tbody tr', this).removeClass( stripeClasses.join(' ') );
        oSettings.asDestroyStripes = stripeClasses.slice();
      }
      
      /*
       * Columns
       * See if we should load columns automatically or use defined ones
       */
      var anThs = [];
      var aoColumnsInit;
      var nThead = this.getElementsByTagName('thead');
      if ( nThead.length !== 0 )
      {
        _fnDetectHeader( oSettings.aoHeader, nThead[0] );
        anThs = _fnGetUniqueThs( oSettings );
      }
      
      /* If not given a column array, generate one with nulls */
      if ( oInit.aoColumns === null )
      {
        aoColumnsInit = [];
        for ( i=0, iLen=anThs.length ; i<iLen ; i++ )
        {
          aoColumnsInit.push( null );
        }
      }
      else
      {
        aoColumnsInit = oInit.aoColumns;
      }
      
      /* Add the columns */
      for ( i=0, iLen=aoColumnsInit.length ; i<iLen ; i++ )
      {
        _fnAddColumn( oSettings, anThs ? anThs[i] : null );
      }
      
      /* Apply the column definitions */
      _fnApplyColumnDefs( oSettings, oInit.aoColumnDefs, aoColumnsInit, function (iCol, oDef) {
        _fnColumnOptions( oSettings, iCol, oDef );
      } );
      
      /* HTML5 attribute detection - build an mData object automatically if the
       * attributes are found
       */
      if ( rowOne.length ) {
        var a = function ( cell, name ) {
          return cell.getAttribute( 'data-'+name ) ? name : null;
        };
      
        $.each( _fnGetRowElements( oSettings, rowOne[0] ).cells, function (i, cell) {
          var col = oSettings.aoColumns[i];
      
          if ( col.mData === i ) {
            var sort = a( cell, 'sort' ) || a( cell, 'order' );
            var filter = a( cell, 'filter' ) || a( cell, 'search' );
      
            if ( sort !== null || filter !== null ) {
              col.mData = {
                _:      i+'.display',
                sort:   sort !== null   ? i+'.@data-'+sort   : undefined,
                type:   sort !== null   ? i+'.@data-'+sort   : undefined,
                filter: filter !== null ? i+'.@data-'+filter : undefined
              };
      
              _fnColumnOptions( oSettings, i );
            }
          }
        } );
      }
      
      var features = oSettings.oFeatures;
      
      /* Must be done after everything which can be overridden by the state saving! */
      if ( oInit.bStateSave )
      {
        features.bStateSave = true;
        _fnLoadState( oSettings, oInit );
        _fnCallbackReg( oSettings, 'aoDrawCallback', _fnSaveState, 'state_save' );
      }
      
      
      /*
       * Sorting
       * @todo For modularisation (1.11) this needs to do into a sort start up handler
       */
      
      // If aaSorting is not defined, then we use the first indicator in asSorting
      // in case that has been altered, so the default sort reflects that option
      if ( oInit.aaSorting === undefined )
      {
        var sorting = oSettings.aaSorting;
        for ( i=0, iLen=sorting.length ; i<iLen ; i++ )
        {
          sorting[i][1] = oSettings.aoColumns[ i ].asSorting[0];
        }
      }
      
      /* Do a first pass on the sorting classes (allows any size changes to be taken into
       * account, and also will apply sorting disabled classes if disabled
       */
      _fnSortingClasses( oSettings );
      
      if ( features.bSort )
      {
        _fnCallbackReg( oSettings, 'aoDrawCallback', function () {
          if ( oSettings.bSorted ) {
            var aSort = _fnSortFlatten( oSettings );
            var sortedColumns = {};
      
            $.each( aSort, function (i, val) {
              sortedColumns[ val.src ] = val.dir;
            } );
      
            _fnCallbackFire( oSettings, null, 'order', [oSettings, aSort, sortedColumns] );
            _fnSortAria( oSettings );
          }
        } );
      }
      
      _fnCallbackReg( oSettings, 'aoDrawCallback', function () {
        if ( oSettings.bSorted || _fnDataSource( oSettings ) === 'ssp' || features.bDeferRender ) {
          _fnSortingClasses( oSettings );
        }
      }, 'sc' );
      
      
      /*
       * Final init
       * Cache the header, body and footer as required, creating them if needed
       */
      
      /* Browser support detection */
      _fnBrowserDetect( oSettings );
      
      // Work around for Webkit bug 83867 - store the caption-side before removing from doc
      var captions = $(this).children('caption').each( function () {
        this._captionSide = $(this).css('caption-side');
      } );
      
      var thead = $(this).children('thead');
      if ( thead.length === 0 )
      {
        thead = $('<thead/>').appendTo(this);
      }
      oSettings.nTHead = thead[0];
      
      var tbody = $(this).children('tbody');
      if ( tbody.length === 0 )
      {
        tbody = $('<tbody/>').appendTo(this);
      }
      oSettings.nTBody = tbody[0];
      
      var tfoot = $(this).children('tfoot');
      if ( tfoot.length === 0 && captions.length > 0 && (oSettings.oScroll.sX !== "" || oSettings.oScroll.sY !== "") )
      {
        // If we are a scrolling table, and no footer has been given, then we need to create
        // a tfoot element for the caption element to be appended to
        tfoot = $('<tfoot/>').appendTo(this);
      }
      
      if ( tfoot.length === 0 || tfoot.children().length === 0 ) {
        $(this).addClass( oClasses.sNoFooter );
      }
      else if ( tfoot.length > 0 ) {
        oSettings.nTFoot = tfoot[0];
        _fnDetectHeader( oSettings.aoFooter, oSettings.nTFoot );
      }
      
      /* Check if there is data passing into the constructor */
      if ( oInit.aaData )
      {
        for ( i=0 ; i<oInit.aaData.length ; i++ )
        {
          _fnAddData( oSettings, oInit.aaData[ i ] );
        }
      }
      else if ( oSettings.bDeferLoading || _fnDataSource( oSettings ) == 'dom' )
      {
        /* Grab the data from the page - only do this when deferred loading or no Ajax
         * source since there is no point in reading the DOM data if we are then going
         * to replace it with Ajax data
         */
        _fnAddTr( oSettings, $(oSettings.nTBody).children('tr') );
      }
      
      /* Copy the data index array */
      oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();
      
      /* Initialisation complete - table can be drawn */
      oSettings.bInitialised = true;
      
      /* Check if we need to initialise the table (it might not have been handed off to the
       * language processor)
       */
      if ( bInitHandedOff === false )
      {
        _fnInitialise( oSettings );
      }
    } );
    _that = null;
    return this;
  };

  
  
  /**
   * Computed structure of the DataTables API, defined by the options passed to
   * `DataTable.Api.register()` when building the API.
   *
   * The structure is built in order to speed creation and extension of the Api
   * objects since the extensions are effectively pre-parsed.
   *
   * The array is an array of objects with the following structure, where this
   * base array represents the Api prototype base:
   *
   *     [
   *       {
   *         name:      'data'                -- string   - Property name
   *         val:       function () {},       -- function - Api method (or undefined if just an object
   *         methodExt: [ ... ],              -- array    - Array of Api object definitions to extend the method result
   *         propExt:   [ ... ]               -- array    - Array of Api object definitions to extend the property
   *       },
   *       {
   *         name:     'row'
   *         val:       {},
   *         methodExt: [ ... ],
   *         propExt:   [
   *           {
   *             name:      'data'
   *             val:       function () {},
   *             methodExt: [ ... ],
   *             propExt:   [ ... ]
   *           },
   *           ...
   *         ]
   *       }
   *     ]
   *
   * @type {Array}
   * @ignore
   */
  var __apiStruct = [];
  
  
  /**
   * `Array.prototype` reference.
   *
   * @type object
   * @ignore
   */
  var __arrayProto = Array.prototype;
  
  
  /**
   * Abstraction for `context` parameter of the `Api` constructor to allow it to
   * take several different forms for ease of use.
   *
   * Each of the input parameter types will be converted to a DataTables settings
   * object where possible.
   *
   * @param  {string|node|jQuery|object} mixed DataTable identifier. Can be one
   *   of:
   *
   *   * `string` - jQuery selector. Any DataTables' matching the given selector
   *     with be found and used.
   *   * `node` - `TABLE` node which has already been formed into a DataTable.
   *   * `jQuery` - A jQuery object of `TABLE` nodes.
   *   * `object` - DataTables settings object
   *   * `DataTables.Api` - API instance
   * @return {array|null} Matching DataTables settings objects. `null` or
   *   `undefined` is returned if no matching DataTable is found.
   * @ignore
   */
  var _toSettings = function ( mixed )
  {
    var idx, jq;
    var settings = DataTable.settings;
    var tables = $.map( settings, function (el, i) {
      return el.nTable;
    } );
  
    if ( ! mixed ) {
      return [];
    }
    else if ( mixed.nTable && mixed.oApi ) {
      // DataTables settings object
      return [ mixed ];
    }
    else if ( mixed.nodeName && mixed.nodeName.toLowerCase() === 'table' ) {
      // Table node
      idx = $.inArray( mixed, tables );
      return idx !== -1 ? [ settings[idx] ] : null;
    }
    else if ( mixed && typeof mixed.settings === 'function' ) {
      return mixed.settings().toArray();
    }
    else if ( typeof mixed === 'string' ) {
      // jQuery selector
      jq = $(mixed);
    }
    else if ( mixed instanceof $ ) {
      // jQuery object (also DataTables instance)
      jq = mixed;
    }
  
    if ( jq ) {
      return jq.map( function(i) {
        idx = $.inArray( this, tables );
        return idx !== -1 ? settings[idx] : null;
      } ).toArray();
    }
  };
  
  
  /**
   * DataTables API class - used to control and interface with  one or more
   * DataTables enhanced tables.
   *
   * The API class is heavily based on jQuery, presenting a chainable interface
   * that you can use to interact with tables. Each instance of the API class has
   * a "context" - i.e. the tables that it will operate on. This could be a single
   * table, all tables on a page or a sub-set thereof.
   *
   * Additionally the API is designed to allow you to easily work with the data in
   * the tables, retrieving and manipulating it as required. This is done by
   * presenting the API class as an array like interface. The contents of the
   * array depend upon the actions requested by each method (for example
   * `rows().nodes()` will return an array of nodes, while `rows().data()` will
   * return an array of objects or arrays depending upon your table's
   * configuration). The API object has a number of array like methods (`push`,
   * `pop`, `reverse` etc) as well as additional helper methods (`each`, `pluck`,
   * `unique` etc) to assist your working with the data held in a table.
   *
   * Most methods (those which return an Api instance) are chainable, which means
   * the return from a method call also has all of the methods available that the
   * top level object had. For example, these two calls are equivalent:
   *
   *     // Not chained
   *     api.row.add( {...} );
   *     api.draw();
   *
   *     // Chained
   *     api.row.add( {...} ).draw();
   *
   * @class DataTable.Api
   * @param {array|object|string|jQuery} context DataTable identifier. This is
   *   used to define which DataTables enhanced tables this API will operate on.
   *   Can be one of:
   *
   *   * `string` - jQuery selector. Any DataTables' matching the given selector
   *     with be found and used.
   *   * `node` - `TABLE` node which has already been formed into a DataTable.
   *   * `jQuery` - A jQuery object of `TABLE` nodes.
   *   * `object` - DataTables settings object
   * @param {array} [data] Data to initialise the Api instance with.
   *
   * @example
   *   // Direct initialisation during DataTables construction
   *   var api = $('#example').DataTable();
   *
   * @example
   *   // Initialisation using a DataTables jQuery object
   *   var api = $('#example').dataTable().api();
   *
   * @example
   *   // Initialisation as a constructor
   *   var api = new $.fn.DataTable.Api( 'table.dataTable' );
   */
  _Api = function ( context, data )
  {
    if ( ! this instanceof _Api ) {
      throw 'DT API must be constructed as a new object';
      // or should it do the 'new' for the caller?
      // return new _Api.apply( this, arguments );
    }
  
    var settings = [];
    var ctxSettings = function ( o ) {
      var a = _toSettings( o );
      if ( a ) {
        settings.push.apply( settings, a );
      }
    };
  
    if ( $.isArray( context ) ) {
      for ( var i=0, ien=context.length ; i<ien ; i++ ) {
        ctxSettings( context[i] );
      }
    }
    else {
      ctxSettings( context );
    }
  
    // Remove duplicates
    this.context = _unique( settings );
  
    // Initial data
    if ( data ) {
      this.push.apply( this, data.toArray ? data.toArray() : data );
    }
  
    // selector
    this.selector = {
      rows: null,
      cols: null,
      opts: null
    };
  
    _Api.extend( this, this, __apiStruct );
  };
  
  DataTable.Api = _Api;
  
  _Api.prototype = /** @lends DataTables.Api */{
    /**
     * Return a new Api instance, comprised of the data held in the current
     * instance, join with the other array(s) and/or value(s).
     *
     * An alias for `Array.prototype.concat`.
     *
     * @type method
     * @param {*} value1 Arrays and/or values to concatenate.
     * @param {*} [...] Additional arrays and/or values to concatenate.
     * @returns {DataTables.Api} New API instance, comprising of the combined
     *   array.
     */
    concat:  __arrayProto.concat,
  
  
    context: [], // array of table settings objects
  
  
    each: function ( fn )
    {
      for ( var i=0, ien=this.length ; i<ien; i++ ) {
        fn.call( this, this[i], i, this );
      }
  
      return this;
    },
  
  
    eq: function ( idx )
    {
      var ctx = this.context;
  
      return ctx.length > idx ?
        new _Api( ctx[idx], this[idx] ) :
        null;
    },
  
  
    filter: function ( fn )
    {
      var a = [];
  
      if ( __arrayProto.filter ) {
        a = __arrayProto.filter.call( this, fn, this );
      }
      else {
        // Compatibility for browsers without EMCA-252-5 (JS 1.6)
        for ( var i=0, ien=this.length ; i<ien ; i++ ) {
          if ( fn.call( this, this[i], i, this ) ) {
            a.push( this[i] );
          }
        }
      }
  
      return new _Api( this.context, a );
    },
  
  
    flatten: function ()
    {
      var a = [];
      return new _Api( this.context, a.concat.apply( a, this.toArray() ) );
    },
  
  
    join:    __arrayProto.join,
  
  
    indexOf: __arrayProto.indexOf || function (obj, start)
    {
      for ( var i=(start || 0), ien=this.length ; i<ien ; i++ ) {
        if ( this[i] === obj ) {
          return i;
        }
      }
      return -1;
    },
  
    // Internal only at the moment - relax?
    iterator: function ( flatten, type, fn ) {
      var
        a = [], ret,
        i, ien, j, jen,
        context = this.context,
        rows, items, item,
        selector = this.selector;
  
      // Argument shifting
      if ( typeof flatten === 'string' ) {
        fn = type;
        type = flatten;
        flatten = false;
      }
  
      for ( i=0, ien=context.length ; i<ien ; i++ ) {
        if ( type === 'table' ) {
          ret = fn( context[i], i );
  
          if ( ret !== undefined ) {
            a.push( ret );
          }
        }
        else if ( type === 'columns' || type === 'rows' ) {
          // this has same length as context - one entry for each table
          ret = fn( context[i], this[i], i );
  
          if ( ret !== undefined ) {
            a.push( ret );
          }
        }
        else if ( type === 'column' || type === 'column-rows' || type === 'row' || type === 'cell' ) {
          // columns and rows share the same structure.
          // 'this' is an array of column indexes for each context
          items = this[i];
  
          if ( type === 'column-rows' ) {
            rows = _selector_row_indexes( context[i], selector.opts );
          }
  
          for ( j=0, jen=items.length ; j<jen ; j++ ) {
            item = items[j];
  
            if ( type === 'cell' ) {
              ret = fn( context[i], item.row, item.column, i, j );
            }
            else {
              ret = fn( context[i], item, i, j, rows );
            }
  
            if ( ret !== undefined ) {
              a.push( ret );
            }
          }
        }
      }
  
      if ( a.length ) {
        var api = new _Api( context, flatten ? a.concat.apply( [], a ) : a );
        var apiSelector = api.selector;
        apiSelector.rows = selector.rows;
        apiSelector.cols = selector.cols;
        apiSelector.opts = selector.opts;
        return api;
      }
      return this;
    },
  
  
    lastIndexOf: __arrayProto.lastIndexOf || function (obj, start)
    {
      // Bit cheeky...
      return this.indexOf.apply( this.toArray.reverse(), arguments );
    },
  
  
    length:  0,
  
  
    map: function ( fn )
    {
      var a = [];
  
      if ( __arrayProto.map ) {
        a = __arrayProto.map.call( this, fn, this );
      }
      else {
        // Compatibility for browsers without EMCA-252-5 (JS 1.6)
        for ( var i=0, ien=this.length ; i<ien ; i++ ) {
          a.push( fn.call( this, this[i], i ) );
        }
      }
  
      return new _Api( this.context, a );
    },
  
  
    pluck: function ( prop )
    {
      return this.map( function ( el ) {
        return el[ prop ];
      } );
    },
  
    pop:     __arrayProto.pop,
  
  
    push:    __arrayProto.push,
  
  
    // Does not return an API instance
    reduce: __arrayProto.reduce || function ( fn, init )
    {
      return _fnReduce( this, fn, init, 0, this.length, 1 );
    },
  
  
    reduceRight: __arrayProto.reduceRight || function ( fn, init )
    {
      return _fnReduce( this, fn, init, this.length-1, -1, -1 );
    },
  
  
    reverse: __arrayProto.reverse,
  
  
    // Object with rows, columns and opts
    selector: null,
  
  
    shift:   __arrayProto.shift,
  
  
    sort:    __arrayProto.sort, // ? name - order?
  
  
    splice:  __arrayProto.splice,
  
  
    toArray: function ()
    {
      return __arrayProto.slice.call( this );
    },
  
  
    to$: function ()
    {
      return $( this );
    },
  
  
    toJQuery: function ()
    {
      return $( this );
    },
  
  
    unique: function ()
    {
      return new _Api( this.context, _unique(this) );
    },
  
  
    unshift: __arrayProto.unshift
  };
  
  
  _Api.extend = function ( scope, obj, ext )
  {
    // Only extend API instances and static properties of the API
    if ( ! obj || ( ! (obj instanceof _Api) && ! obj.__dt_wrapper ) ) {
      return;
    }
  
    var
      i, ien,
      j, jen,
      struct, inner,
      methodScoping = function ( scope, fn, struc ) {
        return function () {
          var ret = fn.apply( scope, arguments );
  
          // Method extension
          _Api.extend( ret, ret, struc.methodExt );
          return ret;
        };
      };
  
    for ( i=0, ien=ext.length ; i<ien ; i++ ) {
      struct = ext[i];
  
      // Value
      obj[ struct.name ] = typeof struct.val === 'function' ?
        methodScoping( scope, struct.val, struct ) :
        $.isPlainObject( struct.val ) ?
          {} :
          struct.val;
  
      obj[ struct.name ].__dt_wrapper = true;
  
      // Property extension
      _Api.extend( scope, obj[ struct.name ], struct.propExt );
    }
  };
  
  
  // @todo - Is there need for an augment function?
  // _Api.augment = function ( inst, name )
  // {
  //  // Find src object in the structure from the name
  //  var parts = name.split('.');
  
  //  _Api.extend( inst, obj );
  // };
  
  
  //     [
  //       {
  //         name:      'data'                -- string   - Property name
  //         val:       function () {},       -- function - Api method (or undefined if just an object
  //         methodExt: [ ... ],              -- array    - Array of Api object definitions to extend the method result
  //         propExt:   [ ... ]               -- array    - Array of Api object definitions to extend the property
  //       },
  //       {
  //         name:     'row'
  //         val:       {},
  //         methodExt: [ ... ],
  //         propExt:   [
  //           {
  //             name:      'data'
  //             val:       function () {},
  //             methodExt: [ ... ],
  //             propExt:   [ ... ]
  //           },
  //           ...
  //         ]
  //       }
  //     ]
  
  _Api.register = _api_register = function ( name, val )
  {
    if ( $.isArray( name ) ) {
      for ( var j=0, jen=name.length ; j<jen ; j++ ) {
        _Api.register( name[j], val );
      }
      return;
    }
  
    var
      i, ien,
      heir = name.split('.'),
      struct = __apiStruct,
      key, method;
  
    var find = function ( src, name ) {
      for ( var i=0, ien=src.length ; i<ien ; i++ ) {
        if ( src[i].name === name ) {
          return src[i];
        }
      }
      return null;
    };
  
    for ( i=0, ien=heir.length ; i<ien ; i++ ) {
      method = heir[i].indexOf('()') !== -1;
      key = method ?
        heir[i].replace('()', '') :
        heir[i];
  
      var src = find( struct, key );
      if ( ! src ) {
        src = {
          name:      key,
          val:       {},
          methodExt: [],
          propExt:   []
        };
        struct.push( src );
      }
  
      if ( i === ien-1 ) {
        src.val = val;
      }
      else {
        struct = method ?
          src.methodExt :
          src.propExt;
      }
    }
  };
  
  
  _Api.registerPlural = _api_registerPlural = function ( pluralName, singularName, val ) {
    _Api.register( pluralName, val );
  
    _Api.register( singularName, function () {
      var ret = val.apply( this, arguments );
  
      if ( ret === this ) {
        // Returned item is the API instance that was passed in, return it
        return this;
      }
      else if ( ret instanceof _Api ) {
        // New API instance returned, want the value from the first item
        // in the returned array for the singular result.
        return ret.length ?
          $.isArray( ret[0] ) ?
            new _Api( ret.context, ret[0] ) : // Array results are 'enhanced'
            ret[0] :
          undefined;
      }
  
      // Non-API return - just fire it back
      return ret;
    } );
  };
  
  
  /**
   * Selector for HTML tables. Apply the given selector to the give array of
   * DataTables settings objects.
   *
   * @param {string|integer} [selector] jQuery selector string or integer
   * @param  {array} Array of DataTables settings objects to be filtered
   * @return {array}
   * @ignore
   */
  var __table_selector = function ( selector, a )
  {
    // Integer is used to pick out a table by index
    if ( typeof selector === 'number' ) {
      return [ a[ selector ] ];
    }
  
    // Perform a jQuery selector on the table nodes
    var nodes = $.map( a, function (el, i) {
      return el.nTable;
    } );
  
    return $(nodes)
      .filter( selector )
      .map( function (i) {
        // Need to translate back from the table node to the settings
        var idx = $.inArray( this, nodes );
        return a[ idx ];
      } )
      .toArray();
  };
  
  
  
  /**
   * Context selector for the API's context (i.e. the tables the API instance
   * refers to.
   *
   * @name    DataTable.Api#tables
   * @param {string|integer} [selector] Selector to pick which tables the iterator
   *   should operate on. If not given, all tables in the current context are
   *   used. This can be given as a jQuery selector (for example `':gt(0)'`) to
   *   select multiple tables or as an integer to select a single table.
   * @returns {DataTable.Api} Returns a new API instance if a selector is given.
   */
  _api_register( 'tables()', function ( selector ) {
    // A new instance is created if there was a selector specified
    return selector ?
      new _Api( __table_selector( selector, this.context ) ) :
      this;
  } );
  
  
  _api_register( 'table()', function ( selector ) {
    var tables = this.tables( selector );
    var ctx = tables.context;
  
    // Truncate to the first matched table
    return ctx.length ?
      new _Api( ctx[0] ) :
      tables;
  } );
  
  
  _api_registerPlural( 'tables().nodes()', 'table().node()' , function () {
    return this.iterator( 'table', function ( ctx ) {
      return ctx.nTable;
    } );
  } );
  
  
  _api_registerPlural( 'tables().body()', 'table().body()' , function () {
    return this.iterator( 'table', function ( ctx ) {
      return ctx.nTBody;
    } );
  } );
  
  
  _api_registerPlural( 'tables().header()', 'table().header()' , function () {
    return this.iterator( 'table', function ( ctx ) {
      return ctx.nTHead;
    } );
  } );
  
  
  _api_registerPlural( 'tables().footer()', 'table().footer()' , function () {
    return this.iterator( 'table', function ( ctx ) {
      return ctx.nTFoot;
    } );
  } );
  
  
  _api_registerPlural( 'tables().containers()', 'table().container()' , function () {
    return this.iterator( 'table', function ( ctx ) {
      return ctx.nTableWrapper;
    } );
  } );
  
  
  
  /**
   * Redraw the tables in the current context.
   *
   * @param {boolean} [reset=true] Reset (default) or hold the current paging
   *   position. A full re-sort and re-filter is performed when this method is
   *   called, which is why the pagination reset is the default action.
   * @returns {DataTables.Api} this
   */
  _api_register( 'draw()', function ( resetPaging ) {
    return this.iterator( 'table', function ( settings ) {
      _fnReDraw( settings, resetPaging===false );
    } );
  } );
  
  
  
  /**
   * Get the current page index.
   *
   * @return {integer} Current page index (zero based)
   *//**
   * Set the current page.
   *
   * Note that if you attempt to show a page which does not exist, DataTables will
   * not throw an error, but rather reset the paging.
   *
   * @param {integer|string} action The paging action to take. This can be one of:
   *  * `integer` - The page index to jump to
   *  * `string` - An action to take:
   *    * `first` - Jump to first page.
   *    * `next` - Jump to the next page
   *    * `previous` - Jump to previous page
   *    * `last` - Jump to the last page.
   * @returns {DataTables.Api} this
   */
  _api_register( 'page()', function ( action ) {
    if ( action === undefined ) {
      return this.page.info().page; // not an expensive call
    }
  
    // else, have an action to take on all tables
    return this.iterator( 'table', function ( settings ) {
      _fnPageChange( settings, action );
    } );
  } );
  
  
  /**
   * Paging information for the first table in the current context.
   *
   * If you require paging information for another table, use the `table()` method
   * with a suitable selector.
   *
   * @return {object} Object with the following properties set:
   *  * `page` - Current page index (zero based - i.e. the first page is `0`)
   *  * `pages` - Total number of pages
   *  * `start` - Display index for the first record shown on the current page
   *  * `end` - Display index for the last record shown on the current page
   *  * `length` - Display length (number of records). Note that generally `start
   *    + length = end`, but this is not always true, for example if there are
   *    only 2 records to show on the final page, with a length of 10.
   *  * `recordsTotal` - Full data set length
   *  * `recordsDisplay` - Data set length once the current filtering criterion
   *    are applied.
   */
  _api_register( 'page.info()', function ( action ) {
    if ( this.context.length === 0 ) {
      return undefined;
    }
  
    var
      settings   = this.context[0],
      start      = settings._iDisplayStart,
      len        = settings._iDisplayLength,
      visRecords = settings.fnRecordsDisplay(),
      all        = len === -1;
  
    return {
      "page":           all ? 0 : Math.floor( start / len ),
      "pages":          all ? 1 : Math.ceil( visRecords / len ),
      "start":          start,
      "end":            settings.fnDisplayEnd(),
      "length":         len,
      "recordsTotal":   settings.fnRecordsTotal(),
      "recordsDisplay": visRecords
    };
  } );
  
  
  /**
   * Get the current page length.
   *
   * @return {integer} Current page length. Note `-1` indicates that all records
   *   are to be shown.
   *//**
   * Set the current page length.
   *
   * @param {integer} Page length to set. Use `-1` to show all records.
   * @returns {DataTables.Api} this
   */
  _api_register( 'page.len()', function ( len ) {
    // Note that we can't call this function 'length()' because `length`
    // is a Javascript property of functions which defines how many arguments
    // the function expects.
    if ( len === undefined ) {
      return this.context.length !== 0 ?
        this.context[0]._iDisplayLength :
        undefined;
    }
  
    // else, set the page length
    return this.iterator( 'table', function ( settings ) {
      _fnLengthChange( settings, len );
    } );
  } );
  
  
  
  var __reload = function ( settings, holdPosition, callback ) {
    if ( _fnDataSource( settings ) == 'ssp' ) {
      _fnReDraw( settings, holdPosition );
    }
    else {
      // Trigger xhr
      _fnProcessingDisplay( settings, true );
  
      _fnBuildAjax( settings, [], function( json ) {
        _fnClearTable( settings );
  
        var data = _fnAjaxDataSrc( settings, json );
        for ( var i=0, ien=data.length ; i<ien ; i++ ) {
          _fnAddData( settings, data[i] );
        }
  
        _fnReDraw( settings, holdPosition );
        _fnProcessingDisplay( settings, false );
      } );
    }
  
    // Use the draw event to trigger a callback, regardless of if it is an async
    // or sync draw
    if ( callback ) {
      var api = new _Api( settings );
  
      api.one( 'draw', function () {
        callback( api.ajax.json() );
      } );
    }
  };
  
  
  /**
   * Get the JSON response from the last Ajax request that DataTables made to the
   * server. Note that this returns the JSON from the first table in the current
   * context.
   *
   * @return {object} JSON received from the server.
   */
  _api_register( 'ajax.json()', function () {
    var ctx = this.context;
  
    if ( ctx.length > 0 ) {
      return ctx[0].json;
    }
  
    // else return undefined;
  } );
  
  
  /**
   * Get the data submitted in the last Ajax request
   */
  _api_register( 'ajax.params()', function () {
    var ctx = this.context;
  
    if ( ctx.length > 0 ) {
      return ctx[0].oAjaxData;
    }
  
    // else return undefined;
  } );
  
  
  /**
   * Reload tables from the Ajax data source. Note that this function will
   * automatically re-draw the table when the remote data has been loaded.
   *
   * @param {boolean} [reset=true] Reset (default) or hold the current paging
   *   position. A full re-sort and re-filter is performed when this method is
   *   called, which is why the pagination reset is the default action.
   * @returns {DataTables.Api} this
   */
  _api_register( 'ajax.reload()', function ( callback, resetPaging ) {
    return this.iterator( 'table', function (settings) {
      __reload( settings, resetPaging===false, callback );
    } );
  } );
  
  
  /**
   * Get the current Ajax URL. Note that this returns the URL from the first
   * table in the current context.
   *
   * @return {string} Current Ajax source URL
   *//**
   * Set the Ajax URL. Note that this will set the URL for all tables in the
   * current context.
   *
   * @param {string} url URL to set.
   * @returns {DataTables.Api} this
   */
  _api_register( 'ajax.url()', function ( url ) {
    var ctx = this.context;
  
    if ( url === undefined ) {
      // get
      if ( ctx.length === 0 ) {
        return undefined;
      }
      ctx = ctx[0];
  
      return ctx.ajax ?
        $.isPlainObject( ctx.ajax ) ?
          ctx.ajax.url :
          ctx.ajax :
        ctx.sAjaxSource;
    }
  
    // set
    return this.iterator( 'table', function ( settings ) {
      if ( $.isPlainObject( settings.ajax ) ) {
        settings.ajax.url = url;
      }
      else {
        settings.ajax = url;
      }
      // No need to consider sAjaxSource here since DataTables gives priority
      // to `ajax` over `sAjaxSource`. So setting `ajax` here, renders any
      // value of `sAjaxSource` redundant.
    } );
  } );
  
  
  /**
   * Load data from the newly set Ajax URL. Note that this method is only
   * available when `ajax.url()` is used to set a URL. Additionally, this method
   * has the same effect as calling `ajax.reload()` but is provided for
   * convenience when setting a new URL. Like `ajax.reload()` it will
   * automatically redraw the table once the remote data has been loaded.
   *
   * @returns {DataTables.Api} this
   */
  _api_register( 'ajax.url().load()', function ( callback, resetPaging ) {
    // Same as a reload, but makes sense to present it for easy access after a
    // url change
    return this.iterator( 'table', function ( ctx ) {
      __reload( ctx, resetPaging===false, callback );
    } );
  } );
  
  
  
  
  var _selector_run = function ( selector, select )
  {
    var
      out = [], res,
      a, i, ien, j, jen;
  
    // Can't just check for isArray here, as an API or jQuery instance might be
    // given with their array like look
    if ( ! selector || typeof selector === 'string' || selector.length === undefined ) {
      selector = [ selector ];
    }
  
    for ( i=0, ien=selector.length ; i<ien ; i++ ) {
      a = selector[i] && selector[i].split ?
        selector[i].split(',') :
        [ selector[i] ];
  
      for ( j=0, jen=a.length ; j<jen ; j++ ) {
        res = select( typeof a[j] === 'string' ? $.trim(a[j]) : a[j] );
  
        if ( res && res.length ) {
          out.push.apply( out, res );
        }
      }
    }
  
    return out;
  };
  
  
  var _selector_opts = function ( opts )
  {
    if ( ! opts ) {
      opts = {};
    }
  
    // Backwards compatibility for 1.9- which used the terminology filter rather
    // than search
    if ( opts.filter && ! opts.search ) {
      opts.search = opts.filter;
    }
  
    return {
      search: opts.search || 'none',
      order:  opts.order  || 'current',
      page:   opts.page   || 'all'
    };
  };
  
  
  var _selector_first = function ( inst )
  {
    // Reduce the API instance to the first item found
    for ( var i=0, ien=inst.length ; i<ien ; i++ ) {
      if ( inst[i].length > 0 ) {
        // Assign the first element to the first item in the instance
        // and truncate the instance and context
        inst[0] = inst[i];
        inst.length = 1;
        inst.context = [ inst.context[i] ];
  
        return inst;
      }
    }
  
    // Not found - return an empty instance
    inst.length = 0;
    return inst;
  };
  
  
  var _selector_row_indexes = function ( settings, opts )
  {
    var
      i, ien, tmp, a=[],
      displayFiltered = settings.aiDisplay,
      displayMaster = settings.aiDisplayMaster;
  
    var
      search = opts.search,  // none, applied, removed
      order  = opts.order,   // applied, current, index (original - compatibility with 1.9)
      page   = opts.page;    // all, current
  
    if ( _fnDataSource( settings ) == 'ssp' ) {
      // In server-side processing mode, most options are irrelevant since
      // rows not shown don't exist and the index order is the applied order
      // Removed is a special case - for consistency just return an empty
      // array
      return search === 'removed' ?
        [] :
        _range( 0, displayMaster.length );
    }
    else if ( page == 'current' ) {
      // Current page implies that order=current and fitler=applied, since it is
      // fairly senseless otherwise, regardless of what order and search actually
      // are
      for ( i=settings._iDisplayStart, ien=settings.fnDisplayEnd() ; i<ien ; i++ ) {
        a.push( displayFiltered[i] );
      }
    }
    else if ( order == 'current' || order == 'applied' ) {
      a = search == 'none' ?
        displayMaster.slice() :                      // no search
        search == 'applied' ?
          displayFiltered.slice() :                // applied search
          $.map( displayMaster, function (el, i) { // removed search
            return $.inArray( el, displayFiltered ) === -1 ? el : null;
          } );
    }
    else if ( order == 'index' || order == 'original' ) {
      for ( i=0, ien=settings.aoData.length ; i<ien ; i++ ) {
        if ( search == 'none' ) {
          a.push( i );
        }
        else { // applied | removed
          tmp = $.inArray( i, displayFiltered );
  
          if ((tmp === -1 && search == 'removed') ||
            (tmp >= 0   && search == 'applied') )
          {
            a.push( i );
          }
        }
      }
    }
  
    return a;
  };
  
  
  /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
   * Rows
   *
   * {}          - no selector - use all available rows
   * {integer}   - row aoData index
   * {node}      - TR node
   * {string}    - jQuery selector to apply to the TR elements
   * {array}     - jQuery array of nodes, or simply an array of TR nodes
   *
   */
  
  
  var __row_selector = function ( settings, selector, opts )
  {
    return _selector_run( selector, function ( sel ) {
      var selInt = _intVal( sel );
  
      // Short cut - selector is a number and no options provided (default is
      // all records, so no need to check if the index is in there, since it
      // must be - dev error if the index doesn't exist).
      if ( selInt !== null && ! opts ) {
        return [ selInt ];
      }
  
      var rows = _selector_row_indexes( settings, opts );
  
      if ( selInt !== null && $.inArray( selInt, rows ) !== -1 ) {
        // Selector - integer
        return [ selInt ];
      }
      else if ( ! sel ) {
        // Selector - none
        return rows;
      }
  
      // Get nodes in the order from the `rows` array (can't use `pluck`) @todo - use pluck_order
      var nodes = [];
      for ( var i=0, ien=rows.length ; i<ien ; i++ ) {
        nodes.push( settings.aoData[ rows[i] ].nTr );
      }
  
      if ( sel.nodeName ) {
        // Selector - node
        if ( $.inArray( sel, nodes ) !== -1 ) {
          return [ sel._DT_RowIndex ];// sel is a TR node that is in the table
                      // and DataTables adds a prop for fast lookup
        }
      }
  
      // Selector - jQuery selector string, array of nodes or jQuery object/
      // As jQuery's .filter() allows jQuery objects to be passed in filter,
      // it also allows arrays, so this will cope with all three options
      return $(nodes)
        .filter( sel )
        .map( function () {
          return this._DT_RowIndex;
        } )
        .toArray();
    } );
  };
  
  
  /**
   *
   */
  _api_register( 'rows()', function ( selector, opts ) {
    // argument shifting
    if ( selector === undefined ) {
      selector = '';
    }
    else if ( $.isPlainObject( selector ) ) {
      opts = selector;
      selector = '';
    }
  
    opts = _selector_opts( opts );
  
    var inst = this.iterator( 'table', function ( settings ) {
      return __row_selector( settings, selector, opts );
    } );
  
    // Want argument shifting here and in __row_selector?
    inst.selector.rows = selector;
    inst.selector.opts = opts;
  
    return inst;
  } );
  
  
  _api_register( 'rows().nodes()', function () {
    return this.iterator( 'row', function ( settings, row ) {
      return settings.aoData[ row ].nTr || undefined;
    } );
  } );
  
  _api_register( 'rows().data()', function () {
    return this.iterator( true, 'rows', function ( settings, rows ) {
      return _pluck_order( settings.aoData, rows, '_aData' );
    } );
  } );
  
  _api_registerPlural( 'rows().cache()', 'row().cache()', function ( type ) {
    return this.iterator( 'row', function ( settings, row ) {
      var r = settings.aoData[ row ];
      return type === 'search' ? r._aFilterData : r._aSortData;
    } );
  } );
  
  _api_registerPlural( 'rows().invalidate()', 'row().invalidate()', function ( src ) {
    return this.iterator( 'row', function ( settings, row ) {
      _fnInvalidateRow( settings, row, src );
    } );
  } );
  
  _api_registerPlural( 'rows().indexes()', 'row().index()', function () {
    return this.iterator( 'row', function ( settings, row ) {
      return row;
    } );
  } );
  
  _api_registerPlural( 'rows().remove()', 'row().remove()', function () {
    var that = this;
  
    return this.iterator( 'row', function ( settings, row, thatIdx ) {
      var data = settings.aoData;
  
      data.splice( row, 1 );
  
      // Update the _DT_RowIndex parameter on all rows in the table
      for ( var i=0, ien=data.length ; i<ien ; i++ ) {
        if ( data[i].nTr !== null ) {
          data[i].nTr._DT_RowIndex = i;
        }
      }
  
      // Remove the target row from the search array
      var displayIndex = $.inArray( row, settings.aiDisplay );
  
      // Delete from the display arrays
      _fnDeleteIndex( settings.aiDisplayMaster, row );
      _fnDeleteIndex( settings.aiDisplay, row );
      _fnDeleteIndex( that[ thatIdx ], row, false ); // maintain local indexes
  
      // Check for an 'overflow' they case for displaying the table
      _fnLengthOverflow( settings );
    } );
  } );
  
  
  _api_register( 'rows.add()', function ( rows ) {
    var newRows = this.iterator( 'table', function ( settings ) {
        var row, i, ien;
        var out = [];
  
        for ( i=0, ien=rows.length ; i<ien ; i++ ) {
          row = rows[i];
  
          if ( row.nodeName && row.nodeName.toUpperCase() === 'TR' ) {
            out.push( _fnAddTr( settings, row )[0] );
          }
          else {
            out.push( _fnAddData( settings, row ) );
          }
        }
  
        return out;
      } );
  
    // Return an Api.rows() extended instance, so rows().nodes() etc can be used
    var modRows = this.rows( -1 );
    modRows.pop();
    modRows.push.apply( modRows, newRows.toArray() );
  
    return modRows;
  } );
  
  
  
  
  
  /**
   *
   */
  _api_register( 'row()', function ( selector, opts ) {
    return _selector_first( this.rows( selector, opts ) );
  } );
  
  
  _api_register( 'row().data()', function ( data ) {
    var ctx = this.context;
  
    if ( data === undefined ) {
      // Get
      return ctx.length && this.length ?
        ctx[0].aoData[ this[0] ]._aData :
        undefined;
    }
  
    // Set
    ctx[0].aoData[ this[0] ]._aData = data;
  
    // Automatically invalidate
    _fnInvalidateRow( ctx[0], this[0], 'data' );
  
    return this;
  } );
  
  
  _api_register( 'row().node()', function () {
    var ctx = this.context;
  
    return ctx.length && this.length ?
      ctx[0].aoData[ this[0] ].nTr || null :
      null;
  } );
  
  
  _api_register( 'row.add()', function ( row ) {
    // Allow a jQuery object to be passed in - only a single row is added from
    // it though - the first element in the set
    if ( row instanceof $ && row.length ) {
      row = row[0];
    }
  
    var rows = this.iterator( 'table', function ( settings ) {
      if ( row.nodeName && row.nodeName.toUpperCase() === 'TR' ) {
        return _fnAddTr( settings, row )[0];
      }
      return _fnAddData( settings, row );
    } );
  
    // Return an Api.rows() extended instance, with the newly added row selected
    return this.row( rows[0] );
  } );
  
  
  
  var __details_add = function ( ctx, row, data, klass )
  {
    // Convert to array of TR elements
    var rows = [];
    var addRow = function ( r, k ) {
      // If we get a TR element, then just add it directly - up to the dev
      // to add the correct number of columns etc
      if ( r.nodeName && r.nodeName.toLowerCase() === 'tr' ) {
        rows.push( r );
      }
      else {
        // Otherwise create a row with a wrapper
        var created = $('<tr><td/></tr>').addClass( k );
        $('td', created)
          .addClass( k )
          .html( r )
          [0].colSpan = _fnVisbleColumns( ctx );
  
        rows.push( created[0] );
      }
    };
  
    if ( $.isArray( data ) || data instanceof $ ) {
      for ( var i=0, ien=data.length ; i<ien ; i++ ) {
        addRow( data[i], klass );
      }
    }
    else {
      addRow( data, klass );
    }
  
    if ( row._details ) {
      row._details.remove();
    }
  
    row._details = $(rows);
  
    // If the children were already shown, that state should be retained
    if ( row._detailsShow ) {
      row._details.insertAfter( row.nTr );
    }
  };
  
  
  var __details_remove = function ( api )
  {
    var ctx = api.context;
  
    if ( ctx.length && api.length ) {
      var row = ctx[0].aoData[ api[0] ];
  
      if ( row._details ) {
        row._details.remove();
  
        row._detailsShow = undefined;
        row._details = undefined;
      }
    }
  };
  
  
  var __details_display = function ( api, show ) {
    var ctx = api.context;
  
    if ( ctx.length && api.length ) {
      var row = ctx[0].aoData[ api[0] ];
  
      if ( row._details ) {
        row._detailsShow = show;
  
        if ( show ) {
          row._details.insertAfter( row.nTr );
        }
        else {
          row._details.detach();
        }
  
        __details_events( ctx[0] );
      }
    }
  };
  
  
  var __details_events = function ( settings )
  {
    var api = new _Api( settings );
    var namespace = '.dt.DT_details';
    var drawEvent = 'draw'+namespace;
    var colvisEvent = 'column-visibility'+namespace;
    var destroyEvent = 'destroy'+namespace;
    var data = settings.aoData;
  
    api.off( drawEvent +' '+ colvisEvent +' '+ destroyEvent );
  
    if ( _pluck( data, '_details' ).length > 0 ) {
      // On each draw, insert the required elements into the document
      api.on( drawEvent, function ( e, ctx ) {
        if ( settings !== ctx ) {
          return;
        }
  
        api.rows( {page:'current'} ).eq(0).each( function (idx) {
          // Internal data grab
          var row = data[ idx ];
  
          if ( row._detailsShow ) {
            row._details.insertAfter( row.nTr );
          }
        } );
      } );
  
      // Column visibility change - update the colspan
      api.on( colvisEvent, function ( e, ctx, idx, vis ) {
        if ( settings !== ctx ) {
          return;
        }
  
        // Update the colspan for the details rows (note, only if it already has
        // a colspan)
        var row, visible = _fnVisbleColumns( ctx );
  
        for ( var i=0, ien=data.length ; i<ien ; i++ ) {
          row = data[i];
  
          if ( row._details ) {
            row._details.children('td[colspan]').attr('colspan', visible );
          }
        }
      } );
  
      // Table destroyed - nuke any child rows
      api.on( destroyEvent, function ( e, ctx ) {
        if ( settings !== ctx ) {
          return;
        }
  
        for ( var i=0, ien=data.length ; i<ien ; i++ ) {
          if ( data[i]._details ) {
            __details_remove( data[i] );
          }
        }
      } );
    }
  };
  
  // Strings for the method names to help minification
  var _emp = '';
  var _child_obj = _emp+'row().child';
  var _child_mth = _child_obj+'()';
  
  // data can be:
  //  tr
  //  string
  //  jQuery or array of any of the above
  _api_register( _child_mth, function ( data, klass ) {
    var ctx = this.context;
  
    if ( data === undefined ) {
      // get
      return ctx.length && this.length ?
        ctx[0].aoData[ this[0] ]._details :
        undefined;
    }
    else if ( data === true ) {
      // show
      this.child.show();
    }
    else if ( data === false ) {
      // remove
      __details_remove( this );
    }
    else if ( ctx.length && this.length ) {
      // set
      __details_add( ctx[0], ctx[0].aoData[ this[0] ], data, klass );
    }
  
    return this;
  } );
  
  
  _api_register( [
    _child_obj+'.show()',
    _child_mth+'.show()' // only when `child()` was called with parameters (without
  ], function ( show ) {   // it returns an object and this method is not executed)
    __details_display( this, true );
    return this;
  } );
  
  
  _api_register( [
    _child_obj+'.hide()',
    _child_mth+'.hide()' // only when `child()` was called with parameters (without
  ], function () {         // it returns an object and this method is not executed)
    __details_display( this, false );
    return this;
  } );
  
  
  _api_register( [
    _child_obj+'.remove()',
    _child_mth+'.remove()' // only when `child()` was called with parameters (without
  ], function () {           // it returns an object and this method is not executed)
    __details_remove( this );
    return this;
  } );
  
  
  _api_register( _child_obj+'.isShown()', function () {
    var ctx = this.context;
  
    if ( ctx.length && this.length ) {
      // _detailsShown as false or undefined will fall through to return false
      return ctx[0].aoData[ this[0] ]._detailsShow || false;
    }
    return false;
  } );
  
  
  
  /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
   * Columns
   *
   * {integer}           - column index (>=0 count from left, <0 count from right)
   * "{integer}:visIdx"  - visible column index (i.e. translate to column index)  (>=0 count from left, <0 count from right)
   * "{integer}:visible" - alias for {integer}:visIdx  (>=0 count from left, <0 count from right)
   * "{string}:name"     - column name
   * "{string}"          - jQuery selector on column header nodes
   *
   */
  
  // can be an array of these items, comma separated list, or an array of comma
  // separated lists
  
  var __re_column_selector = /^(.+):(name|visIdx|visible)$/;
  
  var __column_selector = function ( settings, selector, opts )
  {
    var
      columns = settings.aoColumns,
      names = _pluck( columns, 'sName' ),
      nodes = _pluck( columns, 'nTh' );
  
    return _selector_run( selector, function ( s ) {
      var selInt = _intVal( s );
  
      if ( s === '' ) {
        // All columns
        return _range( columns.length );
      }
      else if ( selInt !== null ) {
        // Integer selector
        return [ selInt >= 0 ?
          selInt : // Count from left
          columns.length + selInt // Count from right (+ because its a negative value)
        ];
      }
      else {
        var match = typeof s === 'string' ?
          s.match( __re_column_selector ) :
          '';
  
        if ( match ) {
          switch( match[2] ) {
            case 'visIdx':
            case 'visible':
              var idx = parseInt( match[1], 10 );
              // Visible index given, convert to column index
              if ( idx < 0 ) {
                // Counting from the right
                var visColumns = $.map( columns, function (col,i) {
                  return col.bVisible ? i : null;
                } );
                return [ visColumns[ visColumns.length + idx ] ];
              }
              // Counting from the left
              return [ _fnVisibleToColumnIndex( settings, idx ) ];
  
            case 'name':
              // match by name. `names` is column index complete and in order
              return $.map( names, function (name, i) {
                return name === match[1] ? i : null;
              } );
          }
        }
        else {
          // jQuery selector on the TH elements for the columns
          return $( nodes )
            .filter( s )
            .map( function () {
              return $.inArray( this, nodes ); // `nodes` is column index complete and in order
            } )
            .toArray();
        }
      }
    } );
  };
  
  
  
  
  
  var __setColumnVis = function ( settings, column, vis, recalc ) {
    var
      cols = settings.aoColumns,
      col  = cols[ column ],
      data = settings.aoData,
      row, cells, i, ien, tr;
  
    // Get
    if ( vis === undefined ) {
      return col.bVisible;
    }
  
    // Set
    // No change
    if ( col.bVisible === vis ) {
      return;
    }
  
    if ( vis ) {
      // Insert column
      // Need to decide if we should use appendChild or insertBefore
      var insertBefore = $.inArray( true, _pluck(cols, 'bVisible'), column+1 );
  
      for ( i=0, ien=data.length ; i<ien ; i++ ) {
        tr = data[i].nTr;
        cells = data[i].anCells;
  
        if ( tr ) {
          // insertBefore can act like appendChild if 2nd arg is null
          tr.insertBefore( cells[ column ], cells[ insertBefore ] || null );
        }
      }
    }
    else {
      // Remove column
      $( _pluck( settings.aoData, 'anCells', column ) ).detach();
    }
  
    // Common actions
    col.bVisible = vis;
    _fnDrawHead( settings, settings.aoHeader );
    _fnDrawHead( settings, settings.aoFooter );
  
    if ( recalc === undefined || recalc ) {
      // Automatically adjust column sizing
      _fnAdjustColumnSizing( settings );
  
      // Realign columns for scrolling
      if ( settings.oScroll.sX || settings.oScroll.sY ) {
        _fnScrollDraw( settings );
      }
    }
  
    _fnCallbackFire( settings, null, 'column-visibility', [settings, column, vis] );
  
    _fnSaveState( settings );
  };
  
  
  /**
   *
   */
  _api_register( 'columns()', function ( selector, opts ) {
    // argument shifting
    if ( selector === undefined ) {
      selector = '';
    }
    else if ( $.isPlainObject( selector ) ) {
      opts = selector;
      selector = '';
    }
  
    opts = _selector_opts( opts );
  
    var inst = this.iterator( 'table', function ( settings ) {
      return __column_selector( settings, selector, opts );
    } );
  
    // Want argument shifting here and in _row_selector?
    inst.selector.cols = selector;
    inst.selector.opts = opts;
  
    return inst;
  } );
  
  
  /**
   *
   */
  _api_registerPlural( 'columns().header()', 'column().header()', function ( selector, opts ) {
    return this.iterator( 'column', function ( settings, column ) {
      return settings.aoColumns[column].nTh;
    } );
  } );
  
  
  /**
   *
   */
  _api_registerPlural( 'columns().footer()', 'column().footer()', function ( selector, opts ) {
    return this.iterator( 'column', function ( settings, column ) {
      return settings.aoColumns[column].nTf;
    } );
  } );
  
  
  /**
   *
   */
  _api_registerPlural( 'columns().data()', 'column().data()', function () {
    return this.iterator( 'column-rows', function ( settings, column, i, j, rows ) {
      var a = [];
      for ( var row=0, ien=rows.length ; row<ien ; row++ ) {
        a.push( _fnGetCellData( settings, rows[row], column, '' ) );
      }
      return a;
    } );
  } );
  
  
  _api_registerPlural( 'columns().cache()', 'column().cache()', function ( type ) {
    return this.iterator( 'column-rows', function ( settings, column, i, j, rows ) {
      return _pluck_order( settings.aoData, rows,
        type === 'search' ? '_aFilterData' : '_aSortData', column
      );
    } );
  } );
  
  
  _api_registerPlural( 'columns().nodes()', 'column().nodes()', function () {
    return this.iterator( 'column-rows', function ( settings, column, i, j, rows ) {
      return _pluck_order( settings.aoData, rows, 'anCells', column ) ;
    } );
  } );
  
  
  
  _api_registerPlural( 'columns().visible()', 'column().visible()', function ( vis, calc ) {
    return this.iterator( 'column', function ( settings, column ) {
      return vis === undefined ?
        settings.aoColumns[ column ].bVisible :
        __setColumnVis( settings, column, vis, calc );
    } );
  } );
  
  
  
  _api_registerPlural( 'columns().indexes()', 'column().index()', function ( type ) {
    return this.iterator( 'column', function ( settings, column ) {
      return type === 'visible' ?
        _fnColumnIndexToVisible( settings, column ) :
        column;
    } );
  } );
  
  
  // _api_register( 'columns().show()', function () {
  //  var selector = this.selector;
  //  return this.columns( selector.cols, selector.opts ).visible( true );
  // } );
  
  
  // _api_register( 'columns().hide()', function () {
  //  var selector = this.selector;
  //  return this.columns( selector.cols, selector.opts ).visible( false );
  // } );
  
  
  
  _api_register( 'columns.adjust()', function () {
    return this.iterator( 'table', function ( settings ) {
      _fnAdjustColumnSizing( settings );
    } );
  } );
  
  
  // Convert from one column index type, to another type
  _api_register( 'column.index()', function ( type, idx ) {
    if ( this.context.length !== 0 ) {
      var ctx = this.context[0];
  
      if ( type === 'fromVisible' || type === 'toData' ) {
        return _fnVisibleToColumnIndex( ctx, idx );
      }
      else if ( type === 'fromData' || type === 'toVisible' ) {
        return _fnColumnIndexToVisible( ctx, idx );
      }
    }
  } );
  
  
  _api_register( 'column()', function ( selector, opts ) {
    return _selector_first( this.columns( selector, opts ) );
  } );
  
  
  
  
  var __cell_selector = function ( settings, selector, opts )
  {
    var data = settings.aoData;
    var rows = _selector_row_indexes( settings, opts );
    var cells = _pluck_order( data, rows, 'anCells' );
    var allCells = $( [].concat.apply([], cells) );
    var row;
    var columns = settings.aoColumns.length;
    var a, i, ien, j;
  
    return _selector_run( selector, function ( s ) {
      if ( s === null || s === undefined ) {
        // All cells
        a = [];
  
        for ( i=0, ien=rows.length ; i<ien ; i++ ) {
          row = rows[i];
  
          for ( j=0 ; j<columns ; j++ ) {
            a.push( {
              row: row,
              column: j
            } );
          }
        }
  
        return a;
      }
      else if ( $.isPlainObject( s ) ) {
        return [s];
      }
  
      // jQuery filtered cells
      return allCells
        .filter( s )
        .map( function (i, el) {
          row = el.parentNode._DT_RowIndex;
  
          return {
            row: row,
            column: $.inArray( el, data[ row ].anCells )
          };
        } )
        .toArray();
    } );
  };
  
  
  
  
  _api_register( 'cells()', function ( rowSelector, columnSelector, opts ) {
    // Argument shifting
    if ( $.isPlainObject( rowSelector ) ) {
      // Indexes
      if ( typeof rowSelector.row !== undefined ) {
        opts = columnSelector;
        columnSelector = null;
      }
      else {
        opts = rowSelector;
        rowSelector = null;
      }
    }
    if ( $.isPlainObject( columnSelector ) ) {
      opts = columnSelector;
      columnSelector = null;
    }
  
    // Cell selector
    if ( columnSelector === null || columnSelector === undefined ) {
      return this.iterator( 'table', function ( settings ) {
        return __cell_selector( settings, rowSelector, _selector_opts( opts ) );
      } );
    }
  
    // Row + column selector
    var columns = this.columns( columnSelector, opts );
    var rows = this.rows( rowSelector, opts );
    var a, i, ien, j, jen;
  
    var cells = this.iterator( 'table', function ( settings, idx ) {
      a = [];
  
      for ( i=0, ien=rows[idx].length ; i<ien ; i++ ) {
        for ( j=0, jen=columns[idx].length ; j<jen ; j++ ) {
          a.push( {
            row:    rows[idx][i],
            column: columns[idx][j]
          } );
        }
      }
  
      return a;
    } );
  
    $.extend( cells.selector, {
      cols: columnSelector,
      rows: rowSelector,
      opts: opts
    } );
  
    return cells;
  } );
  
  
  _api_registerPlural( 'cells().nodes()', 'cell().node()', function () {
    return this.iterator( 'cell', function ( settings, row, column ) {
      return settings.aoData[ row ].anCells[ column ];
    } );
  } );
  
  
  _api_register( 'cells().data()', function () {
    return this.iterator( 'cell', function ( settings, row, column ) {
      return _fnGetCellData( settings, row, column );
    } );
  } );
  
  
  _api_registerPlural( 'cells().cache()', 'cell().cache()', function ( type ) {
    type = type === 'search' ? '_aFilterData' : '_aSortData';
  
    return this.iterator( 'cell', function ( settings, row, column ) {
      return settings.aoData[ row ][ type ][ column ];
    } );
  } );
  
  
  _api_registerPlural( 'cells().indexes()', 'cell().index()', function () {
    return this.iterator( 'cell', function ( settings, row, column ) {
      return {
        row: row,
        column: column,
        columnVisible: _fnColumnIndexToVisible( settings, column )
      };
    } );
  } );
  
  
  _api_register( [
    'cells().invalidate()',
    'cell().invalidate()'
  ], function ( src ) {
    var selector = this.selector;
  
    // Use the rows method of the instance to perform the invalidation, rather
    // than doing it here. This avoids needing to handle duplicate rows from
    // the cells.
    this.rows( selector.rows, selector.opts ).invalidate( src );
  
    return this;
  } );
  
  
  
  
  _api_register( 'cell()', function ( rowSelector, columnSelector, opts ) {
    return _selector_first( this.cells( rowSelector, columnSelector, opts ) );
  } );
  
  
  
  _api_register( 'cell().data()', function ( data ) {
    var ctx = this.context;
    var cell = this[0];
  
    if ( data === undefined ) {
      // Get
      return ctx.length && cell.length ?
        _fnGetCellData( ctx[0], cell[0].row, cell[0].column ) :
        undefined;
    }
  
    // Set
    _fnSetCellData( ctx[0], cell[0].row, cell[0].column, data );
    _fnInvalidateRow( ctx[0], cell[0].row, 'data', cell[0].column );
  
    return this;
  } );
  
  
  
  /**
   * Get current ordering (sorting) that has been applied to the table.
   *
   * @returns {array} 2D array containing the sorting information for the first
   *   table in the current context. Each element in the parent array represents
   *   a column being sorted upon (i.e. multi-sorting with two columns would have
   *   2 inner arrays). The inner arrays may have 2 or 3 elements. The first is
   *   the column index that the sorting condition applies to, the second is the
   *   direction of the sort (`desc` or `asc`) and, optionally, the third is the
   *   index of the sorting order from the `column.sorting` initialisation array.
   *//**
   * Set the ordering for the table.
   *
   * @param {integer} order Column index to sort upon.
   * @param {string} direction Direction of the sort to be applied (`asc` or `desc`)
   * @returns {DataTables.Api} this
   *//**
   * Set the ordering for the table.
   *
   * @param {array} order 1D array of sorting information to be applied.
   * @param {array} [...] Optional additional sorting conditions
   * @returns {DataTables.Api} this
   *//**
   * Set the ordering for the table.
   *
   * @param {array} order 2D array of sorting information to be applied.
   * @returns {DataTables.Api} this
   */
  _api_register( 'order()', function ( order, dir ) {
    var ctx = this.context;
  
    if ( order === undefined ) {
      // get
      return ctx.length !== 0 ?
        ctx[0].aaSorting :
        undefined;
    }
  
    // set
    if ( typeof order === 'number' ) {
      // Simple column / direction passed in
      order = [ [ order, dir ] ];
    }
    else if ( ! $.isArray( order[0] ) ) {
      // Arguments passed in (list of 1D arrays)
      order = Array.prototype.slice.call( arguments );
    }
    // otherwise a 2D array was passed in
  
    return this.iterator( 'table', function ( settings ) {
      settings.aaSorting = order.slice();
    } );
  } );
  
  
  /**
   * Attach a sort listener to an element for a given column
   *
   * @param {node|jQuery|string} node Identifier for the element(s) to attach the
   *   listener to. This can take the form of a single DOM node, a jQuery
   *   collection of nodes or a jQuery selector which will identify the node(s).
   * @param {integer} column the column that a click on this node will sort on
   * @param {function} [callback] callback function when sort is run
   * @returns {DataTables.Api} this
   */
  _api_register( 'order.listener()', function ( node, column, callback ) {
    return this.iterator( 'table', function ( settings ) {
      _fnSortAttachListener( settings, node, column, callback );
    } );
  } );
  
  
  // Order by the selected column(s)
  _api_register( [
    'columns().order()',
    'column().order()'
  ], function ( dir ) {
    var that = this;
  
    return this.iterator( 'table', function ( settings, i ) {
      var sort = [];
  
      $.each( that[i], function (j, col) {
        sort.push( [ col, dir ] );
      } );
  
      settings.aaSorting = sort;
    } );
  } );
  
  
  
  _api_register( 'search()', function ( input, regex, smart, caseInsen ) {
    var ctx = this.context;
  
    if ( input === undefined ) {
      // get
      return ctx.length !== 0 ?
        ctx[0].oPreviousSearch.sSearch :
        undefined;
    }
  
    // set
    return this.iterator( 'table', function ( settings ) {
      if ( ! settings.oFeatures.bFilter ) {
        return;
      }
  
      _fnFilterComplete( settings, $.extend( {}, settings.oPreviousSearch, {
        "sSearch": input+"",
        "bRegex":  regex === null ? false : regex,
        "bSmart":  smart === null ? true  : smart,
        "bCaseInsensitive": caseInsen === null ? true : caseInsen
      } ), 1 );
    } );
  } );
  
  
  _api_registerPlural(
    'columns().search()',
    'column().search()',
    function ( input, regex, smart, caseInsen ) {
      return this.iterator( 'column', function ( settings, column ) {
        var preSearch = settings.aoPreSearchCols;
  
        if ( input === undefined ) {
          // get
          return preSearch[ column ].sSearch;
        }
  
        // set
        if ( ! settings.oFeatures.bFilter ) {
          return;
        }
  
        $.extend( preSearch[ column ], {
          "sSearch": input+"",
          "bRegex":  regex === null ? false : regex,
          "bSmart":  smart === null ? true  : smart,
          "bCaseInsensitive": caseInsen === null ? true : caseInsen
        } );
  
        _fnFilterComplete( settings, settings.oPreviousSearch, 1 );
      } );
    }
  );
  
  /*
   * State API methods
   */
  
  _api_register( 'state()', function () {
    return this.context.length ?
      this.context[0].oSavedState :
      null;
  } );
  
  
  _api_register( 'state.clear()', function () {
    return this.iterator( 'table', function ( settings ) {
      // Save an empty object
      settings.fnStateSaveCallback.call( settings.oInstance, settings, {} );
    } );
  } );
  
  
  _api_register( 'state.loaded()', function () {
    return this.context.length ?
      this.context[0].oLoadedState :
      null;
  } );
  
  
  _api_register( 'state.save()', function () {
    return this.iterator( 'table', function ( settings ) {
      _fnSaveState( settings );
    } );
  } );
  
  
  
  /**
   * Provide a common method for plug-ins to check the version of DataTables being
   * used, in order to ensure compatibility.
   *
   *  @param {string} version Version string to check for, in the format "X.Y.Z".
   *    Note that the formats "X" and "X.Y" are also acceptable.
   *  @returns {boolean} true if this version of DataTables is greater or equal to
   *    the required version, or false if this version of DataTales is not
   *    suitable
   *  @static
   *  @dtopt API-Static
   *
   *  @example
   *    alert( $.fn.dataTable.versionCheck( '1.9.0' ) );
   */
  DataTable.versionCheck = DataTable.fnVersionCheck = function( version )
  {
    var aThis = DataTable.version.split('.');
    var aThat = version.split('.');
    var iThis, iThat;
  
    for ( var i=0, iLen=aThat.length ; i<iLen ; i++ ) {
      iThis = parseInt( aThis[i], 10 ) || 0;
      iThat = parseInt( aThat[i], 10 ) || 0;
  
      // Parts are the same, keep comparing
      if (iThis === iThat) {
        continue;
      }
  
      // Parts are different, return immediately
      return iThis > iThat;
    }
  
    return true;
  };
  
  
  /**
   * Check if a `<table>` node is a DataTable table already or not.
   *
   *  @param {node|jquery|string} table Table node, jQuery object or jQuery
   *      selector for the table to test. Note that if more than more than one
   *      table is passed on, only the first will be checked
   *  @returns {boolean} true the table given is a DataTable, or false otherwise
   *  @static
   *  @dtopt API-Static
   *
   *  @example
   *    if ( ! $.fn.DataTable.isDataTable( '#example' ) ) {
   *      $('#example').dataTable();
   *    }
   */
  DataTable.isDataTable = DataTable.fnIsDataTable = function ( table )
  {
    var t = $(table).get(0);
    var is = false;
  
    $.each( DataTable.settings, function (i, o) {
      if ( o.nTable === t || o.nScrollHead === t || o.nScrollFoot === t ) {
        is = true;
      }
    } );
  
    return is;
  };
  
  
  /**
   * Get all DataTable tables that have been initialised - optionally you can
   * select to get only currently visible tables.
   *
   *  @param {boolean} [visible=false] Flag to indicate if you want all (default)
   *    or visible tables only.
   *  @returns {array} Array of `table` nodes (not DataTable instances) which are
   *    DataTables
   *  @static
   *  @dtopt API-Static
   *
   *  @example
   *    $.each( $.fn.dataTable.tables(true), function () {
   *      $(table).DataTable().columns.adjust();
   *    } );
   */
  DataTable.tables = DataTable.fnTables = function ( visible )
  {
    return jQuery.map( DataTable.settings, function (o) {
      if ( !visible || (visible && $(o.nTable).is(':visible')) ) {
        return o.nTable;
      }
    } );
  };
  
  
  /**
   * Convert from camel case parameters to Hungarian notation. This is made public
   * for the extensions to provide the same ability as DataTables core to accept
   * either the 1.9 style Hungarian notation, or the 1.10+ style camelCase
   * parameters.
   *
   *  @param {object} src The model object which holds all parameters that can be
   *    mapped.
   *  @param {object} user The object to convert from camel case to Hungarian.
   *  @param {boolean} force When set to `true`, properties which already have a
   *    Hungarian value in the `user` object will be overwritten. Otherwise they
   *    won't be.
   */
  DataTable.camelToHungarian = _fnCamelToHungarian;
  
  
  
  /**
   *
   */
  _api_register( '$()', function ( selector, opts ) {
    var
      rows   = this.rows( opts ).nodes(), // Get all rows
      jqRows = $(rows);
  
    return $( [].concat(
      jqRows.filter( selector ).toArray(),
      jqRows.find( selector ).toArray()
    ) );
  } );
  
  
  // jQuery functions to operate on the tables
  $.each( [ 'on', 'one', 'off' ], function (i, key) {
    _api_register( key+'()', function ( /* event, handler */ ) {
      var args = Array.prototype.slice.call(arguments);
  
      // Add the `dt` namespace automatically if it isn't already present
      if ( ! args[0].match(/\.dt\b/) ) {
        args[0] += '.dt';
      }
  
      var inst = $( this.tables().nodes() );
      inst[key].apply( inst, args );
      return this;
    } );
  } );
  
  
  _api_register( 'clear()', function () {
    return this.iterator( 'table', function ( settings ) {
      _fnClearTable( settings );
    } );
  } );
  
  
  _api_register( 'settings()', function () {
    return new _Api( this.context, this.context );
  } );
  
  
  _api_register( 'data()', function () {
    return this.iterator( 'table', function ( settings ) {
      return _pluck( settings.aoData, '_aData' );
    } ).flatten();
  } );
  
  
  _api_register( 'destroy()', function ( remove ) {
    remove = remove || false;
  
    return this.iterator( 'table', function ( settings ) {
      var orig      = settings.nTableWrapper.parentNode;
      var classes   = settings.oClasses;
      var table     = settings.nTable;
      var tbody     = settings.nTBody;
      var thead     = settings.nTHead;
      var tfoot     = settings.nTFoot;
      var jqTable   = $(table);
      var jqTbody   = $(tbody);
      var jqWrapper = $(settings.nTableWrapper);
      var rows      = $.map( settings.aoData, function (r) { return r.nTr; } );
      var i, ien;
  
      // Flag to note that the table is currently being destroyed - no action
      // should be taken
      settings.bDestroying = true;
  
      // Fire off the destroy callbacks for plug-ins etc
      _fnCallbackFire( settings, "aoDestroyCallback", "destroy", [settings] );
  
      // If not being removed from the document, make all columns visible
      if ( ! remove ) {
        new _Api( settings ).columns().visible( true );
      }
  
      // Blitz all `DT` namespaced events (these are internal events, the
      // lowercase, `dt` events are user subscribed and they are responsible
      // for removing them
      jqWrapper.unbind('.DT').find(':not(tbody *)').unbind('.DT');
      $(window).unbind('.DT-'+settings.sInstance);
  
      // When scrolling we had to break the table up - restore it
      if ( table != thead.parentNode ) {
        jqTable.children('thead').detach();
        jqTable.append( thead );
      }
  
      if ( tfoot && table != tfoot.parentNode ) {
        jqTable.children('tfoot').detach();
        jqTable.append( tfoot );
      }
  
      // Remove the DataTables generated nodes, events and classes
      jqTable.detach();
      jqWrapper.detach();
  
      settings.aaSorting = [];
      settings.aaSortingFixed = [];
      _fnSortingClasses( settings );
  
      $( rows ).removeClass( settings.asStripeClasses.join(' ') );
  
      $('th, td', thead).removeClass( classes.sSortable+' '+
        classes.sSortableAsc+' '+classes.sSortableDesc+' '+classes.sSortableNone
      );
  
      if ( settings.bJUI ) {
        $('th span.'+classes.sSortIcon+ ', td span.'+classes.sSortIcon, thead).detach();
        $('th, td', thead).each( function () {
          var wrapper = $('div.'+classes.sSortJUIWrapper, this);
          $(this).append( wrapper.contents() );
          wrapper.detach();
        } );
      }
  
      if ( ! remove && orig ) {
        // insertBefore acts like appendChild if !arg[1]
        orig.insertBefore( table, settings.nTableReinsertBefore );
      }
  
      // Add the TR elements back into the table in their original order
      jqTbody.children().detach();
      jqTbody.append( rows );
  
      // Restore the width of the original table - was read from the style property,
      // so we can restore directly to that
      jqTable
        .css( 'width', settings.sDestroyWidth )
        .removeClass( classes.sTable );
  
      // If the were originally stripe classes - then we add them back here.
      // Note this is not fool proof (for example if not all rows had stripe
      // classes - but it's a good effort without getting carried away
      ien = settings.asDestroyStripes.length;
  
      if ( ien ) {
        jqTbody.children().each( function (i) {
          $(this).addClass( settings.asDestroyStripes[i % ien] );
        } );
      }
  
      /* Remove the settings object from the settings array */
      var idx = $.inArray( settings, DataTable.settings );
      if ( idx !== -1 ) {
        DataTable.settings.splice( idx, 1 );
      }
    } );
  } );
  

  /**
   * Version string for plug-ins to check compatibility. Allowed format is
   * `a.b.c-d` where: a:int, b:int, c:int, d:string(dev|beta|alpha). `d` is used
   * only for non-release builds. See http://semver.org/ for more information.
   *  @member
   *  @type string
   *  @default Version number
   */
  DataTable.version = "1.10.2";

  /**
   * Private data store, containing all of the settings objects that are
   * created for the tables on a given page.
   *
   * Note that the `DataTable.settings` object is aliased to
   * `jQuery.fn.dataTableExt` through which it may be accessed and
   * manipulated, or `jQuery.fn.dataTable.settings`.
   *  @member
   *  @type array
   *  @default []
   *  @private
   */
  DataTable.settings = [];

  /**
   * Object models container, for the various models that DataTables has
   * available to it. These models define the objects that are used to hold
   * the active state and configuration of the table.
   *  @namespace
   */
  DataTable.models = {};
  
  
  
  /**
   * Template object for the way in which DataTables holds information about
   * search information for the global filter and individual column filters.
   *  @namespace
   */
  DataTable.models.oSearch = {
    /**
     * Flag to indicate if the filtering should be case insensitive or not
     *  @type boolean
     *  @default true
     */
    "bCaseInsensitive": true,
  
    /**
     * Applied search term
     *  @type string
     *  @default <i>Empty string</i>
     */
    "sSearch": "",
  
    /**
     * Flag to indicate if the search term should be interpreted as a
     * regular expression (true) or not (false) and therefore and special
     * regex characters escaped.
     *  @type boolean
     *  @default false
     */
    "bRegex": false,
  
    /**
     * Flag to indicate if DataTables is to use its smart filtering or not.
     *  @type boolean
     *  @default true
     */
    "bSmart": true
  };
  
  
  
  
  /**
   * Template object for the way in which DataTables holds information about
   * each individual row. This is the object format used for the settings
   * aoData array.
   *  @namespace
   */
  DataTable.models.oRow = {
    /**
     * TR element for the row
     *  @type node
     *  @default null
     */
    "nTr": null,
  
    /**
     * Array of TD elements for each row. This is null until the row has been
     * created.
     *  @type array nodes
     *  @default []
     */
    "anCells": null,
  
    /**
     * Data object from the original data source for the row. This is either
     * an array if using the traditional form of DataTables, or an object if
     * using mData options. The exact type will depend on the passed in
     * data from the data source, or will be an array if using DOM a data
     * source.
     *  @type array|object
     *  @default []
     */
    "_aData": [],
  
    /**
     * Sorting data cache - this array is ostensibly the same length as the
     * number of columns (although each index is generated only as it is
     * needed), and holds the data that is used for sorting each column in the
     * row. We do this cache generation at the start of the sort in order that
     * the formatting of the sort data need be done only once for each cell
     * per sort. This array should not be read from or written to by anything
     * other than the master sorting methods.
     *  @type array
     *  @default null
     *  @private
     */
    "_aSortData": null,
  
    /**
     * Per cell filtering data cache. As per the sort data cache, used to
     * increase the performance of the filtering in DataTables
     *  @type array
     *  @default null
     *  @private
     */
    "_aFilterData": null,
  
    /**
     * Filtering data cache. This is the same as the cell filtering cache, but
     * in this case a string rather than an array. This is easily computed with
     * a join on `_aFilterData`, but is provided as a cache so the join isn't
     * needed on every search (memory traded for performance)
     *  @type array
     *  @default null
     *  @private
     */
    "_sFilterRow": null,
  
    /**
     * Cache of the class name that DataTables has applied to the row, so we
     * can quickly look at this variable rather than needing to do a DOM check
     * on className for the nTr property.
     *  @type string
     *  @default <i>Empty string</i>
     *  @private
     */
    "_sRowStripe": "",
  
    /**
     * Denote if the original data source was from the DOM, or the data source
     * object. This is used for invalidating data, so DataTables can
     * automatically read data from the original source, unless uninstructed
     * otherwise.
     *  @type string
     *  @default null
     *  @private
     */
    "src": null
  };
  
  
  /**
   * Template object for the column information object in DataTables. This object
   * is held in the settings aoColumns array and contains all the information that
   * DataTables needs about each individual column.
   *
   * Note that this object is related to {@link DataTable.defaults.column}
   * but this one is the internal data store for DataTables's cache of columns.
   * It should NOT be manipulated outside of DataTables. Any configuration should
   * be done through the initialisation options.
   *  @namespace
   */
  DataTable.models.oColumn = {
    /**
     * Column index. This could be worked out on-the-fly with $.inArray, but it
     * is faster to just hold it as a variable
     *  @type integer
     *  @default null
     */
    "idx": null,
  
    /**
     * A list of the columns that sorting should occur on when this column
     * is sorted. That this property is an array allows multi-column sorting
     * to be defined for a column (for example first name / last name columns
     * would benefit from this). The values are integers pointing to the
     * columns to be sorted on (typically it will be a single integer pointing
     * at itself, but that doesn't need to be the case).
     *  @type array
     */
    "aDataSort": null,
  
    /**
     * Define the sorting directions that are applied to the column, in sequence
     * as the column is repeatedly sorted upon - i.e. the first value is used
     * as the sorting direction when the column if first sorted (clicked on).
     * Sort it again (click again) and it will move on to the next index.
     * Repeat until loop.
     *  @type array
     */
    "asSorting": null,
  
    /**
     * Flag to indicate if the column is searchable, and thus should be included
     * in the filtering or not.
     *  @type boolean
     */
    "bSearchable": null,
  
    /**
     * Flag to indicate if the column is sortable or not.
     *  @type boolean
     */
    "bSortable": null,
  
    /**
     * Flag to indicate if the column is currently visible in the table or not
     *  @type boolean
     */
    "bVisible": null,
  
    /**
     * Store for manual type assignment using the `column.type` option. This
     * is held in store so we can manipulate the column's `sType` property.
     *  @type string
     *  @default null
     *  @private
     */
    "_sManualType": null,
  
    /**
     * Flag to indicate if HTML5 data attributes should be used as the data
     * source for filtering or sorting. True is either are.
     *  @type boolean
     *  @default false
     *  @private
     */
    "_bAttrSrc": false,
  
    /**
     * Developer definable function that is called whenever a cell is created (Ajax source,
     * etc) or processed for input (DOM source). This can be used as a compliment to mRender
     * allowing you to modify the DOM element (add background colour for example) when the
     * element is available.
     *  @type function
     *  @param {element} nTd The TD node that has been created
     *  @param {*} sData The Data for the cell
     *  @param {array|object} oData The data for the whole row
     *  @param {int} iRow The row index for the aoData data store
     *  @default null
     */
    "fnCreatedCell": null,
  
    /**
     * Function to get data from a cell in a column. You should <b>never</b>
     * access data directly through _aData internally in DataTables - always use
     * the method attached to this property. It allows mData to function as
     * required. This function is automatically assigned by the column
     * initialisation method
     *  @type function
     *  @param {array|object} oData The data array/object for the array
     *    (i.e. aoData[]._aData)
     *  @param {string} sSpecific The specific data type you want to get -
     *    'display', 'type' 'filter' 'sort'
     *  @returns {*} The data for the cell from the given row's data
     *  @default null
     */
    "fnGetData": null,
  
    /**
     * Function to set data for a cell in the column. You should <b>never</b>
     * set the data directly to _aData internally in DataTables - always use
     * this method. It allows mData to function as required. This function
     * is automatically assigned by the column initialisation method
     *  @type function
     *  @param {array|object} oData The data array/object for the array
     *    (i.e. aoData[]._aData)
     *  @param {*} sValue Value to set
     *  @default null
     */
    "fnSetData": null,
  
    /**
     * Property to read the value for the cells in the column from the data
     * source array / object. If null, then the default content is used, if a
     * function is given then the return from the function is used.
     *  @type function|int|string|null
     *  @default null
     */
    "mData": null,
  
    /**
     * Partner property to mData which is used (only when defined) to get
     * the data - i.e. it is basically the same as mData, but without the
     * 'set' option, and also the data fed to it is the result from mData.
     * This is the rendering method to match the data method of mData.
     *  @type function|int|string|null
     *  @default null
     */
    "mRender": null,
  
    /**
     * Unique header TH/TD element for this column - this is what the sorting
     * listener is attached to (if sorting is enabled.)
     *  @type node
     *  @default null
     */
    "nTh": null,
  
    /**
     * Unique footer TH/TD element for this column (if there is one). Not used
     * in DataTables as such, but can be used for plug-ins to reference the
     * footer for each column.
     *  @type node
     *  @default null
     */
    "nTf": null,
  
    /**
     * The class to apply to all TD elements in the table's TBODY for the column
     *  @type string
     *  @default null
     */
    "sClass": null,
  
    /**
     * When DataTables calculates the column widths to assign to each column,
     * it finds the longest string in each column and then constructs a
     * temporary table and reads the widths from that. The problem with this
     * is that "mmm" is much wider then "iiii", but the latter is a longer
     * string - thus the calculation can go wrong (doing it properly and putting
     * it into an DOM object and measuring that is horribly(!) slow). Thus as
     * a "work around" we provide this option. It will append its value to the
     * text that is found to be the longest string for the column - i.e. padding.
     *  @type string
     */
    "sContentPadding": null,
  
    /**
     * Allows a default value to be given for a column's data, and will be used
     * whenever a null data source is encountered (this can be because mData
     * is set to null, or because the data source itself is null).
     *  @type string
     *  @default null
     */
    "sDefaultContent": null,
  
    /**
     * Name for the column, allowing reference to the column by name as well as
     * by index (needs a lookup to work by name).
     *  @type string
     */
    "sName": null,
  
    /**
     * Custom sorting data type - defines which of the available plug-ins in
     * afnSortData the custom sorting will use - if any is defined.
     *  @type string
     *  @default std
     */
    "sSortDataType": 'std',
  
    /**
     * Class to be applied to the header element when sorting on this column
     *  @type string
     *  @default null
     */
    "sSortingClass": null,
  
    /**
     * Class to be applied to the header element when sorting on this column -
     * when jQuery UI theming is used.
     *  @type string
     *  @default null
     */
    "sSortingClassJUI": null,
  
    /**
     * Title of the column - what is seen in the TH element (nTh).
     *  @type string
     */
    "sTitle": null,
  
    /**
     * Column sorting and filtering type
     *  @type string
     *  @default null
     */
    "sType": null,
  
    /**
     * Width of the column
     *  @type string
     *  @default null
     */
    "sWidth": null,
  
    /**
     * Width of the column when it was first "encountered"
     *  @type string
     *  @default null
     */
    "sWidthOrig": null
  };
  
  
  /*
   * Developer note: The properties of the object below are given in Hungarian
   * notation, that was used as the interface for DataTables prior to v1.10, however
   * from v1.10 onwards the primary interface is camel case. In order to avoid
   * breaking backwards compatibility utterly with this change, the Hungarian
   * version is still, internally the primary interface, but is is not documented
   * - hence the @name tags in each doc comment. This allows a Javascript function
   * to create a map from Hungarian notation to camel case (going the other direction
   * would require each property to be listed, which would at around 3K to the size
   * of DataTables, while this method is about a 0.5K hit.
   *
   * Ultimately this does pave the way for Hungarian notation to be dropped
   * completely, but that is a massive amount of work and will break current
   * installs (therefore is on-hold until v2).
   */
  
  /**
   * Initialisation options that can be given to DataTables at initialisation
   * time.
   *  @namespace
   */
  DataTable.defaults = {
    /**
     * An array of data to use for the table, passed in at initialisation which
     * will be used in preference to any data which is already in the DOM. This is
     * particularly useful for constructing tables purely in Javascript, for
     * example with a custom Ajax call.
     *  @type array
     *  @default null
     *
     *  @dtopt Option
     *  @name DataTable.defaults.data
     *
     *  @example
     *    // Using a 2D array data source
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "data": [
     *          ['Trident', 'Internet Explorer 4.0', 'Win 95+', 4, 'X'],
     *          ['Trident', 'Internet Explorer 5.0', 'Win 95+', 5, 'C'],
     *        ],
     *        "columns": [
     *          { "title": "Engine" },
     *          { "title": "Browser" },
     *          { "title": "Platform" },
     *          { "title": "Version" },
     *          { "title": "Grade" }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using an array of objects as a data source (`data`)
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "data": [
     *          {
     *            "engine":   "Trident",
     *            "browser":  "Internet Explorer 4.0",
     *            "platform": "Win 95+",
     *            "version":  4,
     *            "grade":    "X"
     *          },
     *          {
     *            "engine":   "Trident",
     *            "browser":  "Internet Explorer 5.0",
     *            "platform": "Win 95+",
     *            "version":  5,
     *            "grade":    "C"
     *          }
     *        ],
     *        "columns": [
     *          { "title": "Engine",   "data": "engine" },
     *          { "title": "Browser",  "data": "browser" },
     *          { "title": "Platform", "data": "platform" },
     *          { "title": "Version",  "data": "version" },
     *          { "title": "Grade",    "data": "grade" }
     *        ]
     *      } );
     *    } );
     */
    "aaData": null,
  
  
    /**
     * If ordering is enabled, then DataTables will perform a first pass sort on
     * initialisation. You can define which column(s) the sort is performed
     * upon, and the sorting direction, with this variable. The `sorting` array
     * should contain an array for each column to be sorted initially containing
     * the column's index and a direction string ('asc' or 'desc').
     *  @type array
     *  @default [[0,'asc']]
     *
     *  @dtopt Option
     *  @name DataTable.defaults.order
     *
     *  @example
     *    // Sort by 3rd column first, and then 4th column
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "order": [[2,'asc'], [3,'desc']]
     *      } );
     *    } );
     *
     *    // No initial sorting
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "order": []
     *      } );
     *    } );
     */
    "aaSorting": [[0,'asc']],
  
  
    /**
     * This parameter is basically identical to the `sorting` parameter, but
     * cannot be overridden by user interaction with the table. What this means
     * is that you could have a column (visible or hidden) which the sorting
     * will always be forced on first - any sorting after that (from the user)
     * will then be performed as required. This can be useful for grouping rows
     * together.
     *  @type array
     *  @default null
     *
     *  @dtopt Option
     *  @name DataTable.defaults.orderFixed
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "orderFixed": [[0,'asc']]
     *      } );
     *    } )
     */
    "aaSortingFixed": [],
  
  
    /**
     * DataTables can be instructed to load data to display in the table from a
     * Ajax source. This option defines how that Ajax call is made and where to.
     *
     * The `ajax` property has three different modes of operation, depending on
     * how it is defined. These are:
     *
     * * `string` - Set the URL from where the data should be loaded from.
     * * `object` - Define properties for `jQuery.ajax`.
     * * `function` - Custom data get function
     *
     * `string`
     * --------
     *
     * As a string, the `ajax` property simply defines the URL from which
     * DataTables will load data.
     *
     * `object`
     * --------
     *
     * As an object, the parameters in the object are passed to
     * [jQuery.ajax](http://api.jquery.com/jQuery.ajax/) allowing fine control
     * of the Ajax request. DataTables has a number of default parameters which
     * you can override using this option. Please refer to the jQuery
     * documentation for a full description of the options available, although
     * the following parameters provide additional options in DataTables or
     * require special consideration:
     *
     * * `data` - As with jQuery, `data` can be provided as an object, but it
     *   can also be used as a function to manipulate the data DataTables sends
     *   to the server. The function takes a single parameter, an object of
     *   parameters with the values that DataTables has readied for sending. An
     *   object may be returned which will be merged into the DataTables
     *   defaults, or you can add the items to the object that was passed in and
     *   not return anything from the function. This supersedes `fnServerParams`
     *   from DataTables 1.9-.
     *
     * * `dataSrc` - By default DataTables will look for the property `data` (or
     *   `aaData` for compatibility with DataTables 1.9-) when obtaining data
     *   from an Ajax source or for server-side processing - this parameter
     *   allows that property to be changed. You can use Javascript dotted
     *   object notation to get a data source for multiple levels of nesting, or
     *   it my be used as a function. As a function it takes a single parameter,
     *   the JSON returned from the server, which can be manipulated as
     *   required, with the returned value being that used by DataTables as the
     *   data source for the table. This supersedes `sAjaxDataProp` from
     *   DataTables 1.9-.
     *
     * * `success` - Should not be overridden it is used internally in
     *   DataTables. To manipulate / transform the data returned by the server
     *   use `ajax.dataSrc`, or use `ajax` as a function (see below).
     *
     * `function`
     * ----------
     *
     * As a function, making the Ajax call is left up to yourself allowing
     * complete control of the Ajax request. Indeed, if desired, a method other
     * than Ajax could be used to obtain the required data, such as Web storage
     * or an AIR database.
     *
     * The function is given four parameters and no return is required. The
     * parameters are:
     *
     * 1. _object_ - Data to send to the server
     * 2. _function_ - Callback function that must be executed when the required
     *    data has been obtained. That data should be passed into the callback
     *    as the only parameter
     * 3. _object_ - DataTables settings object for the table
     *
     * Note that this supersedes `fnServerData` from DataTables 1.9-.
     *
     *  @type string|object|function
     *  @default null
     *
     *  @dtopt Option
     *  @name DataTable.defaults.ajax
     *  @since 1.10.0
     *
     * @example
     *   // Get JSON data from a file via Ajax.
     *   // Note DataTables expects data in the form `{ data: [ ...data... ] }` by default).
     *   $('#example').dataTable( {
     *     "ajax": "data.json"
     *   } );
     *
     * @example
     *   // Get JSON data from a file via Ajax, using `dataSrc` to change
     *   // `data` to `tableData` (i.e. `{ tableData: [ ...data... ] }`)
     *   $('#example').dataTable( {
     *     "ajax": {
     *       "url": "data.json",
     *       "dataSrc": "tableData"
     *     }
     *   } );
     *
     * @example
     *   // Get JSON data from a file via Ajax, using `dataSrc` to read data
     *   // from a plain array rather than an array in an object
     *   $('#example').dataTable( {
     *     "ajax": {
     *       "url": "data.json",
     *       "dataSrc": ""
     *     }
     *   } );
     *
     * @example
     *   // Manipulate the data returned from the server - add a link to data
     *   // (note this can, should, be done using `render` for the column - this
     *   // is just a simple example of how the data can be manipulated).
     *   $('#example').dataTable( {
     *     "ajax": {
     *       "url": "data.json",
     *       "dataSrc": function ( json ) {
     *         for ( var i=0, ien=json.length ; i<ien ; i++ ) {
     *           json[i][0] = '<a href="/message/'+json[i][0]+'>View message</a>';
     *         }
     *         return json;
     *       }
     *     }
     *   } );
     *
     * @example
     *   // Add data to the request
     *   $('#example').dataTable( {
     *     "ajax": {
     *       "url": "data.json",
     *       "data": function ( d ) {
     *         return {
     *           "extra_search": $('#extra').val()
     *         };
     *       }
     *     }
     *   } );
     *
     * @example
     *   // Send request as POST
     *   $('#example').dataTable( {
     *     "ajax": {
     *       "url": "data.json",
     *       "type": "POST"
     *     }
     *   } );
     *
     * @example
     *   // Get the data from localStorage (could interface with a form for
     *   // adding, editing and removing rows).
     *   $('#example').dataTable( {
     *     "ajax": function (data, callback, settings) {
     *       callback(
     *         JSON.parse( localStorage.getItem('dataTablesData') )
     *       );
     *     }
     *   } );
     */
    "ajax": null,
  
  
    /**
     * This parameter allows you to readily specify the entries in the length drop
     * down menu that DataTables shows when pagination is enabled. It can be
     * either a 1D array of options which will be used for both the displayed
     * option and the value, or a 2D array which will use the array in the first
     * position as the value, and the array in the second position as the
     * displayed options (useful for language strings such as 'All').
     *
     * Note that the `pageLength` property will be automatically set to the
     * first value given in this array, unless `pageLength` is also provided.
     *  @type array
     *  @default [ 10, 25, 50, 100 ]
     *
     *  @dtopt Option
     *  @name DataTable.defaults.lengthMenu
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "lengthMenu": [[10, 25, 50, -1], [10, 25, 50, "All"]]
     *      } );
     *    } );
     */
    "aLengthMenu": [ 10, 25, 50, 100 ],
  
  
    /**
     * The `columns` option in the initialisation parameter allows you to define
     * details about the way individual columns behave. For a full list of
     * column options that can be set, please see
     * {@link DataTable.defaults.column}. Note that if you use `columns` to
     * define your columns, you must have an entry in the array for every single
     * column that you have in your table (these can be null if you don't which
     * to specify any options).
     *  @member
     *
     *  @name DataTable.defaults.column
     */
    "aoColumns": null,
  
    /**
     * Very similar to `columns`, `columnDefs` allows you to target a specific
     * column, multiple columns, or all columns, using the `targets` property of
     * each object in the array. This allows great flexibility when creating
     * tables, as the `columnDefs` arrays can be of any length, targeting the
     * columns you specifically want. `columnDefs` may use any of the column
     * options available: {@link DataTable.defaults.column}, but it _must_
     * have `targets` defined in each object in the array. Values in the `targets`
     * array may be:
     *   <ul>
     *     <li>a string - class name will be matched on the TH for the column</li>
     *     <li>0 or a positive integer - column index counting from the left</li>
     *     <li>a negative integer - column index counting from the right</li>
     *     <li>the string "_all" - all columns (i.e. assign a default)</li>
     *   </ul>
     *  @member
     *
     *  @name DataTable.defaults.columnDefs
     */
    "aoColumnDefs": null,
  
  
    /**
     * Basically the same as `search`, this parameter defines the individual column
     * filtering state at initialisation time. The array must be of the same size
     * as the number of columns, and each element be an object with the parameters
     * `search` and `escapeRegex` (the latter is optional). 'null' is also
     * accepted and the default will be used.
     *  @type array
     *  @default []
     *
     *  @dtopt Option
     *  @name DataTable.defaults.searchCols
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "searchCols": [
     *          null,
     *          { "search": "My filter" },
     *          null,
     *          { "search": "^[0-9]", "escapeRegex": false }
     *        ]
     *      } );
     *    } )
     */
    "aoSearchCols": [],
  
  
    /**
     * An array of CSS classes that should be applied to displayed rows. This
     * array may be of any length, and DataTables will apply each class
     * sequentially, looping when required.
     *  @type array
     *  @default null <i>Will take the values determined by the `oClasses.stripe*`
     *    options</i>
     *
     *  @dtopt Option
     *  @name DataTable.defaults.stripeClasses
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "stripeClasses": [ 'strip1', 'strip2', 'strip3' ]
     *      } );
     *    } )
     */
    "asStripeClasses": null,
  
  
    /**
     * Enable or disable automatic column width calculation. This can be disabled
     * as an optimisation (it takes some time to calculate the widths) if the
     * tables widths are passed in using `columns`.
     *  @type boolean
     *  @default true
     *
     *  @dtopt Features
     *  @name DataTable.defaults.autoWidth
     *
     *  @example
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "autoWidth": false
     *      } );
     *    } );
     */
    "bAutoWidth": true,
  
  
    /**
     * Deferred rendering can provide DataTables with a huge speed boost when you
     * are using an Ajax or JS data source for the table. This option, when set to
     * true, will cause DataTables to defer the creation of the table elements for
     * each row until they are needed for a draw - saving a significant amount of
     * time.
     *  @type boolean
     *  @default false
     *
     *  @dtopt Features
     *  @name DataTable.defaults.deferRender
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "ajax": "sources/arrays.txt",
     *        "deferRender": true
     *      } );
     *    } );
     */
    "bDeferRender": false,
  
  
    /**
     * Replace a DataTable which matches the given selector and replace it with
     * one which has the properties of the new initialisation object passed. If no
     * table matches the selector, then the new DataTable will be constructed as
     * per normal.
     *  @type boolean
     *  @default false
     *
     *  @dtopt Options
     *  @name DataTable.defaults.destroy
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "srollY": "200px",
     *        "paginate": false
     *      } );
     *
     *      // Some time later....
     *      $('#example').dataTable( {
     *        "filter": false,
     *        "destroy": true
     *      } );
     *    } );
     */
    "bDestroy": false,
  
  
    /**
     * Enable or disable filtering of data. Filtering in DataTables is "smart" in
     * that it allows the end user to input multiple words (space separated) and
     * will match a row containing those words, even if not in the order that was
     * specified (this allow matching across multiple columns). Note that if you
     * wish to use filtering in DataTables this must remain 'true' - to remove the
     * default filtering input box and retain filtering abilities, please use
     * {@link DataTable.defaults.dom}.
     *  @type boolean
     *  @default true
     *
     *  @dtopt Features
     *  @name DataTable.defaults.searching
     *
     *  @example
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "searching": false
     *      } );
     *    } );
     */
    "bFilter": true,
  
  
    /**
     * Enable or disable the table information display. This shows information
     * about the data that is currently visible on the page, including information
     * about filtered data if that action is being performed.
     *  @type boolean
     *  @default true
     *
     *  @dtopt Features
     *  @name DataTable.defaults.info
     *
     *  @example
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "info": false
     *      } );
     *    } );
     */
    "bInfo": true,
  
  
    /**
     * Enable jQuery UI ThemeRoller support (required as ThemeRoller requires some
     * slightly different and additional mark-up from what DataTables has
     * traditionally used).
     *  @type boolean
     *  @default false
     *
     *  @dtopt Features
     *  @name DataTable.defaults.jQueryUI
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "jQueryUI": true
     *      } );
     *    } );
     */
    "bJQueryUI": false,
  
  
    /**
     * Allows the end user to select the size of a formatted page from a select
     * menu (sizes are 10, 25, 50 and 100). Requires pagination (`paginate`).
     *  @type boolean
     *  @default true
     *
     *  @dtopt Features
     *  @name DataTable.defaults.lengthChange
     *
     *  @example
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "lengthChange": false
     *      } );
     *    } );
     */
    "bLengthChange": true,
  
  
    /**
     * Enable or disable pagination.
     *  @type boolean
     *  @default true
     *
     *  @dtopt Features
     *  @name DataTable.defaults.paging
     *
     *  @example
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "paging": false
     *      } );
     *    } );
     */
    "bPaginate": true,
  
  
    /**
     * Enable or disable the display of a 'processing' indicator when the table is
     * being processed (e.g. a sort). This is particularly useful for tables with
     * large amounts of data where it can take a noticeable amount of time to sort
     * the entries.
     *  @type boolean
     *  @default false
     *
     *  @dtopt Features
     *  @name DataTable.defaults.processing
     *
     *  @example
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "processing": true
     *      } );
     *    } );
     */
    "bProcessing": false,
  
  
    /**
     * Retrieve the DataTables object for the given selector. Note that if the
     * table has already been initialised, this parameter will cause DataTables
     * to simply return the object that has already been set up - it will not take
     * account of any changes you might have made to the initialisation object
     * passed to DataTables (setting this parameter to true is an acknowledgement
     * that you understand this). `destroy` can be used to reinitialise a table if
     * you need.
     *  @type boolean
     *  @default false
     *
     *  @dtopt Options
     *  @name DataTable.defaults.retrieve
     *
     *  @example
     *    $(document).ready( function() {
     *      initTable();
     *      tableActions();
     *    } );
     *
     *    function initTable ()
     *    {
     *      return $('#example').dataTable( {
     *        "scrollY": "200px",
     *        "paginate": false,
     *        "retrieve": true
     *      } );
     *    }
     *
     *    function tableActions ()
     *    {
     *      var table = initTable();
     *      // perform API operations with oTable
     *    }
     */
    "bRetrieve": false,
  
  
    /**
     * When vertical (y) scrolling is enabled, DataTables will force the height of
     * the table's viewport to the given height at all times (useful for layout).
     * However, this can look odd when filtering data down to a small data set,
     * and the footer is left "floating" further down. This parameter (when
     * enabled) will cause DataTables to collapse the table's viewport down when
     * the result set will fit within the given Y height.
     *  @type boolean
     *  @default false
     *
     *  @dtopt Options
     *  @name DataTable.defaults.scrollCollapse
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "scrollY": "200",
     *        "scrollCollapse": true
     *      } );
     *    } );
     */
    "bScrollCollapse": false,
  
  
    /**
     * Configure DataTables to use server-side processing. Note that the
     * `ajax` parameter must also be given in order to give DataTables a
     * source to obtain the required data for each draw.
     *  @type boolean
     *  @default false
     *
     *  @dtopt Features
     *  @dtopt Server-side
     *  @name DataTable.defaults.serverSide
     *
     *  @example
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "serverSide": true,
     *        "ajax": "xhr.php"
     *      } );
     *    } );
     */
    "bServerSide": false,
  
  
    /**
     * Enable or disable sorting of columns. Sorting of individual columns can be
     * disabled by the `sortable` option for each column.
     *  @type boolean
     *  @default true
     *
     *  @dtopt Features
     *  @name DataTable.defaults.ordering
     *
     *  @example
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "ordering": false
     *      } );
     *    } );
     */
    "bSort": true,
  
  
    /**
     * Enable or display DataTables' ability to sort multiple columns at the
     * same time (activated by shift-click by the user).
     *  @type boolean
     *  @default true
     *
     *  @dtopt Options
     *  @name DataTable.defaults.orderMulti
     *
     *  @example
     *    // Disable multiple column sorting ability
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "orderMulti": false
     *      } );
     *    } );
     */
    "bSortMulti": true,
  
  
    /**
     * Allows control over whether DataTables should use the top (true) unique
     * cell that is found for a single column, or the bottom (false - default).
     * This is useful when using complex headers.
     *  @type boolean
     *  @default false
     *
     *  @dtopt Options
     *  @name DataTable.defaults.orderCellsTop
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "orderCellsTop": true
     *      } );
     *    } );
     */
    "bSortCellsTop": false,
  
  
    /**
     * Enable or disable the addition of the classes `sorting\_1`, `sorting\_2` and
     * `sorting\_3` to the columns which are currently being sorted on. This is
     * presented as a feature switch as it can increase processing time (while
     * classes are removed and added) so for large data sets you might want to
     * turn this off.
     *  @type boolean
     *  @default true
     *
     *  @dtopt Features
     *  @name DataTable.defaults.orderClasses
     *
     *  @example
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "orderClasses": false
     *      } );
     *    } );
     */
    "bSortClasses": true,
  
  
    /**
     * Enable or disable state saving. When enabled HTML5 `localStorage` will be
     * used to save table display information such as pagination information,
     * display length, filtering and sorting. As such when the end user reloads
     * the page the display display will match what thy had previously set up.
     *
     * Due to the use of `localStorage` the default state saving is not supported
     * in IE6 or 7. If state saving is required in those browsers, use
     * `stateSaveCallback` to provide a storage solution such as cookies.
     *  @type boolean
     *  @default false
     *
     *  @dtopt Features
     *  @name DataTable.defaults.stateSave
     *
     *  @example
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "stateSave": true
     *      } );
     *    } );
     */
    "bStateSave": false,
  
  
    /**
     * This function is called when a TR element is created (and all TD child
     * elements have been inserted), or registered if using a DOM source, allowing
     * manipulation of the TR element (adding classes etc).
     *  @type function
     *  @param {node} row "TR" element for the current row
     *  @param {array} data Raw data array for this row
     *  @param {int} dataIndex The index of this row in the internal aoData array
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.createdRow
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "createdRow": function( row, data, dataIndex ) {
     *          // Bold the grade for all 'A' grade browsers
     *          if ( data[4] == "A" )
     *          {
     *            $('td:eq(4)', row).html( '<b>A</b>' );
     *          }
     *        }
     *      } );
     *    } );
     */
    "fnCreatedRow": null,
  
  
    /**
     * This function is called on every 'draw' event, and allows you to
     * dynamically modify any aspect you want about the created DOM.
     *  @type function
     *  @param {object} settings DataTables settings object
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.drawCallback
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "drawCallback": function( settings ) {
     *          alert( 'DataTables has redrawn the table' );
     *        }
     *      } );
     *    } );
     */
    "fnDrawCallback": null,
  
  
    /**
     * Identical to fnHeaderCallback() but for the table footer this function
     * allows you to modify the table footer on every 'draw' event.
     *  @type function
     *  @param {node} foot "TR" element for the footer
     *  @param {array} data Full table data (as derived from the original HTML)
     *  @param {int} start Index for the current display starting point in the
     *    display array
     *  @param {int} end Index for the current display ending point in the
     *    display array
     *  @param {array int} display Index array to translate the visual position
     *    to the full data array
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.footerCallback
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "footerCallback": function( tfoot, data, start, end, display ) {
     *          tfoot.getElementsByTagName('th')[0].innerHTML = "Starting index is "+start;
     *        }
     *      } );
     *    } )
     */
    "fnFooterCallback": null,
  
  
    /**
     * When rendering large numbers in the information element for the table
     * (i.e. "Showing 1 to 10 of 57 entries") DataTables will render large numbers
     * to have a comma separator for the 'thousands' units (e.g. 1 million is
     * rendered as "1,000,000") to help readability for the end user. This
     * function will override the default method DataTables uses.
     *  @type function
     *  @member
     *  @param {int} toFormat number to be formatted
     *  @returns {string} formatted string for DataTables to show the number
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.formatNumber
     *
     *  @example
     *    // Format a number using a single quote for the separator (note that
     *    // this can also be done with the language.thousands option)
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "formatNumber": function ( toFormat ) {
     *          return toFormat.toString().replace(
     *            /\B(?=(\d{3})+(?!\d))/g, "'"
     *          );
     *        };
     *      } );
     *    } );
     */
    "fnFormatNumber": function ( toFormat ) {
      return toFormat.toString().replace(
        /\B(?=(\d{3})+(?!\d))/g,
        this.oLanguage.sThousands
      );
    },
  
  
    /**
     * This function is called on every 'draw' event, and allows you to
     * dynamically modify the header row. This can be used to calculate and
     * display useful information about the table.
     *  @type function
     *  @param {node} head "TR" element for the header
     *  @param {array} data Full table data (as derived from the original HTML)
     *  @param {int} start Index for the current display starting point in the
     *    display array
     *  @param {int} end Index for the current display ending point in the
     *    display array
     *  @param {array int} display Index array to translate the visual position
     *    to the full data array
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.headerCallback
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "fheaderCallback": function( head, data, start, end, display ) {
     *          head.getElementsByTagName('th')[0].innerHTML = "Displaying "+(end-start)+" records";
     *        }
     *      } );
     *    } )
     */
    "fnHeaderCallback": null,
  
  
    /**
     * The information element can be used to convey information about the current
     * state of the table. Although the internationalisation options presented by
     * DataTables are quite capable of dealing with most customisations, there may
     * be times where you wish to customise the string further. This callback
     * allows you to do exactly that.
     *  @type function
     *  @param {object} oSettings DataTables settings object
     *  @param {int} start Starting position in data for the draw
     *  @param {int} end End position in data for the draw
     *  @param {int} max Total number of rows in the table (regardless of
     *    filtering)
     *  @param {int} total Total number of rows in the data set, after filtering
     *  @param {string} pre The string that DataTables has formatted using it's
     *    own rules
     *  @returns {string} The string to be displayed in the information element.
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.infoCallback
     *
     *  @example
     *    $('#example').dataTable( {
     *      "infoCallback": function( settings, start, end, max, total, pre ) {
     *        return start +" to "+ end;
     *      }
     *    } );
     */
    "fnInfoCallback": null,
  
  
    /**
     * Called when the table has been initialised. Normally DataTables will
     * initialise sequentially and there will be no need for this function,
     * however, this does not hold true when using external language information
     * since that is obtained using an async XHR call.
     *  @type function
     *  @param {object} settings DataTables settings object
     *  @param {object} json The JSON object request from the server - only
     *    present if client-side Ajax sourced data is used
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.initComplete
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "initComplete": function(settings, json) {
     *          alert( 'DataTables has finished its initialisation.' );
     *        }
     *      } );
     *    } )
     */
    "fnInitComplete": null,
  
  
    /**
     * Called at the very start of each table draw and can be used to cancel the
     * draw by returning false, any other return (including undefined) results in
     * the full draw occurring).
     *  @type function
     *  @param {object} settings DataTables settings object
     *  @returns {boolean} False will cancel the draw, anything else (including no
     *    return) will allow it to complete.
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.preDrawCallback
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "preDrawCallback": function( settings ) {
     *          if ( $('#test').val() == 1 ) {
     *            return false;
     *          }
     *        }
     *      } );
     *    } );
     */
    "fnPreDrawCallback": null,
  
  
    /**
     * This function allows you to 'post process' each row after it have been
     * generated for each table draw, but before it is rendered on screen. This
     * function might be used for setting the row class name etc.
     *  @type function
     *  @param {node} row "TR" element for the current row
     *  @param {array} data Raw data array for this row
     *  @param {int} displayIndex The display index for the current table draw
     *  @param {int} displayIndexFull The index of the data in the full list of
     *    rows (after filtering)
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.rowCallback
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "rowCallback": function( row, data, displayIndex, displayIndexFull ) {
     *          // Bold the grade for all 'A' grade browsers
     *          if ( data[4] == "A" ) {
     *            $('td:eq(4)', row).html( '<b>A</b>' );
     *          }
     *        }
     *      } );
     *    } );
     */
    "fnRowCallback": null,
  
  
    /**
     * __Deprecated__ The functionality provided by this parameter has now been
     * superseded by that provided through `ajax`, which should be used instead.
     *
     * This parameter allows you to override the default function which obtains
     * the data from the server so something more suitable for your application.
     * For example you could use POST data, or pull information from a Gears or
     * AIR database.
     *  @type function
     *  @member
     *  @param {string} source HTTP source to obtain the data from (`ajax`)
     *  @param {array} data A key/value pair object containing the data to send
     *    to the server
     *  @param {function} callback to be called on completion of the data get
     *    process that will draw the data on the page.
     *  @param {object} settings DataTables settings object
     *
     *  @dtopt Callbacks
     *  @dtopt Server-side
     *  @name DataTable.defaults.serverData
     *
     *  @deprecated 1.10. Please use `ajax` for this functionality now.
     */
    "fnServerData": null,
  
  
    /**
     * __Deprecated__ The functionality provided by this parameter has now been
     * superseded by that provided through `ajax`, which should be used instead.
     *
     *  It is often useful to send extra data to the server when making an Ajax
     * request - for example custom filtering information, and this callback
     * function makes it trivial to send extra information to the server. The
     * passed in parameter is the data set that has been constructed by
     * DataTables, and you can add to this or modify it as you require.
     *  @type function
     *  @param {array} data Data array (array of objects which are name/value
     *    pairs) that has been constructed by DataTables and will be sent to the
     *    server. In the case of Ajax sourced data with server-side processing
     *    this will be an empty array, for server-side processing there will be a
     *    significant number of parameters!
     *  @returns {undefined} Ensure that you modify the data array passed in,
     *    as this is passed by reference.
     *
     *  @dtopt Callbacks
     *  @dtopt Server-side
     *  @name DataTable.defaults.serverParams
     *
     *  @deprecated 1.10. Please use `ajax` for this functionality now.
     */
    "fnServerParams": null,
  
  
    /**
     * Load the table state. With this function you can define from where, and how, the
     * state of a table is loaded. By default DataTables will load from `localStorage`
     * but you might wish to use a server-side database or cookies.
     *  @type function
     *  @member
     *  @param {object} settings DataTables settings object
     *  @return {object} The DataTables state object to be loaded
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.stateLoadCallback
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "stateSave": true,
     *        "stateLoadCallback": function (settings) {
     *          var o;
     *
     *          // Send an Ajax request to the server to get the data. Note that
     *          // this is a synchronous request.
     *          $.ajax( {
     *            "url": "/state_load",
     *            "async": false,
     *            "dataType": "json",
     *            "success": function (json) {
     *              o = json;
     *            }
     *          } );
     *
     *          return o;
     *        }
     *      } );
     *    } );
     */
    "fnStateLoadCallback": function ( settings ) {
      try {
        return JSON.parse(
          (settings.iStateDuration === -1 ? sessionStorage : localStorage).getItem(
            'DataTables_'+settings.sInstance+'_'+location.pathname
          )
        );
      } catch (e) {}
    },
  
  
    /**
     * Callback which allows modification of the saved state prior to loading that state.
     * This callback is called when the table is loading state from the stored data, but
     * prior to the settings object being modified by the saved state. Note that for
     * plug-in authors, you should use the `stateLoadParams` event to load parameters for
     * a plug-in.
     *  @type function
     *  @param {object} settings DataTables settings object
     *  @param {object} data The state object that is to be loaded
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.stateLoadParams
     *
     *  @example
     *    // Remove a saved filter, so filtering is never loaded
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "stateSave": true,
     *        "stateLoadParams": function (settings, data) {
     *          data.oSearch.sSearch = "";
     *        }
     *      } );
     *    } );
     *
     *  @example
     *    // Disallow state loading by returning false
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "stateSave": true,
     *        "stateLoadParams": function (settings, data) {
     *          return false;
     *        }
     *      } );
     *    } );
     */
    "fnStateLoadParams": null,
  
  
    /**
     * Callback that is called when the state has been loaded from the state saving method
     * and the DataTables settings object has been modified as a result of the loaded state.
     *  @type function
     *  @param {object} settings DataTables settings object
     *  @param {object} data The state object that was loaded
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.stateLoaded
     *
     *  @example
     *    // Show an alert with the filtering value that was saved
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "stateSave": true,
     *        "stateLoaded": function (settings, data) {
     *          alert( 'Saved filter was: '+data.oSearch.sSearch );
     *        }
     *      } );
     *    } );
     */
    "fnStateLoaded": null,
  
  
    /**
     * Save the table state. This function allows you to define where and how the state
     * information for the table is stored By default DataTables will use `localStorage`
     * but you might wish to use a server-side database or cookies.
     *  @type function
     *  @member
     *  @param {object} settings DataTables settings object
     *  @param {object} data The state object to be saved
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.stateSaveCallback
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "stateSave": true,
     *        "stateSaveCallback": function (settings, data) {
     *          // Send an Ajax request to the server with the state object
     *          $.ajax( {
     *            "url": "/state_save",
     *            "data": data,
     *            "dataType": "json",
     *            "method": "POST"
     *            "success": function () {}
     *          } );
     *        }
     *      } );
     *    } );
     */
    "fnStateSaveCallback": function ( settings, data ) {
      try {
        (settings.iStateDuration === -1 ? sessionStorage : localStorage).setItem(
          'DataTables_'+settings.sInstance+'_'+location.pathname,
          JSON.stringify( data )
        );
      } catch (e) {}
    },
  
  
    /**
     * Callback which allows modification of the state to be saved. Called when the table
     * has changed state a new state save is required. This method allows modification of
     * the state saving object prior to actually doing the save, including addition or
     * other state properties or modification. Note that for plug-in authors, you should
     * use the `stateSaveParams` event to save parameters for a plug-in.
     *  @type function
     *  @param {object} settings DataTables settings object
     *  @param {object} data The state object to be saved
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.stateSaveParams
     *
     *  @example
     *    // Remove a saved filter, so filtering is never saved
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "stateSave": true,
     *        "stateSaveParams": function (settings, data) {
     *          data.oSearch.sSearch = "";
     *        }
     *      } );
     *    } );
     */
    "fnStateSaveParams": null,
  
  
    /**
     * Duration for which the saved state information is considered valid. After this period
     * has elapsed the state will be returned to the default.
     * Value is given in seconds.
     *  @type int
     *  @default 7200 <i>(2 hours)</i>
     *
     *  @dtopt Options
     *  @name DataTable.defaults.stateDuration
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "stateDuration": 60*60*24; // 1 day
     *      } );
     *    } )
     */
    "iStateDuration": 7200,
  
  
    /**
     * When enabled DataTables will not make a request to the server for the first
     * page draw - rather it will use the data already on the page (no sorting etc
     * will be applied to it), thus saving on an XHR at load time. `deferLoading`
     * is used to indicate that deferred loading is required, but it is also used
     * to tell DataTables how many records there are in the full table (allowing
     * the information element and pagination to be displayed correctly). In the case
     * where a filtering is applied to the table on initial load, this can be
     * indicated by giving the parameter as an array, where the first element is
     * the number of records available after filtering and the second element is the
     * number of records without filtering (allowing the table information element
     * to be shown correctly).
     *  @type int | array
     *  @default null
     *
     *  @dtopt Options
     *  @name DataTable.defaults.deferLoading
     *
     *  @example
     *    // 57 records available in the table, no filtering applied
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "serverSide": true,
     *        "ajax": "scripts/server_processing.php",
     *        "deferLoading": 57
     *      } );
     *    } );
     *
     *  @example
     *    // 57 records after filtering, 100 without filtering (an initial filter applied)
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "serverSide": true,
     *        "ajax": "scripts/server_processing.php",
     *        "deferLoading": [ 57, 100 ],
     *        "search": {
     *          "search": "my_filter"
     *        }
     *      } );
     *    } );
     */
    "iDeferLoading": null,
  
  
    /**
     * Number of rows to display on a single page when using pagination. If
     * feature enabled (`lengthChange`) then the end user will be able to override
     * this to a custom setting using a pop-up menu.
     *  @type int
     *  @default 10
     *
     *  @dtopt Options
     *  @name DataTable.defaults.pageLength
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "pageLength": 50
     *      } );
     *    } )
     */
    "iDisplayLength": 10,
  
  
    /**
     * Define the starting point for data display when using DataTables with
     * pagination. Note that this parameter is the number of records, rather than
     * the page number, so if you have 10 records per page and want to start on
     * the third page, it should be "20".
     *  @type int
     *  @default 0
     *
     *  @dtopt Options
     *  @name DataTable.defaults.displayStart
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "displayStart": 20
     *      } );
     *    } )
     */
    "iDisplayStart": 0,
  
  
    /**
     * By default DataTables allows keyboard navigation of the table (sorting, paging,
     * and filtering) by adding a `tabindex` attribute to the required elements. This
     * allows you to tab through the controls and press the enter key to activate them.
     * The tabindex is default 0, meaning that the tab follows the flow of the document.
     * You can overrule this using this parameter if you wish. Use a value of -1 to
     * disable built-in keyboard navigation.
     *  @type int
     *  @default 0
     *
     *  @dtopt Options
     *  @name DataTable.defaults.tabIndex
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "tabIndex": 1
     *      } );
     *    } );
     */
    "iTabIndex": 0,
  
  
    /**
     * Classes that DataTables assigns to the various components and features
     * that it adds to the HTML table. This allows classes to be configured
     * during initialisation in addition to through the static
     * {@link DataTable.ext.oStdClasses} object).
     *  @namespace
     *  @name DataTable.defaults.classes
     */
    "oClasses": {},
  
  
    /**
     * All strings that DataTables uses in the user interface that it creates
     * are defined in this object, allowing you to modified them individually or
     * completely replace them all as required.
     *  @namespace
     *  @name DataTable.defaults.language
     */
    "oLanguage": {
      /**
       * Strings that are used for WAI-ARIA labels and controls only (these are not
       * actually visible on the page, but will be read by screenreaders, and thus
       * must be internationalised as well).
       *  @namespace
       *  @name DataTable.defaults.language.aria
       */
      "oAria": {
        /**
         * ARIA label that is added to the table headers when the column may be
         * sorted ascending by activing the column (click or return when focused).
         * Note that the column header is prefixed to this string.
         *  @type string
         *  @default : activate to sort column ascending
         *
         *  @dtopt Language
         *  @name DataTable.defaults.language.aria.sortAscending
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "language": {
         *          "aria": {
         *            "sortAscending": " - click/return to sort ascending"
         *          }
         *        }
         *      } );
         *    } );
         */
        "sSortAscending": ": activate to sort column ascending",
  
        /**
         * ARIA label that is added to the table headers when the column may be
         * sorted descending by activing the column (click or return when focused).
         * Note that the column header is prefixed to this string.
         *  @type string
         *  @default : activate to sort column ascending
         *
         *  @dtopt Language
         *  @name DataTable.defaults.language.aria.sortDescending
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "language": {
         *          "aria": {
         *            "sortDescending": " - click/return to sort descending"
         *          }
         *        }
         *      } );
         *    } );
         */
        "sSortDescending": ": activate to sort column descending"
      },
  
      /**
       * Pagination string used by DataTables for the built-in pagination
       * control types.
       *  @namespace
       *  @name DataTable.defaults.language.paginate
       */
      "oPaginate": {
        /**
         * Text to use when using the 'full_numbers' type of pagination for the
         * button to take the user to the first page.
         *  @type string
         *  @default First
         *
         *  @dtopt Language
         *  @name DataTable.defaults.language.paginate.first
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "language": {
         *          "paginate": {
         *            "first": "First page"
         *          }
         *        }
         *      } );
         *    } );
         */
        "sFirst": "First",
  
  
        /**
         * Text to use when using the 'full_numbers' type of pagination for the
         * button to take the user to the last page.
         *  @type string
         *  @default Last
         *
         *  @dtopt Language
         *  @name DataTable.defaults.language.paginate.last
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "language": {
         *          "paginate": {
         *            "last": "Last page"
         *          }
         *        }
         *      } );
         *    } );
         */
        "sLast": "Last",
  
  
        /**
         * Text to use for the 'next' pagination button (to take the user to the
         * next page).
         *  @type string
         *  @default Next
         *
         *  @dtopt Language
         *  @name DataTable.defaults.language.paginate.next
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "language": {
         *          "paginate": {
         *            "next": "Next page"
         *          }
         *        }
         *      } );
         *    } );
         */
        "sNext": "Next",
  
  
        /**
         * Text to use for the 'previous' pagination button (to take the user to
         * the previous page).
         *  @type string
         *  @default Previous
         *
         *  @dtopt Language
         *  @name DataTable.defaults.language.paginate.previous
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "language": {
         *          "paginate": {
         *            "previous": "Previous page"
         *          }
         *        }
         *      } );
         *    } );
         */
        "sPrevious": "Previous"
      },
  
      /**
       * This string is shown in preference to `zeroRecords` when the table is
       * empty of data (regardless of filtering). Note that this is an optional
       * parameter - if it is not given, the value of `zeroRecords` will be used
       * instead (either the default or given value).
       *  @type string
       *  @default No data available in table
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.emptyTable
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "emptyTable": "No data available in table"
       *        }
       *      } );
       *    } );
       */
      "sEmptyTable": "No data available in table",
  
  
      /**
       * This string gives information to the end user about the information
       * that is current on display on the page. The following tokens can be
       * used in the string and will be dynamically replaced as the table
       * display updates. This tokens can be placed anywhere in the string, or
       * removed as needed by the language requires:
       *
       * * `\_START\_` - Display index of the first record on the current page
       * * `\_END\_` - Display index of the last record on the current page
       * * `\_TOTAL\_` - Number of records in the table after filtering
       * * `\_MAX\_` - Number of records in the table without filtering
       * * `\_PAGE\_` - Current page number
       * * `\_PAGES\_` - Total number of pages of data in the table
       *
       *  @type string
       *  @default Showing _START_ to _END_ of _TOTAL_ entries
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.info
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "info": "Showing page _PAGE_ of _PAGES_"
       *        }
       *      } );
       *    } );
       */
      "sInfo": "Showing _START_ to _END_ of _TOTAL_ entries",
  
  
      /**
       * Display information string for when the table is empty. Typically the
       * format of this string should match `info`.
       *  @type string
       *  @default Showing 0 to 0 of 0 entries
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.infoEmpty
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "infoEmpty": "No entries to show"
       *        }
       *      } );
       *    } );
       */
      "sInfoEmpty": "Showing 0 to 0 of 0 entries",
  
  
      /**
       * When a user filters the information in a table, this string is appended
       * to the information (`info`) to give an idea of how strong the filtering
       * is. The variable _MAX_ is dynamically updated.
       *  @type string
       *  @default (filtered from _MAX_ total entries)
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.infoFiltered
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "infoFiltered": " - filtering from _MAX_ records"
       *        }
       *      } );
       *    } );
       */
      "sInfoFiltered": "(filtered from _MAX_ total entries)",
  
  
      /**
       * If can be useful to append extra information to the info string at times,
       * and this variable does exactly that. This information will be appended to
       * the `info` (`infoEmpty` and `infoFiltered` in whatever combination they are
       * being used) at all times.
       *  @type string
       *  @default <i>Empty string</i>
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.infoPostFix
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "infoPostFix": "All records shown are derived from real information."
       *        }
       *      } );
       *    } );
       */
      "sInfoPostFix": "",
  
  
      /**
       * This decimal place operator is a little different from the other
       * language options since DataTables doesn't output floating point
       * numbers, so it won't ever use this for display of a number. Rather,
       * what this parameter does is modify the sort methods of the table so
       * that numbers which are in a format which has a character other than
       * a period (`.`) as a decimal place will be sorted numerically.
       *
       * Note that numbers with different decimal places cannot be shown in
       * the same table and still be sortable, the table must be consistent.
       * However, multiple different tables on the page can use different
       * decimal place characters.
       *  @type string
       *  @default 
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.decimal
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "decimal": ","
       *          "thousands": "."
       *        }
       *      } );
       *    } );
       */
      "sDecimal": "",
  
  
      /**
       * DataTables has a build in number formatter (`formatNumber`) which is
       * used to format large numbers that are used in the table information.
       * By default a comma is used, but this can be trivially changed to any
       * character you wish with this parameter.
       *  @type string
       *  @default ,
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.thousands
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "thousands": "'"
       *        }
       *      } );
       *    } );
       */
      "sThousands": ",",
  
  
      /**
       * Detail the action that will be taken when the drop down menu for the
       * pagination length option is changed. The '_MENU_' variable is replaced
       * with a default select list of 10, 25, 50 and 100, and can be replaced
       * with a custom select box if required.
       *  @type string
       *  @default Show _MENU_ entries
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.lengthMenu
       *
       *  @example
       *    // Language change only
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "lengthMenu": "Display _MENU_ records"
       *        }
       *      } );
       *    } );
       *
       *  @example
       *    // Language and options change
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "lengthMenu": 'Display <select>'+
       *            '<option value="10">10</option>'+
       *            '<option value="20">20</option>'+
       *            '<option value="30">30</option>'+
       *            '<option value="40">40</option>'+
       *            '<option value="50">50</option>'+
       *            '<option value="-1">All</option>'+
       *            '</select> records'
       *        }
       *      } );
       *    } );
       */
      "sLengthMenu": "Show _MENU_ entries",
  
  
      /**
       * When using Ajax sourced data and during the first draw when DataTables is
       * gathering the data, this message is shown in an empty row in the table to
       * indicate to the end user the the data is being loaded. Note that this
       * parameter is not used when loading data by server-side processing, just
       * Ajax sourced data with client-side processing.
       *  @type string
       *  @default Loading...
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.loadingRecords
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "loadingRecords": "Please wait - loading..."
       *        }
       *      } );
       *    } );
       */
      "sLoadingRecords": "<div class='loading_wrapper'><img src='/images/loading_32.gif' class='loading' /><span>Loading...</span></div>",
  
  
      /**
       * Text which is displayed when the table is processing a user action
       * (usually a sort command or similar).
       *  @type string
       *  @default Processing...
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.processing
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "processing": "DataTables is currently busy"
       *        }
       *      } );
       *    } );
       */
      "sProcessing": "Processing...",
  
  
      /**
       * Details the actions that will be taken when the user types into the
       * filtering input text box. The variable "_INPUT_", if used in the string,
       * is replaced with the HTML text box for the filtering input allowing
       * control over where it appears in the string. If "_INPUT_" is not given
       * then the input box is appended to the string automatically.
       *  @type string
       *  @default Search:
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.search
       *
       *  @example
       *    // Input text box will be appended at the end automatically
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "search": "Filter records:"
       *        }
       *      } );
       *    } );
       *
       *  @example
       *    // Specify where the filter should appear
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "search": "Apply filter _INPUT_ to table"
       *        }
       *      } );
       *    } );
       */
      "sSearch": "Search:",
  
  
      /**
       * Assign a `placeholder` attribute to the search `input` element
       *  @type string
       *  @default 
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.searchPlaceholder
       */
      "sSearchPlaceholder": "",
  
  
      /**
       * All of the language information can be stored in a file on the
       * server-side, which DataTables will look up if this parameter is passed.
       * It must store the URL of the language file, which is in a JSON format,
       * and the object has the same properties as the oLanguage object in the
       * initialiser object (i.e. the above parameters). Please refer to one of
       * the example language files to see how this works in action.
       *  @type string
       *  @default <i>Empty string - i.e. disabled</i>
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.url
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "url": "http://www.sprymedia.co.uk/dataTables/lang.txt"
       *        }
       *      } );
       *    } );
       */
      "sUrl": "",
  
  
      /**
       * Text shown inside the table records when the is no information to be
       * displayed after filtering. `emptyTable` is shown when there is simply no
       * information in the table at all (regardless of filtering).
       *  @type string
       *  @default No matching records found
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.zeroRecords
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "zeroRecords": "No records to display"
       *        }
       *      } );
       *    } );
       */
      "sZeroRecords": "<div class='selectProductLeft'><img src='' /><p>Select a folder from left panel</p></div>"
    },
  
  
    /**
     * This parameter allows you to have define the global filtering state at
     * initialisation time. As an object the `search` parameter must be
     * defined, but all other parameters are optional. When `regex` is true,
     * the search string will be treated as a regular expression, when false
     * (default) it will be treated as a straight string. When `smart`
     * DataTables will use it's smart filtering methods (to word match at
     * any point in the data), when false this will not be done.
     *  @namespace
     *  @extends DataTable.models.oSearch
     *
     *  @dtopt Options
     *  @name DataTable.defaults.search
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "search": {"search": "Initial search"}
     *      } );
     *    } )
     */
    "oSearch": $.extend( {}, DataTable.models.oSearch ),
  
  
    /**
     * __Deprecated__ The functionality provided by this parameter has now been
     * superseded by that provided through `ajax`, which should be used instead.
     *
     * By default DataTables will look for the property `data` (or `aaData` for
     * compatibility with DataTables 1.9-) when obtaining data from an Ajax
     * source or for server-side processing - this parameter allows that
     * property to be changed. You can use Javascript dotted object notation to
     * get a data source for multiple levels of nesting.
     *  @type string
     *  @default data
     *
     *  @dtopt Options
     *  @dtopt Server-side
     *  @name DataTable.defaults.ajaxDataProp
     *
     *  @deprecated 1.10. Please use `ajax` for this functionality now.
     */
    "sAjaxDataProp": "data",
  
  
    /**
     * __Deprecated__ The functionality provided by this parameter has now been
     * superseded by that provided through `ajax`, which should be used instead.
     *
     * You can instruct DataTables to load data from an external
     * source using this parameter (use aData if you want to pass data in you
     * already have). Simply provide a url a JSON object can be obtained from.
     *  @type string
     *  @default null
     *
     *  @dtopt Options
     *  @dtopt Server-side
     *  @name DataTable.defaults.ajaxSource
     *
     *  @deprecated 1.10. Please use `ajax` for this functionality now.
     */
    "sAjaxSource": null,
  
  
    /**
     * This initialisation variable allows you to specify exactly where in the
     * DOM you want DataTables to inject the various controls it adds to the page
     * (for example you might want the pagination controls at the top of the
     * table). DIV elements (with or without a custom class) can also be added to
     * aid styling. The follow syntax is used:
     *   <ul>
     *     <li>The following options are allowed:
     *       <ul>
     *         <li>'l' - Length changing</li>
     *         <li>'f' - Filtering input</li>
     *         <li>'t' - The table!</li>
     *         <li>'i' - Information</li>
     *         <li>'p' - Pagination</li>
     *         <li>'r' - pRocessing</li>
     *       </ul>
     *     </li>
     *     <li>The following constants are allowed:
     *       <ul>
     *         <li>'H' - jQueryUI theme "header" classes ('fg-toolbar ui-widget-header ui-corner-tl ui-corner-tr ui-helper-clearfix')</li>
     *         <li>'F' - jQueryUI theme "footer" classes ('fg-toolbar ui-widget-header ui-corner-bl ui-corner-br ui-helper-clearfix')</li>
     *       </ul>
     *     </li>
     *     <li>The following syntax is expected:
     *       <ul>
     *         <li>'&lt;' and '&gt;' - div elements</li>
     *         <li>'&lt;"class" and '&gt;' - div with a class</li>
     *         <li>'&lt;"#id" and '&gt;' - div with an ID</li>
     *       </ul>
     *     </li>
     *     <li>Examples:
     *       <ul>
     *         <li>'&lt;"wrapper"flipt&gt;'</li>
     *         <li>'&lt;lf&lt;t&gt;ip&gt;'</li>
     *       </ul>
     *     </li>
     *   </ul>
     *  @type string
     *  @default lfrtip <i>(when `jQueryUI` is false)</i> <b>or</b>
     *    <"H"lfr>t<"F"ip> <i>(when `jQueryUI` is true)</i>
     *
     *  @dtopt Options
     *  @name DataTable.defaults.dom
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "dom": '&lt;"top"i&gt;rt&lt;"bottom"flp&gt;&lt;"clear"&gt;'
     *      } );
     *    } );
     */
    "sDom": "lfrtip",
  
  
    /**
     * DataTables features four different built-in options for the buttons to
     * display for pagination control:
     *
     * * `simple` - 'Previous' and 'Next' buttons only
     * * 'simple_numbers` - 'Previous' and 'Next' buttons, plus page numbers
     * * `full` - 'First', 'Previous', 'Next' and 'Last' buttons
     * * `full_numbers` - 'First', 'Previous', 'Next' and 'Last' buttons, plus
     *   page numbers
     *  
     * Further methods can be added using {@link DataTable.ext.oPagination}.
     *  @type string
     *  @default simple_numbers
     *
     *  @dtopt Options
     *  @name DataTable.defaults.pagingType
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "pagingType": "full_numbers"
     *      } );
     *    } )
     */
    "sPaginationType": "simple_numbers",
  
  
    /**
     * Enable horizontal scrolling. When a table is too wide to fit into a
     * certain layout, or you have a large number of columns in the table, you
     * can enable x-scrolling to show the table in a viewport, which can be
     * scrolled. This property can be `true` which will allow the table to
     * scroll horizontally when needed, or any CSS unit, or a number (in which
     * case it will be treated as a pixel measurement). Setting as simply `true`
     * is recommended.
     *  @type boolean|string
     *  @default <i>blank string - i.e. disabled</i>
     *
     *  @dtopt Features
     *  @name DataTable.defaults.scrollX
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "scrollX": true,
     *        "scrollCollapse": true
     *      } );
     *    } );
     */
    "sScrollX": "",
  
  
    /**
     * This property can be used to force a DataTable to use more width than it
     * might otherwise do when x-scrolling is enabled. For example if you have a
     * table which requires to be well spaced, this parameter is useful for
     * "over-sizing" the table, and thus forcing scrolling. This property can by
     * any CSS unit, or a number (in which case it will be treated as a pixel
     * measurement).
     *  @type string
     *  @default <i>blank string - i.e. disabled</i>
     *
     *  @dtopt Options
     *  @name DataTable.defaults.scrollXInner
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "scrollX": "100%",
     *        "scrollXInner": "110%"
     *      } );
     *    } );
     */
    "sScrollXInner": "",
  
  
    /**
     * Enable vertical scrolling. Vertical scrolling will constrain the DataTable
     * to the given height, and enable scrolling for any data which overflows the
     * current viewport. This can be used as an alternative to paging to display
     * a lot of data in a small area (although paging and scrolling can both be
     * enabled at the same time). This property can be any CSS unit, or a number
     * (in which case it will be treated as a pixel measurement).
     *  @type string
     *  @default <i>blank string - i.e. disabled</i>
     *
     *  @dtopt Features
     *  @name DataTable.defaults.scrollY
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "scrollY": "200px",
     *        "paginate": false
     *      } );
     *    } );
     */
    "sScrollY": "",
  
  
    /**
     * __Deprecated__ The functionality provided by this parameter has now been
     * superseded by that provided through `ajax`, which should be used instead.
     *
     * Set the HTTP method that is used to make the Ajax call for server-side
     * processing or Ajax sourced data.
     *  @type string
     *  @default GET
     *
     *  @dtopt Options
     *  @dtopt Server-side
     *  @name DataTable.defaults.serverMethod
     *
     *  @deprecated 1.10. Please use `ajax` for this functionality now.
     */
    "sServerMethod": "GET",
  
  
    /**
     * DataTables makes use of renderers when displaying HTML elements for
     * a table. These renderers can be added or modified by plug-ins to
     * generate suitable mark-up for a site. For example the Bootstrap
     * integration plug-in for DataTables uses a paging button renderer to
     * display pagination buttons in the mark-up required by Bootstrap.
     *
     * For further information about the renderers available see
     * DataTable.ext.renderer
     *  @type string|object
     *  @default null
     *
     *  @name DataTable.defaults.renderer
     *
     */
    "renderer": null
  };
  
  _fnHungarianMap( DataTable.defaults );
  
  
  
  /*
   * Developer note - See note in model.defaults.js about the use of Hungarian
   * notation and camel case.
   */
  
  /**
   * Column options that can be given to DataTables at initialisation time.
   *  @namespace
   */
  DataTable.defaults.column = {
    /**
     * Define which column(s) an order will occur on for this column. This
     * allows a column's ordering to take multiple columns into account when
     * doing a sort or use the data from a different column. For example first
     * name / last name columns make sense to do a multi-column sort over the
     * two columns.
     *  @type array|int
     *  @default null <i>Takes the value of the column index automatically</i>
     *
     *  @name DataTable.defaults.column.orderData
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          { "orderData": [ 0, 1 ], "targets": [ 0 ] },
     *          { "orderData": [ 1, 0 ], "targets": [ 1 ] },
     *          { "orderData": 2, "targets": [ 2 ] }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          { "orderData": [ 0, 1 ] },
     *          { "orderData": [ 1, 0 ] },
     *          { "orderData": 2 },
     *          null,
     *          null
     *        ]
     *      } );
     *    } );
     */
    "aDataSort": null,
    "iDataSort": -1,
  
  
    /**
     * You can control the default ordering direction, and even alter the
     * behaviour of the sort handler (i.e. only allow ascending ordering etc)
     * using this parameter.
     *  @type array
     *  @default [ 'asc', 'desc' ]
     *
     *  @name DataTable.defaults.column.orderSequence
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          { "orderSequence": [ "asc" ], "targets": [ 1 ] },
     *          { "orderSequence": [ "desc", "asc", "asc" ], "targets": [ 2 ] },
     *          { "orderSequence": [ "desc" ], "targets": [ 3 ] }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          null,
     *          { "orderSequence": [ "asc" ] },
     *          { "orderSequence": [ "desc", "asc", "asc" ] },
     *          { "orderSequence": [ "desc" ] },
     *          null
     *        ]
     *      } );
     *    } );
     */
    "asSorting": [ 'asc', 'desc' ],
  
  
    /**
     * Enable or disable filtering on the data in this column.
     *  @type boolean
     *  @default true
     *
     *  @name DataTable.defaults.column.searchable
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          { "searchable": false, "targets": [ 0 ] }
     *        ] } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          { "searchable": false },
     *          null,
     *          null,
     *          null,
     *          null
     *        ] } );
     *    } );
     */
    "bSearchable": true,
  
  
    /**
     * Enable or disable ordering on this column.
     *  @type boolean
     *  @default true
     *
     *  @name DataTable.defaults.column.orderable
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          { "orderable": false, "targets": [ 0 ] }
     *        ] } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          { "orderable": false },
     *          null,
     *          null,
     *          null,
     *          null
     *        ] } );
     *    } );
     */
    "bSortable": true,
  
  
    /**
     * Enable or disable the display of this column.
     *  @type boolean
     *  @default true
     *
     *  @name DataTable.defaults.column.visible
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          { "visible": false, "targets": [ 0 ] }
     *        ] } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          { "visible": false },
     *          null,
     *          null,
     *          null,
     *          null
     *        ] } );
     *    } );
     */
    "bVisible": true,
  
  
    /**
     * Developer definable function that is called whenever a cell is created (Ajax source,
     * etc) or processed for input (DOM source). This can be used as a compliment to mRender
     * allowing you to modify the DOM element (add background colour for example) when the
     * element is available.
     *  @type function
     *  @param {element} td The TD node that has been created
     *  @param {*} cellData The Data for the cell
     *  @param {array|object} rowData The data for the whole row
     *  @param {int} row The row index for the aoData data store
     *  @param {int} col The column index for aoColumns
     *
     *  @name DataTable.defaults.column.createdCell
     *  @dtopt Columns
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [ {
     *          "targets": [3],
     *          "createdCell": function (td, cellData, rowData, row, col) {
     *            if ( cellData == "1.7" ) {
     *              $(td).css('color', 'blue')
     *            }
     *          }
     *        } ]
     *      });
     *    } );
     */
    "fnCreatedCell": null,
  
  
    /**
     * This parameter has been replaced by `data` in DataTables to ensure naming
     * consistency. `dataProp` can still be used, as there is backwards
     * compatibility in DataTables for this option, but it is strongly
     * recommended that you use `data` in preference to `dataProp`.
     *  @name DataTable.defaults.column.dataProp
     */
  
  
    /**
     * This property can be used to read data from any data source property,
     * including deeply nested objects / properties. `data` can be given in a
     * number of different ways which effect its behaviour:
     *
     * * `integer` - treated as an array index for the data source. This is the
     *   default that DataTables uses (incrementally increased for each column).
     * * `string` - read an object property from the data source. There are
     *   three 'special' options that can be used in the string to alter how
     *   DataTables reads the data from the source object:
     *    * `.` - Dotted Javascript notation. Just as you use a `.` in
     *      Javascript to read from nested objects, so to can the options
     *      specified in `data`. For example: `browser.version` or
     *      `browser.name`. If your object parameter name contains a period, use
     *      `\\` to escape it - i.e. `first\\.name`.
     *    * `[]` - Array notation. DataTables can automatically combine data
     *      from and array source, joining the data with the characters provided
     *      between the two brackets. For example: `name[, ]` would provide a
     *      comma-space separated list from the source array. If no characters
     *      are provided between the brackets, the original array source is
     *      returned.
     *    * `()` - Function notation. Adding `()` to the end of a parameter will
     *      execute a function of the name given. For example: `browser()` for a
     *      simple function on the data source, `browser.version()` for a
     *      function in a nested property or even `browser().version` to get an
     *      object property if the function called returns an object. Note that
     *      function notation is recommended for use in `render` rather than
     *      `data` as it is much simpler to use as a renderer.
     * * `null` - use the original data source for the row rather than plucking
     *   data directly from it. This action has effects on two other
     *   initialisation options:
     *    * `defaultContent` - When null is given as the `data` option and
     *      `defaultContent` is specified for the column, the value defined by
     *      `defaultContent` will be used for the cell.
     *    * `render` - When null is used for the `data` option and the `render`
     *      option is specified for the column, the whole data source for the
     *      row is used for the renderer.
     * * `function` - the function given will be executed whenever DataTables
     *   needs to set or get the data for a cell in the column. The function
     *   takes three parameters:
     *    * Parameters:
     *      * `{array|object}` The data source for the row
     *      * `{string}` The type call data requested - this will be 'set' when
     *        setting data or 'filter', 'display', 'type', 'sort' or undefined
     *        when gathering data. Note that when `undefined` is given for the
     *        type DataTables expects to get the raw data for the object back<
     *      * `{*}` Data to set when the second parameter is 'set'.
     *    * Return:
     *      * The return value from the function is not required when 'set' is
     *        the type of call, but otherwise the return is what will be used
     *        for the data requested.
     *
     * Note that `data` is a getter and setter option. If you just require
     * formatting of data for output, you will likely want to use `render` which
     * is simply a getter and thus simpler to use.
     *
     * Note that prior to DataTables 1.9.2 `data` was called `mDataProp`. The
     * name change reflects the flexibility of this property and is consistent
     * with the naming of mRender. If 'mDataProp' is given, then it will still
     * be used by DataTables, as it automatically maps the old name to the new
     * if required.
     *
     *  @type string|int|function|null
     *  @default null <i>Use automatically calculated column index</i>
     *
     *  @name DataTable.defaults.column.data
     *  @dtopt Columns
     *
     *  @example
     *    // Read table data from objects
     *    // JSON structure for each row:
     *    //   {
     *    //      "engine": {value},
     *    //      "browser": {value},
     *    //      "platform": {value},
     *    //      "version": {value},
     *    //      "grade": {value}
     *    //   }
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "ajaxSource": "sources/objects.txt",
     *        "columns": [
     *          { "data": "engine" },
     *          { "data": "browser" },
     *          { "data": "platform" },
     *          { "data": "version" },
     *          { "data": "grade" }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Read information from deeply nested objects
     *    // JSON structure for each row:
     *    //   {
     *    //      "engine": {value},
     *    //      "browser": {value},
     *    //      "platform": {
     *    //         "inner": {value}
     *    //      },
     *    //      "details": [
     *    //         {value}, {value}
     *    //      ]
     *    //   }
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "ajaxSource": "sources/deep.txt",
     *        "columns": [
     *          { "data": "engine" },
     *          { "data": "browser" },
     *          { "data": "platform.inner" },
     *          { "data": "platform.details.0" },
     *          { "data": "platform.details.1" }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using `data` as a function to provide different information for
     *    // sorting, filtering and display. In this case, currency (price)
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [ {
     *          "targets": [ 0 ],
     *          "data": function ( source, type, val ) {
     *            if (type === 'set') {
     *              source.price = val;
     *              // Store the computed dislay and filter values for efficiency
     *              source.price_display = val=="" ? "" : "$"+numberFormat(val);
     *              source.price_filter  = val=="" ? "" : "$"+numberFormat(val)+" "+val;
     *              return;
     *            }
     *            else if (type === 'display') {
     *              return source.price_display;
     *            }
     *            else if (type === 'filter') {
     *              return source.price_filter;
     *            }
     *            // 'sort', 'type' and undefined all just use the integer
     *            return source.price;
     *          }
     *        } ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using default content
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [ {
     *          "targets": [ 0 ],
     *          "data": null,
     *          "defaultContent": "Click to edit"
     *        } ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using array notation - outputting a list from an array
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [ {
     *          "targets": [ 0 ],
     *          "data": "name[, ]"
     *        } ]
     *      } );
     *    } );
     *
     */
    "mData": null,
  
  
    /**
     * This property is the rendering partner to `data` and it is suggested that
     * when you want to manipulate data for display (including filtering,
     * sorting etc) without altering the underlying data for the table, use this
     * property. `render` can be considered to be the the read only companion to
     * `data` which is read / write (then as such more complex). Like `data`
     * this option can be given in a number of different ways to effect its
     * behaviour:
     *
     * * `integer` - treated as an array index for the data source. This is the
     *   default that DataTables uses (incrementally increased for each column).
     * * `string` - read an object property from the data source. There are
     *   three 'special' options that can be used in the string to alter how
     *   DataTables reads the data from the source object:
     *    * `.` - Dotted Javascript notation. Just as you use a `.` in
     *      Javascript to read from nested objects, so to can the options
     *      specified in `data`. For example: `browser.version` or
     *      `browser.name`. If your object parameter name contains a period, use
     *      `\\` to escape it - i.e. `first\\.name`.
     *    * `[]` - Array notation. DataTables can automatically combine data
     *      from and array source, joining the data with the characters provided
     *      between the two brackets. For example: `name[, ]` would provide a
     *      comma-space separated list from the source array. If no characters
     *      are provided between the brackets, the original array source is
     *      returned.
     *    * `()` - Function notation. Adding `()` to the end of a parameter will
     *      execute a function of the name given. For example: `browser()` for a
     *      simple function on the data source, `browser.version()` for a
     *      function in a nested property or even `browser().version` to get an
     *      object property if the function called returns an object.
     * * `object` - use different data for the different data types requested by
     *   DataTables ('filter', 'display', 'type' or 'sort'). The property names
     *   of the object is the data type the property refers to and the value can
     *   defined using an integer, string or function using the same rules as
     *   `render` normally does. Note that an `_` option _must_ be specified.
     *   This is the default value to use if you haven't specified a value for
     *   the data type requested by DataTables.
     * * `function` - the function given will be executed whenever DataTables
     *   needs to set or get the data for a cell in the column. The function
     *   takes three parameters:
     *    * Parameters:
     *      * {array|object} The data source for the row (based on `data`)
     *      * {string} The type call data requested - this will be 'filter',
     *        'display', 'type' or 'sort'.
     *      * {array|object} The full data source for the row (not based on
     *        `data`)
     *    * Return:
     *      * The return value from the function is what will be used for the
     *        data requested.
     *
     *  @type string|int|function|object|null
     *  @default null Use the data source value.
     *
     *  @name DataTable.defaults.column.render
     *  @dtopt Columns
     *
     *  @example
     *    // Create a comma separated list from an array of objects
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "ajaxSource": "sources/deep.txt",
     *        "columns": [
     *          { "data": "engine" },
     *          { "data": "browser" },
     *          {
     *            "data": "platform",
     *            "render": "[, ].name"
     *          }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Execute a function to obtain data
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [ {
     *          "targets": [ 0 ],
     *          "data": null, // Use the full data source object for the renderer's source
     *          "render": "browserName()"
     *        } ]
     *      } );
     *    } );
     *
     *  @example
     *    // As an object, extracting different data for the different types
     *    // This would be used with a data source such as:
     *    //   { "phone": 5552368, "phone_filter": "5552368 555-2368", "phone_display": "555-2368" }
     *    // Here the `phone` integer is used for sorting and type detection, while `phone_filter`
     *    // (which has both forms) is used for filtering for if a user inputs either format, while
     *    // the formatted phone number is the one that is shown in the table.
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [ {
     *          "targets": [ 0 ],
     *          "data": null, // Use the full data source object for the renderer's source
     *          "render": {
     *            "_": "phone",
     *            "filter": "phone_filter",
     *            "display": "phone_display"
     *          }
     *        } ]
     *      } );
     *    } );
     *
     *  @example
     *    // Use as a function to create a link from the data source
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [ {
     *          "targets": [ 0 ],
     *          "data": "download_link",
     *          "render": function ( data, type, full ) {
     *            return '<a href="'+data+'">Download</a>';
     *          }
     *        } ]
     *      } );
     *    } );
     */
    "mRender": null,
  
  
    /**
     * Change the cell type created for the column - either TD cells or TH cells. This
     * can be useful as TH cells have semantic meaning in the table body, allowing them
     * to act as a header for a row (you may wish to add scope='row' to the TH elements).
     *  @type string
     *  @default td
     *
     *  @name DataTable.defaults.column.cellType
     *  @dtopt Columns
     *
     *  @example
     *    // Make the first column use TH cells
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [ {
     *          "targets": [ 0 ],
     *          "cellType": "th"
     *        } ]
     *      } );
     *    } );
     */
    "sCellType": "td",
  
  
    /**
     * Class to give to each cell in this column.
     *  @type string
     *  @default <i>Empty string</i>
     *
     *  @name DataTable.defaults.column.class
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          { "class": "my_class", "targets": [ 0 ] }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          { "class": "my_class" },
     *          null,
     *          null,
     *          null,
     *          null
     *        ]
     *      } );
     *    } );
     */
    "sClass": "",
  
    /**
     * When DataTables calculates the column widths to assign to each column,
     * it finds the longest string in each column and then constructs a
     * temporary table and reads the widths from that. The problem with this
     * is that "mmm" is much wider then "iiii", but the latter is a longer
     * string - thus the calculation can go wrong (doing it properly and putting
     * it into an DOM object and measuring that is horribly(!) slow). Thus as
     * a "work around" we provide this option. It will append its value to the
     * text that is found to be the longest string for the column - i.e. padding.
     * Generally you shouldn't need this!
     *  @type string
     *  @default <i>Empty string<i>
     *
     *  @name DataTable.defaults.column.contentPadding
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          null,
     *          null,
     *          null,
     *          {
     *            "contentPadding": "mmm"
     *          }
     *        ]
     *      } );
     *    } );
     */
    "sContentPadding": "",
  
  
    /**
     * Allows a default value to be given for a column's data, and will be used
     * whenever a null data source is encountered (this can be because `data`
     * is set to null, or because the data source itself is null).
     *  @type string
     *  @default null
     *
     *  @name DataTable.defaults.column.defaultContent
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          {
     *            "data": null,
     *            "defaultContent": "Edit",
     *            "targets": [ -1 ]
     *          }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          null,
     *          null,
     *          null,
     *          {
     *            "data": null,
     *            "defaultContent": "Edit"
     *          }
     *        ]
     *      } );
     *    } );
     */
    "sDefaultContent": null,
  
  
    /**
     * This parameter is only used in DataTables' server-side processing. It can
     * be exceptionally useful to know what columns are being displayed on the
     * client side, and to map these to database fields. When defined, the names
     * also allow DataTables to reorder information from the server if it comes
     * back in an unexpected order (i.e. if you switch your columns around on the
     * client-side, your server-side code does not also need updating).
     *  @type string
     *  @default <i>Empty string</i>
     *
     *  @name DataTable.defaults.column.name
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          { "name": "engine", "targets": [ 0 ] },
     *          { "name": "browser", "targets": [ 1 ] },
     *          { "name": "platform", "targets": [ 2 ] },
     *          { "name": "version", "targets": [ 3 ] },
     *          { "name": "grade", "targets": [ 4 ] }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          { "name": "engine" },
     *          { "name": "browser" },
     *          { "name": "platform" },
     *          { "name": "version" },
     *          { "name": "grade" }
     *        ]
     *      } );
     *    } );
     */
    "sName": "",
  
  
    /**
     * Defines a data source type for the ordering which can be used to read
     * real-time information from the table (updating the internally cached
     * version) prior to ordering. This allows ordering to occur on user
     * editable elements such as form inputs.
     *  @type string
     *  @default std
     *
     *  @name DataTable.defaults.column.orderDataType
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          { "orderDataType": "dom-text", "targets": [ 2, 3 ] },
     *          { "type": "numeric", "targets": [ 3 ] },
     *          { "orderDataType": "dom-select", "targets": [ 4 ] },
     *          { "orderDataType": "dom-checkbox", "targets": [ 5 ] }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          null,
     *          null,
     *          { "orderDataType": "dom-text" },
     *          { "orderDataType": "dom-text", "type": "numeric" },
     *          { "orderDataType": "dom-select" },
     *          { "orderDataType": "dom-checkbox" }
     *        ]
     *      } );
     *    } );
     */
    "sSortDataType": "std",
  
  
    /**
     * The title of this column.
     *  @type string
     *  @default null <i>Derived from the 'TH' value for this column in the
     *    original HTML table.</i>
     *
     *  @name DataTable.defaults.column.title
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          { "title": "My column title", "targets": [ 0 ] }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          { "title": "My column title" },
     *          null,
     *          null,
     *          null,
     *          null
     *        ]
     *      } );
     *    } );
     */
    "sTitle": null,
  
  
    /**
     * The type allows you to specify how the data for this column will be
     * ordered. Four types (string, numeric, date and html (which will strip
     * HTML tags before ordering)) are currently available. Note that only date
     * formats understood by Javascript's Date() object will be accepted as type
     * date. For example: "Mar 26, 2008 5:03 PM". May take the values: 'string',
     * 'numeric', 'date' or 'html' (by default). Further types can be adding
     * through plug-ins.
     *  @type string
     *  @default null <i>Auto-detected from raw data</i>
     *
     *  @name DataTable.defaults.column.type
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          { "type": "html", "targets": [ 0 ] }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          { "type": "html" },
     *          null,
     *          null,
     *          null,
     *          null
     *        ]
     *      } );
     *    } );
     */
    "sType": null,
  
  
    /**
     * Defining the width of the column, this parameter may take any CSS value
     * (3em, 20px etc). DataTables applies 'smart' widths to columns which have not
     * been given a specific width through this interface ensuring that the table
     * remains readable.
     *  @type string
     *  @default null <i>Automatic</i>
     *
     *  @name DataTable.defaults.column.width
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          { "width": "20%", "targets": [ 0 ] }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          { "width": "20%" },
     *          null,
     *          null,
     *          null,
     *          null
     *        ]
     *      } );
     *    } );
     */
    "sWidth": null
  };
  
  _fnHungarianMap( DataTable.defaults.column );
  
  
  
  /**
   * DataTables settings object - this holds all the information needed for a
   * given table, including configuration, data and current application of the
   * table options. DataTables does not have a single instance for each DataTable
   * with the settings attached to that instance, but rather instances of the
   * DataTable "class" are created on-the-fly as needed (typically by a
   * $().dataTable() call) and the settings object is then applied to that
   * instance.
   *
   * Note that this object is related to {@link DataTable.defaults} but this
   * one is the internal data store for DataTables's cache of columns. It should
   * NOT be manipulated outside of DataTables. Any configuration should be done
   * through the initialisation options.
   *  @namespace
   *  @todo Really should attach the settings object to individual instances so we
   *    don't need to create new instances on each $().dataTable() call (if the
   *    table already exists). It would also save passing oSettings around and
   *    into every single function. However, this is a very significant
   *    architecture change for DataTables and will almost certainly break
   *    backwards compatibility with older installations. This is something that
   *    will be done in 2.0.
   */
  DataTable.models.oSettings = {
    /**
     * Primary features of DataTables and their enablement state.
     *  @namespace
     */
    "oFeatures": {
  
      /**
       * Flag to say if DataTables should automatically try to calculate the
       * optimum table and columns widths (true) or not (false).
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bAutoWidth": null,
  
      /**
       * Delay the creation of TR and TD elements until they are actually
       * needed by a driven page draw. This can give a significant speed
       * increase for Ajax source and Javascript source data, but makes no
       * difference at all fro DOM and server-side processing tables.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bDeferRender": null,
  
      /**
       * Enable filtering on the table or not. Note that if this is disabled
       * then there is no filtering at all on the table, including fnFilter.
       * To just remove the filtering input use sDom and remove the 'f' option.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bFilter": null,
  
      /**
       * Table information element (the 'Showing x of y records' div) enable
       * flag.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bInfo": null,
  
      /**
       * Present a user control allowing the end user to change the page size
       * when pagination is enabled.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bLengthChange": null,
  
      /**
       * Pagination enabled or not. Note that if this is disabled then length
       * changing must also be disabled.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bPaginate": null,
  
      /**
       * Processing indicator enable flag whenever DataTables is enacting a
       * user request - typically an Ajax request for server-side processing.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bProcessing": null,
  
      /**
       * Server-side processing enabled flag - when enabled DataTables will
       * get all data from the server for every draw - there is no filtering,
       * sorting or paging done on the client-side.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bServerSide": null,
  
      /**
       * Sorting enablement flag.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bSort": null,
  
      /**
       * Multi-column sorting
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bSortMulti": null,
  
      /**
       * Apply a class to the columns which are being sorted to provide a
       * visual highlight or not. This can slow things down when enabled since
       * there is a lot of DOM interaction.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bSortClasses": null,
  
      /**
       * State saving enablement flag.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bStateSave": null
    },
  
  
    /**
     * Scrolling settings for a table.
     *  @namespace
     */
    "oScroll": {
      /**
       * When the table is shorter in height than sScrollY, collapse the
       * table container down to the height of the table (when true).
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bCollapse": null,
  
      /**
       * Width of the scrollbar for the web-browser's platform. Calculated
       * during table initialisation.
       *  @type int
       *  @default 0
       */
      "iBarWidth": 0,
  
      /**
       * Viewport width for horizontal scrolling. Horizontal scrolling is
       * disabled if an empty string.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type string
       */
      "sX": null,
  
      /**
       * Width to expand the table to when using x-scrolling. Typically you
       * should not need to use this.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type string
       *  @deprecated
       */
      "sXInner": null,
  
      /**
       * Viewport height for vertical scrolling. Vertical scrolling is disabled
       * if an empty string.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type string
       */
      "sY": null
    },
  
    /**
     * Language information for the table.
     *  @namespace
     *  @extends DataTable.defaults.oLanguage
     */
    "oLanguage": {
      /**
       * Information callback function. See
       * {@link DataTable.defaults.fnInfoCallback}
       *  @type function
       *  @default null
       */
      "fnInfoCallback": null
    },
  
    /**
     * Browser support parameters
     *  @namespace
     */
    "oBrowser": {
      /**
       * Indicate if the browser incorrectly calculates width:100% inside a
       * scrolling element (IE6/7)
       *  @type boolean
       *  @default false
       */
      "bScrollOversize": false,
  
      /**
       * Determine if the vertical scrollbar is on the right or left of the
       * scrolling container - needed for rtl language layout, although not
       * all browsers move the scrollbar (Safari).
       *  @type boolean
       *  @default false
       */
      "bScrollbarLeft": false
    },
  
  
    "ajax": null,
  
  
    /**
     * Array referencing the nodes which are used for the features. The
     * parameters of this object match what is allowed by sDom - i.e.
     *   <ul>
     *     <li>'l' - Length changing</li>
     *     <li>'f' - Filtering input</li>
     *     <li>'t' - The table!</li>
     *     <li>'i' - Information</li>
     *     <li>'p' - Pagination</li>
     *     <li>'r' - pRocessing</li>
     *   </ul>
     *  @type array
     *  @default []
     */
    "aanFeatures": [],
  
    /**
     * Store data information - see {@link DataTable.models.oRow} for detailed
     * information.
     *  @type array
     *  @default []
     */
    "aoData": [],
  
    /**
     * Array of indexes which are in the current display (after filtering etc)
     *  @type array
     *  @default []
     */
    "aiDisplay": [],
  
    /**
     * Array of indexes for display - no filtering
     *  @type array
     *  @default []
     */
    "aiDisplayMaster": [],
  
    /**
     * Store information about each column that is in use
     *  @type array
     *  @default []
     */
    "aoColumns": [],
  
    /**
     * Store information about the table's header
     *  @type array
     *  @default []
     */
    "aoHeader": [],
  
    /**
     * Store information about the table's footer
     *  @type array
     *  @default []
     */
    "aoFooter": [],
  
    /**
     * Store the applied global search information in case we want to force a
     * research or compare the old search to a new one.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @namespace
     *  @extends DataTable.models.oSearch
     */
    "oPreviousSearch": {},
  
    /**
     * Store the applied search for each column - see
     * {@link DataTable.models.oSearch} for the format that is used for the
     * filtering information for each column.
     *  @type array
     *  @default []
     */
    "aoPreSearchCols": [],
  
    /**
     * Sorting that is applied to the table. Note that the inner arrays are
     * used in the following manner:
     * <ul>
     *   <li>Index 0 - column number</li>
     *   <li>Index 1 - current sorting direction</li>
     * </ul>
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type array
     *  @todo These inner arrays should really be objects
     */
    "aaSorting": null,
  
    /**
     * Sorting that is always applied to the table (i.e. prefixed in front of
     * aaSorting).
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type array
     *  @default []
     */
    "aaSortingFixed": [],
  
    /**
     * Classes to use for the striping of a table.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type array
     *  @default []
     */
    "asStripeClasses": null,
  
    /**
     * If restoring a table - we should restore its striping classes as well
     *  @type array
     *  @default []
     */
    "asDestroyStripes": [],
  
    /**
     * If restoring a table - we should restore its width
     *  @type int
     *  @default 0
     */
    "sDestroyWidth": 0,
  
    /**
     * Callback functions array for every time a row is inserted (i.e. on a draw).
     *  @type array
     *  @default []
     */
    "aoRowCallback": [],
  
    /**
     * Callback functions for the header on each draw.
     *  @type array
     *  @default []
     */
    "aoHeaderCallback": [],
  
    /**
     * Callback function for the footer on each draw.
     *  @type array
     *  @default []
     */
    "aoFooterCallback": [],
  
    /**
     * Array of callback functions for draw callback functions
     *  @type array
     *  @default []
     */
    "aoDrawCallback": [],
  
    /**
     * Array of callback functions for row created function
     *  @type array
     *  @default []
     */
    "aoRowCreatedCallback": [],
  
    /**
     * Callback functions for just before the table is redrawn. A return of
     * false will be used to cancel the draw.
     *  @type array
     *  @default []
     */
    "aoPreDrawCallback": [],
  
    /**
     * Callback functions for when the table has been initialised.
     *  @type array
     *  @default []
     */
    "aoInitComplete": [],
  
  
    /**
     * Callbacks for modifying the settings to be stored for state saving, prior to
     * saving state.
     *  @type array
     *  @default []
     */
    "aoStateSaveParams": [],
  
    /**
     * Callbacks for modifying the settings that have been stored for state saving
     * prior to using the stored values to restore the state.
     *  @type array
     *  @default []
     */
    "aoStateLoadParams": [],
  
    /**
     * Callbacks for operating on the settings object once the saved state has been
     * loaded
     *  @type array
     *  @default []
     */
    "aoStateLoaded": [],
  
    /**
     * Cache the table ID for quick access
     *  @type string
     *  @default <i>Empty string</i>
     */
    "sTableId": "",
  
    /**
     * The TABLE node for the main table
     *  @type node
     *  @default null
     */
    "nTable": null,
  
    /**
     * Permanent ref to the thead element
     *  @type node
     *  @default null
     */
    "nTHead": null,
  
    /**
     * Permanent ref to the tfoot element - if it exists
     *  @type node
     *  @default null
     */
    "nTFoot": null,
  
    /**
     * Permanent ref to the tbody element
     *  @type node
     *  @default null
     */
    "nTBody": null,
  
    /**
     * Cache the wrapper node (contains all DataTables controlled elements)
     *  @type node
     *  @default null
     */
    "nTableWrapper": null,
  
    /**
     * Indicate if when using server-side processing the loading of data
     * should be deferred until the second draw.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type boolean
     *  @default false
     */
    "bDeferLoading": false,
  
    /**
     * Indicate if all required information has been read in
     *  @type boolean
     *  @default false
     */
    "bInitialised": false,
  
    /**
     * Information about open rows. Each object in the array has the parameters
     * 'nTr' and 'nParent'
     *  @type array
     *  @default []
     */
    "aoOpenRows": [],
  
    /**
     * Dictate the positioning of DataTables' control elements - see
     * {@link DataTable.model.oInit.sDom}.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type string
     *  @default null
     */
    "sDom": null,
  
    /**
     * Which type of pagination should be used.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type string
     *  @default two_button
     */
    "sPaginationType": "two_button",
  
    /**
     * The state duration (for `stateSave`) in seconds.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type int
     *  @default 0
     */
    "iStateDuration": 0,
  
    /**
     * Array of callback functions for state saving. Each array element is an
     * object with the following parameters:
     *   <ul>
     *     <li>function:fn - function to call. Takes two parameters, oSettings
     *       and the JSON string to save that has been thus far created. Returns
     *       a JSON string to be inserted into a json object
     *       (i.e. '"param": [ 0, 1, 2]')</li>
     *     <li>string:sName - name of callback</li>
     *   </ul>
     *  @type array
     *  @default []
     */
    "aoStateSave": [],
  
    /**
     * Array of callback functions for state loading. Each array element is an
     * object with the following parameters:
     *   <ul>
     *     <li>function:fn - function to call. Takes two parameters, oSettings
     *       and the object stored. May return false to cancel state loading</li>
     *     <li>string:sName - name of callback</li>
     *   </ul>
     *  @type array
     *  @default []
     */
    "aoStateLoad": [],
  
    /**
     * State that was saved. Useful for back reference
     *  @type object
     *  @default null
     */
    "oSavedState": null,
  
    /**
     * State that was loaded. Useful for back reference
     *  @type object
     *  @default null
     */
    "oLoadedState": null,
  
    /**
     * Source url for AJAX data for the table.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type string
     *  @default null
     */
    "sAjaxSource": null,
  
    /**
     * Property from a given object from which to read the table data from. This
     * can be an empty string (when not server-side processing), in which case
     * it is  assumed an an array is given directly.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type string
     */
    "sAjaxDataProp": null,
  
    /**
     * Note if draw should be blocked while getting data
     *  @type boolean
     *  @default true
     */
    "bAjaxDataGet": true,
  
    /**
     * The last jQuery XHR object that was used for server-side data gathering.
     * This can be used for working with the XHR information in one of the
     * callbacks
     *  @type object
     *  @default null
     */
    "jqXHR": null,
  
    /**
     * JSON returned from the server in the last Ajax request
     *  @type object
     *  @default undefined
     */
    "json": undefined,
  
    /**
     * Data submitted as part of the last Ajax request
     *  @type object
     *  @default undefined
     */
    "oAjaxData": undefined,
  
    /**
     * Function to get the server-side data.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type function
     */
    "fnServerData": null,
  
    /**
     * Functions which are called prior to sending an Ajax request so extra
     * parameters can easily be sent to the server
     *  @type array
     *  @default []
     */
    "aoServerParams": [],
  
    /**
     * Send the XHR HTTP method - GET or POST (could be PUT or DELETE if
     * required).
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type string
     */
    "sServerMethod": null,
  
    /**
     * Format numbers for display.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type function
     */
    "fnFormatNumber": null,
  
    /**
     * List of options that can be used for the user selectable length menu.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type array
     *  @default []
     */
    "aLengthMenu": null,
  
    /**
     * Counter for the draws that the table does. Also used as a tracker for
     * server-side processing
     *  @type int
     *  @default 0
     */
    "iDraw": 0,
  
    /**
     * Indicate if a redraw is being done - useful for Ajax
     *  @type boolean
     *  @default false
     */
    "bDrawing": false,
  
    /**
     * Draw index (iDraw) of the last error when parsing the returned data
     *  @type int
     *  @default -1
     */
    "iDrawError": -1,
  
    /**
     * Paging display length
     *  @type int
     *  @default 10
     */
    "_iDisplayLength": 10,
  
    /**
     * Paging start point - aiDisplay index
     *  @type int
     *  @default 0
     */
    "_iDisplayStart": 0,
  
    /**
     * Server-side processing - number of records in the result set
     * (i.e. before filtering), Use fnRecordsTotal rather than
     * this property to get the value of the number of records, regardless of
     * the server-side processing setting.
     *  @type int
     *  @default 0
     *  @private
     */
    "_iRecordsTotal": 0,
  
    /**
     * Server-side processing - number of records in the current display set
     * (i.e. after filtering). Use fnRecordsDisplay rather than
     * this property to get the value of the number of records, regardless of
     * the server-side processing setting.
     *  @type boolean
     *  @default 0
     *  @private
     */
    "_iRecordsDisplay": 0,
  
    /**
     * Flag to indicate if jQuery UI marking and classes should be used.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type boolean
     */
    "bJUI": null,
  
    /**
     * The classes to use for the table
     *  @type object
     *  @default {}
     */
    "oClasses": {},
  
    /**
     * Flag attached to the settings object so you can check in the draw
     * callback if filtering has been done in the draw. Deprecated in favour of
     * events.
     *  @type boolean
     *  @default false
     *  @deprecated
     */
    "bFiltered": false,
  
    /**
     * Flag attached to the settings object so you can check in the draw
     * callback if sorting has been done in the draw. Deprecated in favour of
     * events.
     *  @type boolean
     *  @default false
     *  @deprecated
     */
    "bSorted": false,
  
    /**
     * Indicate that if multiple rows are in the header and there is more than
     * one unique cell per column, if the top one (true) or bottom one (false)
     * should be used for sorting / title by DataTables.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type boolean
     */
    "bSortCellsTop": null,
  
    /**
     * Initialisation object that is used for the table
     *  @type object
     *  @default null
     */
    "oInit": null,
  
    /**
     * Destroy callback functions - for plug-ins to attach themselves to the
     * destroy so they can clean up markup and events.
     *  @type array
     *  @default []
     */
    "aoDestroyCallback": [],
  
  
    /**
     * Get the number of records in the current record set, before filtering
     *  @type function
     */
    "fnRecordsTotal": function ()
    {
      return _fnDataSource( this ) == 'ssp' ?
        this._iRecordsTotal * 1 :
        this.aiDisplayMaster.length;
    },
  
    /**
     * Get the number of records in the current record set, after filtering
     *  @type function
     */
    "fnRecordsDisplay": function ()
    {
      return _fnDataSource( this ) == 'ssp' ?
        this._iRecordsDisplay * 1 :
        this.aiDisplay.length;
    },
  
    /**
     * Get the display end point - aiDisplay index
     *  @type function
     */
    "fnDisplayEnd": function ()
    {
      var
        len      = this._iDisplayLength,
        start    = this._iDisplayStart,
        calc     = start + len,
        records  = this.aiDisplay.length,
        features = this.oFeatures,
        paginate = features.bPaginate;
  
      if ( features.bServerSide ) {
        return paginate === false || len === -1 ?
          start + records :
          Math.min( start+len, this._iRecordsDisplay );
      }
      else {
        return ! paginate || calc>records || len===-1 ?
          records :
          calc;
      }
    },
  
    /**
     * The DataTables object for this table
     *  @type object
     *  @default null
     */
    "oInstance": null,
  
    /**
     * Unique identifier for each instance of the DataTables object. If there
     * is an ID on the table node, then it takes that value, otherwise an
     * incrementing internal counter is used.
     *  @type string
     *  @default null
     */
    "sInstance": null,
  
    /**
     * tabindex attribute value that is added to DataTables control elements, allowing
     * keyboard navigation of the table and its controls.
     */
    "iTabIndex": 0,
  
    /**
     * DIV container for the footer scrolling table if scrolling
     */
    "nScrollHead": null,
  
    /**
     * DIV container for the footer scrolling table if scrolling
     */
    "nScrollFoot": null,
  
    /**
     * Last applied sort
     *  @type array
     *  @default []
     */
    "aLastSort": [],
  
    /**
     * Stored plug-in instances
     *  @type object
     *  @default {}
     */
    "oPlugins": {}
  };

  /**
   * Extension object for DataTables that is used to provide all extension
   * options.
   *
   * Note that the `DataTable.ext` object is available through
   * `jQuery.fn.dataTable.ext` where it may be accessed and manipulated. It is
   * also aliased to `jQuery.fn.dataTableExt` for historic reasons.
   *  @namespace
   *  @extends DataTable.models.ext
   */
  
  
  /**
   * DataTables extensions
   * 
   * This namespace acts as a collection area for plug-ins that can be used to
   * extend DataTables capabilities. Indeed many of the build in methods
   * use this method to provide their own capabilities (sorting methods for
   * example).
   *
   * Note that this namespace is aliased to `jQuery.fn.dataTableExt` for legacy
   * reasons
   *
   *  @namespace
   */
  DataTable.ext = _ext = {
    /**
     * Element class names
     *
     *  @type object
     *  @default {}
     */
    classes: {},
  
  
    /**
     * Error reporting.
     * 
     * How should DataTables report an error. Can take the value 'alert' or
     * 'throw'
     *
     *  @type string
     *  @default alert
     */
    errMode: "alert",
  
  
    /**
     * Feature plug-ins.
     * 
     * This is an array of objects which describe the feature plug-ins that are
     * available to DataTables. These feature plug-ins are then available for
     * use through the `dom` initialisation option.
     * 
     * Each feature plug-in is described by an object which must have the
     * following properties:
     * 
     * * `fnInit` - function that is used to initialise the plug-in,
     * * `cFeature` - a character so the feature can be enabled by the `dom`
     *   instillation option. This is case sensitive.
     *
     * The `fnInit` function has the following input parameters:
     *
     * 1. `{object}` DataTables settings object: see
     *    {@link DataTable.models.oSettings}
     *
     * And the following return is expected:
     * 
     * * {node|null} The element which contains your feature. Note that the
     *   return may also be void if your plug-in does not require to inject any
     *   DOM elements into DataTables control (`dom`) - for example this might
     *   be useful when developing a plug-in which allows table control via
     *   keyboard entry
     *
     *  @type array
     *
     *  @example
     *    $.fn.dataTable.ext.features.push( {
     *      "fnInit": function( oSettings ) {
     *        return new TableTools( { "oDTSettings": oSettings } );
     *      },
     *      "cFeature": "T"
     *    } );
     */
    feature: [],
  
  
    /**
     * Row searching.
     * 
     * This method of searching is complimentary to the default type based
     * searching, and a lot more comprehensive as it allows you complete control
     * over the searching logic. Each element in this array is a function
     * (parameters described below) that is called for every row in the table,
     * and your logic decides if it should be included in the searching data set
     * or not.
     *
     * Searching functions have the following input parameters:
     *
     * 1. `{object}` DataTables settings object: see
     *    {@link DataTable.models.oSettings}
     * 2. `{array|object}` Data for the row to be processed (same as the
     *    original format that was passed in as the data source, or an array
     *    from a DOM data source
     * 3. `{int}` Row index ({@link DataTable.models.oSettings.aoData}), which
     *    can be useful to retrieve the `TR` element if you need DOM interaction.
     *
     * And the following return is expected:
     *
     * * {boolean} Include the row in the searched result set (true) or not
     *   (false)
     *
     * Note that as with the main search ability in DataTables, technically this
     * is "filtering", since it is subtractive. However, for consistency in
     * naming we call it searching here.
     *
     *  @type array
     *  @default []
     *
     *  @example
     *    // The following example shows custom search being applied to the
     *    // fourth column (i.e. the data[3] index) based on two input values
     *    // from the end-user, matching the data in a certain range.
     *    $.fn.dataTable.ext.search.push(
     *      function( settings, data, dataIndex ) {
     *        var min = document.getElementById('min').value * 1;
     *        var max = document.getElementById('max').value * 1;
     *        var version = data[3] == "-" ? 0 : data[3]*1;
     *
     *        if ( min == "" && max == "" ) {
     *          return true;
     *        }
     *        else if ( min == "" && version < max ) {
     *          return true;
     *        }
     *        else if ( min < version && "" == max ) {
     *          return true;
     *        }
     *        else if ( min < version && version < max ) {
     *          return true;
     *        }
     *        return false;
     *      }
     *    );
     */
    search: [],
  
  
    /**
     * Internal functions, exposed for used in plug-ins.
     * 
     * Please note that you should not need to use the internal methods for
     * anything other than a plug-in (and even then, try to avoid if possible).
     * The internal function may change between releases.
     *
     *  @type object
     *  @default {}
     */
    internal: {},
  
  
    /**
     * Legacy configuration options. Enable and disable legacy options that
     * are available in DataTables.
     *
     *  @type object
     */
    legacy: {
      /**
       * Enable / disable DataTables 1.9 compatible server-side processing
       * requests
       *
       *  @type boolean
       *  @default null
       */
      ajax: null
    },
  
  
    /**
     * Pagination plug-in methods.
     * 
     * Each entry in this object is a function and defines which buttons should
     * be shown by the pagination rendering method that is used for the table:
     * {@link DataTable.ext.renderer.pageButton}. The renderer addresses how the
     * buttons are displayed in the document, while the functions here tell it
     * what buttons to display. This is done by returning an array of button
     * descriptions (what each button will do).
     *
     * Pagination types (the four built in options and any additional plug-in
     * options defined here) can be used through the `paginationType`
     * initialisation parameter.
     *
     * The functions defined take two parameters:
     *
     * 1. `{int} page` The current page index
     * 2. `{int} pages` The number of pages in the table
     *
     * Each function is expected to return an array where each element of the
     * array can be one of:
     *
     * * `first` - Jump to first page when activated
     * * `last` - Jump to last page when activated
     * * `previous` - Show previous page when activated
     * * `next` - Show next page when activated
     * * `{int}` - Show page of the index given
     * * `{array}` - A nested array containing the above elements to add a
     *   containing 'DIV' element (might be useful for styling).
     *
     * Note that DataTables v1.9- used this object slightly differently whereby
     * an object with two functions would be defined for each plug-in. That
     * ability is still supported by DataTables 1.10+ to provide backwards
     * compatibility, but this option of use is now decremented and no longer
     * documented in DataTables 1.10+.
     *
     *  @type object
     *  @default {}
     *
     *  @example
     *    // Show previous, next and current page buttons only
     *    $.fn.dataTableExt.oPagination.current = function ( page, pages ) {
     *      return [ 'previous', page, 'next' ];
     *    };
     */
    pager: {},
  
  
    renderer: {
      pageButton: {},
      header: {}
    },
  
  
    /**
     * Ordering plug-ins - custom data source
     * 
     * The extension options for ordering of data available here is complimentary
     * to the default type based ordering that DataTables typically uses. It
     * allows much greater control over the the data that is being used to
     * order a column, but is necessarily therefore more complex.
     * 
     * This type of ordering is useful if you want to do ordering based on data
     * live from the DOM (for example the contents of an 'input' element) rather
     * than just the static string that DataTables knows of.
     * 
     * The way these plug-ins work is that you create an array of the values you
     * wish to be ordering for the column in question and then return that
     * array. The data in the array much be in the index order of the rows in
     * the table (not the currently ordering order!). Which order data gathering
     * function is run here depends on the `dt-init columns.orderDataType`
     * parameter that is used for the column (if any).
     *
     * The functions defined take two parameters:
     *
     * 1. `{object}` DataTables settings object: see
     *    {@link DataTable.models.oSettings}
     * 2. `{int}` Target column index
     *
     * Each function is expected to return an array:
     *
     * * `{array}` Data for the column to be ordering upon
     *
     *  @type array
     *
     *  @example
     *    // Ordering using `input` node values
     *    $.fn.dataTable.ext.order['dom-text'] = function  ( settings, col )
     *    {
     *      return this.api().column( col, {order:'index'} ).nodes().map( function ( td, i ) {
     *        return $('input', td).val();
     *      } );
     *    }
     */
    order: {},
  
  
    /**
     * Type based plug-ins.
     *
     * Each column in DataTables has a type assigned to it, either by automatic
     * detection or by direct assignment using the `type` option for the column.
     * The type of a column will effect how it is ordering and search (plug-ins
     * can also make use of the column type if required).
     *
     * @namespace
     */
    type: {
      /**
       * Type detection functions.
       *
       * The functions defined in this object are used to automatically detect
       * a column's type, making initialisation of DataTables super easy, even
       * when complex data is in the table.
       *
       * The functions defined take two parameters:
       *
         *  1. `{*}` Data from the column cell to be analysed
         *  2. `{settings}` DataTables settings object. This can be used to
         *     perform context specific type detection - for example detection
         *     based on language settings such as using a comma for a decimal
         *     place. Generally speaking the options from the settings will not
         *     be required
       *
       * Each function is expected to return:
       *
       * * `{string|null}` Data type detected, or null if unknown (and thus
       *   pass it on to the other type detection functions.
       *
       *  @type array
       *
       *  @example
       *    // Currency type detection plug-in:
       *    $.fn.dataTable.ext.type.detect.push(
       *      function ( data, settings ) {
       *        // Check the numeric part
       *        if ( ! $.isNumeric( data.substring(1) ) ) {
       *          return null;
       *        }
       *
       *        // Check prefixed by currency
       *        if ( data.charAt(0) == '$' || data.charAt(0) == '&pound;' ) {
       *          return 'currency';
       *        }
       *        return null;
       *      }
       *    );
       */
      detect: [],
  
  
      /**
       * Type based search formatting.
       *
       * The type based searching functions can be used to pre-format the
       * data to be search on. For example, it can be used to strip HTML
       * tags or to de-format telephone numbers for numeric only searching.
       *
       * Note that is a search is not defined for a column of a given type,
       * no search formatting will be performed.
       * 
       * Pre-processing of searching data plug-ins - When you assign the sType
       * for a column (or have it automatically detected for you by DataTables
       * or a type detection plug-in), you will typically be using this for
       * custom sorting, but it can also be used to provide custom searching
       * by allowing you to pre-processing the data and returning the data in
       * the format that should be searched upon. This is done by adding
       * functions this object with a parameter name which matches the sType
       * for that target column. This is the corollary of <i>afnSortData</i>
       * for searching data.
       *
       * The functions defined take a single parameter:
       *
         *  1. `{*}` Data from the column cell to be prepared for searching
       *
       * Each function is expected to return:
       *
       * * `{string|null}` Formatted string that will be used for the searching.
       *
       *  @type object
       *  @default {}
       *
       *  @example
       *    $.fn.dataTable.ext.type.search['title-numeric'] = function ( d ) {
       *      return d.replace(/\n/g," ").replace( /<.*?>/g, "" );
       *    }
       */
      search: {},
  
  
      /**
       * Type based ordering.
       *
       * The column type tells DataTables what ordering to apply to the table
       * when a column is sorted upon. The order for each type that is defined,
       * is defined by the functions available in this object.
       *
       * Each ordering option can be described by three properties added to
       * this object:
       *
       * * `{type}-pre` - Pre-formatting function
       * * `{type}-asc` - Ascending order function
       * * `{type}-desc` - Descending order function
       *
       * All three can be used together, only `{type}-pre` or only
       * `{type}-asc` and `{type}-desc` together. It is generally recommended
       * that only `{type}-pre` is used, as this provides the optimal
       * implementation in terms of speed, although the others are provided
       * for compatibility with existing Javascript sort functions.
       *
       * `{type}-pre`: Functions defined take a single parameter:
       *
         *  1. `{*}` Data from the column cell to be prepared for ordering
       *
       * And return:
       *
       * * `{*}` Data to be sorted upon
       *
       * `{type}-asc` and `{type}-desc`: Functions are typical Javascript sort
       * functions, taking two parameters:
       *
         *  1. `{*}` Data to compare to the second parameter
         *  2. `{*}` Data to compare to the first parameter
       *
       * And returning:
       *
       * * `{*}` Ordering match: <0 if first parameter should be sorted lower
       *   than the second parameter, ===0 if the two parameters are equal and
       *   >0 if the first parameter should be sorted height than the second
       *   parameter.
       * 
       *  @type object
       *  @default {}
       *
       *  @example
       *    // Numeric ordering of formatted numbers with a pre-formatter
       *    $.extend( $.fn.dataTable.ext.type.order, {
       *      "string-pre": function(x) {
       *        a = (a === "-" || a === "") ? 0 : a.replace( /[^\d\-\.]/g, "" );
       *        return parseFloat( a );
       *      }
       *    } );
       *
       *  @example
       *    // Case-sensitive string ordering, with no pre-formatting method
       *    $.extend( $.fn.dataTable.ext.order, {
       *      "string-case-asc": function(x,y) {
       *        return ((x < y) ? -1 : ((x > y) ? 1 : 0));
       *      },
       *      "string-case-desc": function(x,y) {
       *        return ((x < y) ? 1 : ((x > y) ? -1 : 0));
       *      }
       *    } );
       */
      order: {}
    },
  
    /**
     * Unique DataTables instance counter
     *
     * @type int
     * @private
     */
    _unique: 0,
  
  
    //
    // Depreciated
    // The following properties are retained for backwards compatiblity only.
    // The should not be used in new projects and will be removed in a future
    // version
    //
  
    /**
     * Version check function.
     *  @type function
     *  @depreciated Since 1.10
     */
    fnVersionCheck: DataTable.fnVersionCheck,
  
  
    /**
     * Index for what 'this' index API functions should use
     *  @type int
     *  @deprecated Since v1.10
     */
    iApiIndex: 0,
  
  
    /**
     * jQuery UI class container
     *  @type object
     *  @deprecated Since v1.10
     */
    oJUIClasses: {},
  
  
    /**
     * Software version
     *  @type string
     *  @deprecated Since v1.10
     */
    sVersion: DataTable.version
  };
  
  
  //
  // Backwards compatibility. Alias to pre 1.10 Hungarian notation counter parts
  //
  $.extend( _ext, {
    afnFiltering: _ext.search,
    aTypes:       _ext.type.detect,
    ofnSearch:    _ext.type.search,
    oSort:        _ext.type.order,
    afnSortData:  _ext.order,
    aoFeatures:   _ext.feature,
    oApi:         _ext.internal,
    oStdClasses:  _ext.classes,
    oPagination:  _ext.pager
  } );
  
  
  $.extend( DataTable.ext.classes, {
    "sTable": "dataTable",
    "sNoFooter": "no-footer",
  
    /* Paging buttons */
    "sPageButton": "paginate_button",
    "sPageButtonActive": "current",
    "sPageButtonDisabled": "disabled",
  
    /* Striping classes */
    "sStripeOdd": "odd",
    "sStripeEven": "even",
  
    /* Empty row */
    "sRowEmpty": "dataTables_empty",
  
    /* Features */
    "sWrapper": "dataTables_wrapper",
    "sFilter": "dataTables_filter",
    "sInfo": "dataTables_info",
    "sPaging": "dataTables_paginate paging_", /* Note that the type is postfixed */
    "sLength": "dataTables_length",
    "sProcessing": "dataTables_processing",
  
    /* Sorting */
    "sSortAsc": "sorting_asc",
    "sSortDesc": "sorting_desc",
    "sSortable": "sorting", /* Sortable in both directions */
    "sSortableAsc": "sorting_asc_disabled",
    "sSortableDesc": "sorting_desc_disabled",
    "sSortableNone": "sorting_disabled",
    "sSortColumn": "sorting_", /* Note that an int is postfixed for the sorting order */
  
    /* Filtering */
    "sFilterInput": "",
  
    /* Page length */
    "sLengthSelect": "",
  
    /* Scrolling */
    "sScrollWrapper": "dataTables_scroll",
    "sScrollHead": "dataTables_scrollHead",
    "sScrollHeadInner": "dataTables_scrollHeadInner",
    "sScrollBody": "dataTables_scrollBody",
    "sScrollFoot": "dataTables_scrollFoot",
    "sScrollFootInner": "dataTables_scrollFootInner",
  
    /* Misc */
    "sHeaderTH": "",
    "sFooterTH": "",
  
    // Deprecated
    "sSortJUIAsc": "",
    "sSortJUIDesc": "",
    "sSortJUI": "",
    "sSortJUIAscAllowed": "",
    "sSortJUIDescAllowed": "",
    "sSortJUIWrapper": "",
    "sSortIcon": "",
    "sJUIHeader": "",
    "sJUIFooter": ""
  } );
  
  
  (function() {
  
  // Reused strings for better compression. Closure compiler appears to have a
  // weird edge case where it is trying to expand strings rather than use the
  // variable version. This results in about 200 bytes being added, for very
  // little preference benefit since it this run on script load only.
  var _empty = '';
  _empty = '';
  
  var _stateDefault = _empty + 'ui-state-default';
  var _sortIcon     = _empty + 'css_right ui-icon ui-icon-';
  var _headerFooter = _empty + 'fg-toolbar ui-toolbar ui-widget-header ui-helper-clearfix';
  
  $.extend( DataTable.ext.oJUIClasses, DataTable.ext.classes, {
    /* Full numbers paging buttons */
    "sPageButton":         "fg-button ui-button "+_stateDefault,
    "sPageButtonActive":   "ui-state-disabled",
    "sPageButtonDisabled": "ui-state-disabled",
  
    /* Features */
    "sPaging": "dataTables_paginate fg-buttonset ui-buttonset fg-buttonset-multi "+
      "ui-buttonset-multi paging_", /* Note that the type is postfixed */
  
    /* Sorting */
    "sSortAsc":            _stateDefault+" sorting_asc",
    "sSortDesc":           _stateDefault+" sorting_desc",
    "sSortable":           _stateDefault+" sorting",
    "sSortableAsc":        _stateDefault+" sorting_asc_disabled",
    "sSortableDesc":       _stateDefault+" sorting_desc_disabled",
    "sSortableNone":       _stateDefault+" sorting_disabled",
    "sSortJUIAsc":         _sortIcon+"triangle-1-n",
    "sSortJUIDesc":        _sortIcon+"triangle-1-s",
    "sSortJUI":            _sortIcon+"carat-2-n-s",
    "sSortJUIAscAllowed":  _sortIcon+"carat-1-n",
    "sSortJUIDescAllowed": _sortIcon+"carat-1-s",
    "sSortJUIWrapper":     "DataTables_sort_wrapper",
    "sSortIcon":           "DataTables_sort_icon",
  
    /* Scrolling */
    "sScrollHead": "dataTables_scrollHead "+_stateDefault,
    "sScrollFoot": "dataTables_scrollFoot "+_stateDefault,
  
    /* Misc */
    "sHeaderTH":  _stateDefault,
    "sFooterTH":  _stateDefault,
    "sJUIHeader": _headerFooter+" ui-corner-tl ui-corner-tr",
    "sJUIFooter": _headerFooter+" ui-corner-bl ui-corner-br"
  } );
  
  }());
  
  
  
  var extPagination = DataTable.ext.pager;
  
  function _numbers ( page, pages ) {
    var
      numbers = [],
      buttons = extPagination.numbers_length,
      half = Math.floor( buttons / 2 ),
      i = 1;
  
    if ( pages <= buttons ) {
      numbers = _range( 0, pages );
    }
    else if ( page <= half ) {
      numbers = _range( 0, buttons-2 );
      numbers.push( 'ellipsis' );
      numbers.push( pages-1 );
    }
    else if ( page >= pages - 1 - half ) {
      numbers = _range( pages-(buttons-2), pages );
      numbers.splice( 0, 0, 'ellipsis' ); // no unshift in ie6
      numbers.splice( 0, 0, 0 );
    }
    else {
      numbers = _range( page-1, page+2 );
      numbers.push( 'ellipsis' );
      numbers.push( pages-1 );
      numbers.splice( 0, 0, 'ellipsis' );
      numbers.splice( 0, 0, 0 );
    }
  
    numbers.DT_el = 'span';
    return numbers;
  }
  
  
  $.extend( extPagination, {
    simple: function ( page, pages ) {
      return [ 'previous', 'next' ];
    },
  
    full: function ( page, pages ) {
      return [  'first', 'previous', 'next', 'last' ];
    },
  
    simple_numbers: function ( page, pages ) {
      return [ 'previous', _numbers(page, pages), 'next' ];
    },
  
    full_numbers: function ( page, pages ) {
      return [ 'first', 'previous', _numbers(page, pages), 'next', 'last' ];
    },
  
    // For testing and plug-ins to use
    _numbers: _numbers,
    numbers_length: 7
  } );
  
  
  $.extend( true, DataTable.ext.renderer, {
    pageButton: {
      _: function ( settings, host, idx, buttons, page, pages ) {
        var classes = settings.oClasses;
        var lang = settings.oLanguage.oPaginate;
        var btnDisplay, btnClass, counter=0;
  
        var attach = function( container, buttons ) {
          var i, ien, node, button;
          var clickHandler = function ( e ) {
            _fnPageChange( settings, e.data.action, true );
          };
  
          for ( i=0, ien=buttons.length ; i<ien ; i++ ) {
            button = buttons[i];
  
            if ( $.isArray( button ) ) {
              var inner = $( '<'+(button.DT_el || 'div')+'/>' )
                .appendTo( container );
              attach( inner, button );
            }
            else {
              btnDisplay = '';
              btnClass = '';
  
              switch ( button ) {
                case 'ellipsis':
                  container.append('<span>&hellip;</span>');
                  break;
  
                case 'first':
                  btnDisplay = lang.sFirst;
                  btnClass = button + (page > 0 ?
                    '' : ' '+classes.sPageButtonDisabled);
                  break;
  
                case 'previous':
                  btnDisplay = lang.sPrevious;
                  btnClass = button + (page > 0 ?
                    '' : ' '+classes.sPageButtonDisabled);
                  break;
  
                case 'next':
                  btnDisplay = lang.sNext;
                  btnClass = button + (page < pages-1 ?
                    '' : ' '+classes.sPageButtonDisabled);
                  break;
  
                case 'last':
                  btnDisplay = lang.sLast;
                  btnClass = button + (page < pages-1 ?
                    '' : ' '+classes.sPageButtonDisabled);
                  break;
  
                default:
                  btnDisplay = button + 1;
                  btnClass = page === button ?
                    classes.sPageButtonActive : '';
                  break;
              }
  
              if ( btnDisplay ) {
                node = $('<a>', {
                    'class': classes.sPageButton+' '+btnClass,
                    'aria-controls': settings.sTableId,
                    'data-dt-idx': counter,
                    'tabindex': settings.iTabIndex,
                    'id': idx === 0 && typeof button === 'string' ?
                      settings.sTableId +'_'+ button :
                      null
                  } )
                  .html( btnDisplay )
                  .appendTo( container );
  
                _fnBindAction(
                  node, {action: button}, clickHandler
                );
  
                counter++;
              }
            }
          }
        };
  
        // IE9 throws an 'unknown error' if document.activeElement is used
        // inside an iframe or frame. Try / catch the error. Not good for
        // accessibility, but neither are frames.
        try {
          // Because this approach is destroying and recreating the paging
          // elements, focus is lost on the select button which is bad for
          // accessibility. So we want to restore focus once the draw has
          // completed
          var activeEl = $(document.activeElement).data('dt-idx');
  
          attach( $(host).empty(), buttons );
  
          if ( activeEl !== null ) {
            $(host).find( '[data-dt-idx='+activeEl+']' ).focus();
          }
        }
        catch (e) {}
      }
    }
  } );
  
  
  
  var __numericReplace = function ( d, decimalPlace, re1, re2 ) {
    if ( !d || d === '-' ) {
      return -Infinity;
    }
  
    // If a decimal place other than `.` is used, it needs to be given to the
    // function so we can detect it and replace with a `.` which is the only
    // decimal place Javascript recognises - it is not locale aware.
    if ( decimalPlace ) {
      d = _numToDecimal( d, decimalPlace );
    }
  
    if ( d.replace ) {
      if ( re1 ) {
        d = d.replace( re1, '' );
      }
  
      if ( re2 ) {
        d = d.replace( re2, '' );
      }
    }
  
    return d * 1;
  };
  
  
  // Add the numeric 'deformatting' functions for sorting. This is done in a
  // function to provide an easy ability for the language options to add
  // additional methods if a non-period decimal place is used.
  function _addNumericSort ( decimalPlace ) {
    $.each(
      {
        // Plain numbers
        "num": function ( d ) {
          return __numericReplace( d, decimalPlace );
        },
  
        // Formatted numbers
        "num-fmt": function ( d ) {
          return __numericReplace( d, decimalPlace, _re_formatted_numeric );
        },
  
        // HTML numeric
        "html-num": function ( d ) {
          return __numericReplace( d, decimalPlace, _re_html );
        },
  
        // HTML numeric, formatted
        "html-num-fmt": function ( d ) {
          return __numericReplace( d, decimalPlace, _re_html, _re_formatted_numeric );
        }
      },
      function ( key, fn ) {
        _ext.type.order[ key+decimalPlace+'-pre' ] = fn;
      }
    );
  }
  
  
  // Default sort methods
  $.extend( _ext.type.order, {
    // Dates
    "date-pre": function ( d ) {
      return Date.parse( d ) || 0;
    },
  
    // html
    "html-pre": function ( a ) {
      return _empty(a) ?
        '' :
        a.replace ?
          a.replace( /<.*?>/g, "" ).toLowerCase() :
          a+'';
    },
  
    // string
    "string-pre": function ( a ) {
      // This is a little complex, but faster than always calling toString,
      // http://jsperf.com/tostring-v-check
      return _empty(a) ?
        '' :
        typeof a === 'string' ?
          a.toLowerCase() :
          ! a.toString ?
            '' :
            a.toString();
    },
  
    // string-asc and -desc are retained only for compatibility with the old
    // sort methods
    "string-asc": function ( x, y ) {
      return ((x < y) ? -1 : ((x > y) ? 1 : 0));
    },
  
    "string-desc": function ( x, y ) {
      return ((x < y) ? 1 : ((x > y) ? -1 : 0));
    }
  } );
  
  
  // Numeric sorting types - order doesn't matter here
  _addNumericSort( '' );
  
  
  // Built in type detection. See model.ext.aTypes for information about
  // what is required from this methods.
  $.extend( DataTable.ext.type.detect, [
    // Plain numbers - first since V8 detects some plain numbers as dates
    // e.g. Date.parse('55') (but not all, e.g. Date.parse('22')...).
    function ( d, settings )
    {
      var decimal = settings.oLanguage.sDecimal;
      return _isNumber( d, decimal ) ? 'num'+decimal : null;
    },
  
    // Dates (only those recognised by the browser's Date.parse)
    function ( d, settings )
    {
      // V8 will remove any unknown characters at the start and end of the
      // expression, leading to false matches such as `$245.12` or `10%` being
      // a valid date. See forum thread 18941 for detail.
      if ( d && ( ! _re_date_start.test(d) || ! _re_date_end.test(d) ) ) {
        return null;
      }
      var parsed = Date.parse(d);
      return (parsed !== null && !isNaN(parsed)) || _empty(d) ? 'date' : null;
    },
  
    // Formatted numbers
    function ( d, settings )
    {
      var decimal = settings.oLanguage.sDecimal;
      return _isNumber( d, decimal, true ) ? 'num-fmt'+decimal : null;
    },
  
    // HTML numeric
    function ( d, settings )
    {
      var decimal = settings.oLanguage.sDecimal;
      return _htmlNumeric( d, decimal ) ? 'html-num'+decimal : null;
    },
  
    // HTML numeric, formatted
    function ( d, settings )
    {
      var decimal = settings.oLanguage.sDecimal;
      return _htmlNumeric( d, decimal, true ) ? 'html-num-fmt'+decimal : null;
    },
  
    // HTML (this is strict checking - there must be html)
    function ( d, settings )
    {
      return _empty( d ) || (typeof d === 'string' && d.indexOf('<') !== -1) ?
        'html' : null;
    }
  ] );
  
  
  
  // Filter formatting functions. See model.ext.ofnSearch for information about
  // what is required from these methods.
  
  
  $.extend( DataTable.ext.type.search, {
    html: function ( data ) {
      return _empty(data) ?
        data :
        typeof data === 'string' ?
          data
            .replace( _re_new_lines, " " )
            .replace( _re_html, "" ) :
          '';
    },
  
    string: function ( data ) {
      return _empty(data) ?
        data :
        typeof data === 'string' ?
          data.replace( _re_new_lines, " " ) :
          data;
    }
  } );
  
  
  
  $.extend( true, DataTable.ext.renderer, {
    header: {
      _: function ( settings, cell, column, classes ) {
        // No additional mark-up required
        // Attach a sort listener to update on sort - note that using the
        // `DT` namespace will allow the event to be removed automatically
        // on destroy, while the `dt` namespaced event is the one we are
        // listening for
        $(settings.nTable).on( 'order.dt.DT', function ( e, ctx, sorting, columns ) {
          if ( settings !== ctx ) { // need to check this this is the host
            return;               // table, not a nested one
          }
  
          var colIdx = column.idx;
  
          cell
            .removeClass(
              column.sSortingClass +' '+
              classes.sSortAsc +' '+
              classes.sSortDesc
            )
            .addClass( columns[ colIdx ] == 'asc' ?
              classes.sSortAsc : columns[ colIdx ] == 'desc' ?
                classes.sSortDesc :
                column.sSortingClass
            );
        } );
      },
  
      jqueryui: function ( settings, cell, column, classes ) {
        var colIdx = column.idx;
  
        $('<div/>')
          .addClass( classes.sSortJUIWrapper )
          .append( cell.contents() )
          .append( $('<span/>')
            .addClass( classes.sSortIcon+' '+column.sSortingClassJUI )
          )
          .appendTo( cell );
  
        // Attach a sort listener to update on sort
        $(settings.nTable).on( 'order.dt.DT', function ( e, ctx, sorting, columns ) {
          if ( settings !== ctx ) {
            return;
          }
  
          cell
            .removeClass( classes.sSortAsc +" "+classes.sSortDesc )
            .addClass( columns[ colIdx ] == 'asc' ?
              classes.sSortAsc : columns[ colIdx ] == 'desc' ?
                classes.sSortDesc :
                column.sSortingClass
            );
  
          cell
            .find( 'span.'+classes.sSortIcon )
            .removeClass(
              classes.sSortJUIAsc +" "+
              classes.sSortJUIDesc +" "+
              classes.sSortJUI +" "+
              classes.sSortJUIAscAllowed +" "+
              classes.sSortJUIDescAllowed
            )
            .addClass( columns[ colIdx ] == 'asc' ?
              classes.sSortJUIAsc : columns[ colIdx ] == 'desc' ?
                classes.sSortJUIDesc :
                column.sSortingClassJUI
            );
        } );
      }
    }
  } );
  
  /*
   * Public helper functions. These aren't used internally by DataTables, or
   * called by any of the options passed into DataTables, but they can be used
   * externally by developers working with DataTables. They are helper functions
   * to make working with DataTables a little bit easier.
   */
  
  /**
   * Helpers for `columns.render`.
   *
   * The options defined here can be used with the `columns.render` initialisation
   * option to provide a display renderer. The following functions are defined:
   *
   * * `number` - Will format numeric data (defined by `columns.data`) for
   *   display, retaining the original unformatted data for sorting and filtering.
   *   It takes 4 parameters:
   *   * `string` - Thousands grouping separator
   *   * `string` - Decimal point indicator
   *   * `integer` - Number of decimal points to show
   *   * `string` (optional) - Prefix.
   *
   * @example
   *   // Column definition using the number renderer
   *   {
   *     data: "salary",
   *     render: $.fn.dataTable.render.number( '\'', '.', 0, '$' )
   *   }
   *
   * @namespace
   */
  DataTable.render = {
    number: function ( thousands, decimal, precision, prefix ) {
      return {
        display: function ( d ) {
          var negative = d < 0 ? '-' : '';
          d = Math.abs( parseFloat( d ) );
  
          var intPart = parseInt( d, 10 );
          var floatPart = precision ?
            decimal+(d - intPart).toFixed( precision ).substring( 2 ):
            '';
  
          return negative + (prefix||'') +
            intPart.toString().replace(
              /\B(?=(\d{3})+(?!\d))/g, thousands
            ) +
            floatPart;
        }
      };
    }
  };
  
  
  /*
   * This is really a good bit rubbish this method of exposing the internal methods
   * publicly... - To be fixed in 2.0 using methods on the prototype
   */
  
  
  /**
   * Create a wrapper function for exporting an internal functions to an external API.
   *  @param {string} fn API function name
   *  @returns {function} wrapped function
   *  @memberof DataTable#internal
   */
  function _fnExternApiFunc (fn)
  {
    return function() {
      var args = [_fnSettingsFromNode( this[DataTable.ext.iApiIndex] )].concat(
        Array.prototype.slice.call(arguments)
      );
      return DataTable.ext.internal[fn].apply( this, args );
    };
  }
  
  
  /**
   * Reference to internal functions for use by plug-in developers. Note that
   * these methods are references to internal functions and are considered to be
   * private. If you use these methods, be aware that they are liable to change
   * between versions.
   *  @namespace
   */
  $.extend( DataTable.ext.internal, {
    _fnExternApiFunc: _fnExternApiFunc,
    _fnBuildAjax: _fnBuildAjax,
    _fnAjaxUpdate: _fnAjaxUpdate,
    _fnAjaxParameters: _fnAjaxParameters,
    _fnAjaxUpdateDraw: _fnAjaxUpdateDraw,
    _fnAjaxDataSrc: _fnAjaxDataSrc,
    _fnAddColumn: _fnAddColumn,
    _fnColumnOptions: _fnColumnOptions,
    _fnAdjustColumnSizing: _fnAdjustColumnSizing,
    _fnVisibleToColumnIndex: _fnVisibleToColumnIndex,
    _fnColumnIndexToVisible: _fnColumnIndexToVisible,
    _fnVisbleColumns: _fnVisbleColumns,
    _fnGetColumns: _fnGetColumns,
    _fnColumnTypes: _fnColumnTypes,
    _fnApplyColumnDefs: _fnApplyColumnDefs,
    _fnHungarianMap: _fnHungarianMap,
    _fnCamelToHungarian: _fnCamelToHungarian,
    _fnLanguageCompat: _fnLanguageCompat,
    _fnBrowserDetect: _fnBrowserDetect,
    _fnAddData: _fnAddData,
    _fnAddTr: _fnAddTr,
    _fnNodeToDataIndex: _fnNodeToDataIndex,
    _fnNodeToColumnIndex: _fnNodeToColumnIndex,
    _fnGetCellData: _fnGetCellData,
    _fnSetCellData: _fnSetCellData,
    _fnSplitObjNotation: _fnSplitObjNotation,
    _fnGetObjectDataFn: _fnGetObjectDataFn,
    _fnSetObjectDataFn: _fnSetObjectDataFn,
    _fnGetDataMaster: _fnGetDataMaster,
    _fnClearTable: _fnClearTable,
    _fnDeleteIndex: _fnDeleteIndex,
    _fnInvalidateRow: _fnInvalidateRow,
    _fnGetRowElements: _fnGetRowElements,
    _fnCreateTr: _fnCreateTr,
    _fnBuildHead: _fnBuildHead,
    _fnDrawHead: _fnDrawHead,
    _fnDraw: _fnDraw,
    _fnReDraw: _fnReDraw,
    _fnAddOptionsHtml: _fnAddOptionsHtml,
    _fnDetectHeader: _fnDetectHeader,
    _fnGetUniqueThs: _fnGetUniqueThs,
    _fnFeatureHtmlFilter: _fnFeatureHtmlFilter,
    _fnFilterComplete: _fnFilterComplete,
    _fnFilterCustom: _fnFilterCustom,
    _fnFilterColumn: _fnFilterColumn,
    _fnFilter: _fnFilter,
    _fnFilterCreateSearch: _fnFilterCreateSearch,
    _fnEscapeRegex: _fnEscapeRegex,
    _fnFilterData: _fnFilterData,
    _fnFeatureHtmlInfo: _fnFeatureHtmlInfo,
    _fnUpdateInfo: _fnUpdateInfo,
    _fnInfoMacros: _fnInfoMacros,
    _fnInitialise: _fnInitialise,
    _fnInitComplete: _fnInitComplete,
    _fnLengthChange: _fnLengthChange,
    _fnFeatureHtmlLength: _fnFeatureHtmlLength,
    _fnFeatureHtmlPaginate: _fnFeatureHtmlPaginate,
    _fnPageChange: _fnPageChange,
    _fnFeatureHtmlProcessing: _fnFeatureHtmlProcessing,
    _fnProcessingDisplay: _fnProcessingDisplay,
    _fnFeatureHtmlTable: _fnFeatureHtmlTable,
    _fnScrollDraw: _fnScrollDraw,
    _fnApplyToChildren: _fnApplyToChildren,
    _fnCalculateColumnWidths: _fnCalculateColumnWidths,
    _fnThrottle: _fnThrottle,
    _fnConvertToWidth: _fnConvertToWidth,
    _fnScrollingWidthAdjust: _fnScrollingWidthAdjust,
    _fnGetWidestNode: _fnGetWidestNode,
    _fnGetMaxLenString: _fnGetMaxLenString,
    _fnStringToCss: _fnStringToCss,
    _fnScrollBarWidth: _fnScrollBarWidth,
    _fnSortFlatten: _fnSortFlatten,
    _fnSort: _fnSort,
    _fnSortAria: _fnSortAria,
    _fnSortListener: _fnSortListener,
    _fnSortAttachListener: _fnSortAttachListener,
    _fnSortingClasses: _fnSortingClasses,
    _fnSortData: _fnSortData,
    _fnSaveState: _fnSaveState,
    _fnLoadState: _fnLoadState,
    _fnSettingsFromNode: _fnSettingsFromNode,
    _fnLog: _fnLog,
    _fnMap: _fnMap,
    _fnBindAction: _fnBindAction,
    _fnCallbackReg: _fnCallbackReg,
    _fnCallbackFire: _fnCallbackFire,
    _fnLengthOverflow: _fnLengthOverflow,
    _fnRenderer: _fnRenderer,
    _fnDataSource: _fnDataSource,
    _fnRowAttributes: _fnRowAttributes,
    _fnCalculateEnd: function () {} // Used by a lot of plug-ins, but redundant
                                    // in 1.10, so this dead-end function is
                                    // added to prevent errors
  } );
  

  // jQuery access
  $.fn.dataTable = DataTable;

  // Legacy aliases
  $.fn.dataTableSettings = DataTable.settings;
  $.fn.dataTableExt = DataTable.ext;

  // With a capital `D` we return a DataTables API instance rather than a
  // jQuery object
  $.fn.DataTable = function ( opts ) {
    return $(this).dataTable( opts ).api();
  };

  // All properties that are available to $.fn.dataTable should also be
  // available on $.fn.DataTable
  $.each( DataTable, function ( prop, val ) {
    $.fn.DataTable[ prop ] = val;
  } );


  // Information about events fired by DataTables - for documentation.
  /**
   * Draw event, fired whenever the table is redrawn on the page, at the same
   * point as fnDrawCallback. This may be useful for binding events or
   * performing calculations when the table is altered at all.
   *  @name DataTable#draw.dt
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
   */

  /**
   * Search event, fired when the searching applied to the table (using the
   * built-in global search, or column filters) is altered.
   *  @name DataTable#search.dt
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
   */

  /**
   * Page change event, fired when the paging of the table is altered.
   *  @name DataTable#page.dt
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
   */

  /**
   * Order event, fired when the ordering applied to the table is altered.
   *  @name DataTable#order.dt
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
   */

  /**
   * DataTables initialisation complete event, fired when the table is fully
   * drawn, including Ajax data loaded, if Ajax data is required.
   *  @name DataTable#init.dt
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} oSettings DataTables settings object
   *  @param {object} json The JSON object request from the server - only
   *    present if client-side Ajax sourced data is used</li></ol>
   */

  /**
   * State save event, fired when the table has changed state a new state save
   * is required. This event allows modification of the state saving object
   * prior to actually doing the save, including addition or other state
   * properties (for plug-ins) or modification of a DataTables core property.
   *  @name DataTable#stateSaveParams.dt
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} oSettings DataTables settings object
   *  @param {object} json The state information to be saved
   */

  /**
   * State load event, fired when the table is loading state from the stored
   * data, but prior to the settings object being modified by the saved state
   * - allowing modification of the saved state is required or loading of
   * state for a plug-in.
   *  @name DataTable#stateLoadParams.dt
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} oSettings DataTables settings object
   *  @param {object} json The saved state information
   */

  /**
   * State loaded event, fired when state has been loaded from stored data and
   * the settings object has been modified by the loaded data.
   *  @name DataTable#stateLoaded.dt
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} oSettings DataTables settings object
   *  @param {object} json The saved state information
   */

  /**
   * Processing event, fired when DataTables is doing some kind of processing
   * (be it, order, searcg or anything else). It can be used to indicate to
   * the end user that there is something happening, or that something has
   * finished.
   *  @name DataTable#processing.dt
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} oSettings DataTables settings object
   *  @param {boolean} bShow Flag for if DataTables is doing processing or not
   */

  /**
   * Ajax (XHR) event, fired whenever an Ajax request is completed from a
   * request to made to the server for new data. This event is called before
   * DataTables processed the returned data, so it can also be used to pre-
   * process the data returned from the server, if needed.
   *
   * Note that this trigger is called in `fnServerData`, if you override
   * `fnServerData` and which to use this event, you need to trigger it in you
   * success function.
   *  @name DataTable#xhr.dt
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
   *  @param {object} json JSON returned from the server
   *
   *  @example
   *     // Use a custom property returned from the server in another DOM element
   *     $('#table').dataTable().on('xhr.dt', function (e, settings, json) {
   *       $('#status').html( json.status );
   *     } );
   *
   *  @example
   *     // Pre-process the data returned from the server
   *     $('#table').dataTable().on('xhr.dt', function (e, settings, json) {
   *       for ( var i=0, ien=json.aaData.length ; i<ien ; i++ ) {
   *         json.aaData[i].sum = json.aaData[i].one + json.aaData[i].two;
   *       }
   *       // Note no return - manipulate the data directly in the JSON object.
   *     } );
   */

  /**
   * Destroy event, fired when the DataTable is destroyed by calling fnDestroy
   * or passing the bDestroy:true parameter in the initialisation object. This
   * can be used to remove bound events, added DOM nodes, etc.
   *  @name DataTable#destroy.dt
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
   */

  /**
   * Page length change event, fired when number of records to show on each
   * page (the length) is changed.
   *  @name DataTable#length.dt
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
   *  @param {integer} len New length
   */

  /**
   * Column sizing has changed.
   *  @name DataTable#column-sizing.dt
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
   */

  /**
   * Column visibility has changed.
   *  @name DataTable#column-visibility.dt
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
   *  @param {int} column Column index
   *  @param {bool} vis `false` if column now hidden, or `true` if visible
   */

  return $.fn.dataTable;
}));

}(window, document));

/****** ANGULAR DATATABLES *******/
'use strict';

angular.module('datatables', ['datatables.directive', 'datatables.factory'])
    .run(initAngularDataTables);

/* @ngInject */
function initAngularDataTables($log) {
    if ($.fn.DataTable.Api) {
        /**
         * Register an API to destroy a DataTable without detaching the tbody so that we can add new data
         * when rendering with the "Angular way".
         */
        $.fn.DataTable.Api.register('ngDestroy()', function(remove) {
            remove = remove || false;

            return this.iterator('table', function(settings) {
                var orig = settings.nTableWrapper.parentNode;
                var classes = settings.oClasses;
                var table = settings.nTable;
                var tbody = settings.nTBody;
                var thead = settings.nTHead;
                var tfoot = settings.nTFoot;
                var jqTable = $(table);
                var jqTbody = $(tbody);
                var jqWrapper = $(settings.nTableWrapper);
                var rows = $.map(settings.aoData, function(r) {
                    return r.nTr;
                });
                var ien;

                // Flag to note that the table is currently being destroyed - no action
                // should be taken
                settings.bDestroying = true;

                // Fire off the destroy callbacks for plug-ins etc
                $.fn.DataTable.ext.internal._fnCallbackFire(settings, 'aoDestroyCallback', 'destroy', [settings]);

                // If not being removed from the document, make all columns visible
                if (!remove) {
                    new $.fn.DataTable.Api(settings).columns().visible(true);
                }

                // Blitz all `DT` namespaced events (these are internal events, the
                // lowercase, `dt` events are user subscribed and they are responsible
                // for removing them
                jqWrapper.unbind('.DT').find(':not(tbody *)').unbind('.DT');
                $(window).unbind('.DT-' + settings.sInstance);

                // When scrolling we had to break the table up - restore it
                if (table !== thead.parentNode) {
                    jqTable.children('thead').detach();
                    jqTable.append(thead);
                }

                if (tfoot && table !== tfoot.parentNode) {
                    jqTable.children('tfoot').detach();
                    jqTable.append(tfoot);
                }

                // Remove the DataTables generated nodes, events and classes
                jqTable.detach();
                jqWrapper.detach();

                settings.aaSorting = [];
                settings.aaSortingFixed = [];
                $.fn.DataTable.ext.internal._fnSortingClasses(settings);

                $(rows).removeClass(settings.asStripeClasses.join(' '));

                $('th, td', thead).removeClass(classes.sSortable + ' ' +
                    classes.sSortableAsc + ' ' + classes.sSortableDesc + ' ' + classes.sSortableNone
                );

                if (settings.bJUI) {
                    $('th span.' + classes.sSortIcon + ', td span.' + classes.sSortIcon, thead).detach();
                    $('th, td', thead).each(function() {
                        var wrapper = $('div.' + classes.sSortJUIWrapper, this);
                        $(this).append(wrapper.contents());
                        wrapper.detach();
                    });
                }

                // -------------------------------------------------------------------------
                // This is the only change with the "destroy()" API (with DT v1.10.1)
                // -------------------------------------------------------------------------
                if (!remove && orig) {
                    // insertBefore acts like appendChild if !arg[1]
                    try {
                        orig.insertBefore(table, settings.nTableReinsertBefore);
                    } catch (ex) {
                        $log.warn(ex);
                        orig.appendChild(table);
                    }
                }
                // Add the TR elements back into the table in their original order
                // jqTbody.children().detach();
                // jqTbody.append( rows );
                // -------------------------------------------------------------------------

                // Restore the width of the original table - was read from the style property,
                // so we can restore directly to that
                jqTable
                    .css('width', settings.sDestroyWidth)
                    .removeClass(classes.sTable);

                // If the were originally stripe classes - then we add them back here.
                // Note this is not fool proof (for example if not all rows had stripe
                // classes - but it's a good effort without getting carried away
                ien = settings.asDestroyStripes.length;

                if (ien) {
                    jqTbody.children().each(function(i) {
                        $(this).addClass(settings.asDestroyStripes[i % ien]);
                    });
                }

                /* Remove the settings object from the settings array */
                var idx = $.inArray(settings, $.fn.DataTable.settings);
                if (idx !== -1) {
                    $.fn.DataTable.settings.splice(idx, 1);
                }
            });
        });
    }
}


/****** ANGULAR DATATABLES UTILS *******/
'use strict';

angular.module('datatables.util', []).factory('DTPropertyUtil', dtPropertyUtil);

/* @ngInject */
function dtPropertyUtil($q) {
    return {
        overrideProperties: overrideProperties,
        deleteProperty: deleteProperty,
        resolveObjectPromises: resolveObjectPromises,
        resolveArrayPromises: resolveArrayPromises
    };

    /**
     * Overrides the source property with the given target properties.
     * Source is not written. It's making a fresh copy of it in order to ensure that we do not change the parameters.
     * @param source the source properties to override
     * @param target the target properties
     * @returns {*} the object overrided
     */
    function overrideProperties(source, target) {
        var result = angular.copy(source);

        if (angular.isUndefined(result) || result === null) {
            result = {};
        }
        if (angular.isUndefined(target) || target === null) {
            return result;
        }
        if (angular.isObject(target)) {
            for (var prop in target) {
                if (target.hasOwnProperty(prop)) {
                    result[prop] = overrideProperties(result[prop], target[prop]);
                }
            }
        } else {
            result = angular.copy(target);
        }
        return result;
    }

    /**
     * Delete the property from the given object
     * @param obj the object
     * @param propertyName the property name
     */
    function deleteProperty(obj, propertyName) {
        if (angular.isObject(obj)) {
            delete obj[propertyName];
        }
    }

    /**
     * Resolve any promises from a given object if there are any.
     * @param obj the object
     * @param excludedPropertiesName the list of properties to ignore
     * @returns {promise} the promise that the object attributes promises are all resolved
     */
    function resolveObjectPromises(obj, excludedPropertiesName) {
        var defer = $q.defer(),
            promises = [],
            resolvedObj = {},
            excludedProp = excludedPropertiesName || [];
        if (!angular.isObject(obj) || angular.isArray(obj)) {
            defer.resolve(obj);
        } else {
            resolvedObj = angular.extend(resolvedObj, obj);
            for (var prop in resolvedObj) {
                if (resolvedObj.hasOwnProperty(prop) && $.inArray(prop, excludedProp) === -1) {
                    if (angular.isArray(resolvedObj[prop])) {
                        promises.push(resolveArrayPromises(resolvedObj[prop]));
                    } else {
                        promises.push($q.when(resolvedObj[prop]));
                    }
                }
            }
            $q.all(promises).then(function(result) {
                var index = 0;
                for (var prop in resolvedObj) {
                    if (resolvedObj.hasOwnProperty(prop) && $.inArray(prop, excludedProp) === -1) {
                        resolvedObj[prop] = result[index++];
                    }
                }
                defer.resolve(resolvedObj);
            });
        }
        return defer.promise;
    }

    /**
     * Resolve the given array promises
     * @param array the array containing promise or not
     * @returns {promise} the promise that the array contains a list of objects/values promises that are resolved
     */
    function resolveArrayPromises(array) {
        var defer = $q.defer(),
            promises = [],
            resolveArray = [];
        if (!angular.isArray(array)) {
            defer.resolve(array);
        } else {
            angular.forEach(array, function(item) {
                if (angular.isObject(item)) {
                    promises.push(resolveObjectPromises(item));
                } else {
                    promises.push($q.when(item));
                }
            });
            $q.all(promises).then(function(result) {
                angular.forEach(result, function(item) {
                    resolveArray.push(item);
                });
                defer.resolve(resolveArray);
            });
        }
        return defer.promise;
    }
}

/****** ANGULAR DATATABLES OPTIONS *******/
'use strict';
angular.module('datatables.options', [])
    .constant('DT_DEFAULT_OPTIONS', {
        // Default dom
        dom: 'lfrtip',
        // Default ajax properties. See http://legacy.datatables.net/usage/options#sAjaxDataProp
        sAjaxDataProp: '',
        // Set default columns (used when none are provided)
        aoColumns: []
    })
    .service('DTDefaultOptions', dtDefaultOptions);

function dtDefaultOptions() {
    var options = {
        bootstrapOptions: {},
        setLanguageSource: setLanguageSource,
        setLanguage: setLanguage,
        setDisplayLength: setDisplayLength,
        setBootstrapOptions: setBootstrapOptions
    };

    return options;

    /**
     * Set the default language source for all datatables
     * @param sLanguageSource the language source
     * @returns {DTDefaultOptions} the default option config
     */
    function setLanguageSource(sLanguageSource) {
        $.extend($.fn.dataTable.defaults, {
            oLanguage: {
                sUrl: sLanguageSource
            }
        });
        return options;
    }

    /**
     * Set the language for all datatables
     * @param oLanguage the language
     * @returns {DTDefaultOptions} the default option config
     */
    function setLanguage(oLanguage) {
        $.extend(true, $.fn.dataTable.defaults, {
            oLanguage: oLanguage
        });
        return options;
    }

    /**
     * Set the default number of items to display for all datatables
     * @param iDisplayLength the number of items to display
     * @returns {DTDefaultOptions} the default option config
     */
    function setDisplayLength(iDisplayLength) {
        $.extend($.fn.dataTable.defaults, {
            iDisplayLength: iDisplayLength
        });
        return options;
    }

    /**
     * Set the default options to be use for Bootstrap integration.
     * See https://github.com/l-lin/angular-datatables/blob/dev/src/angular-datatables.bootstrap.options.js to check
     * what default options Angular DataTables is using.
     * @param oBootstrapOptions an object containing the default options for Bootstreap integration
     * @returns {DTDefaultOptions} the default option config
     */
    function setBootstrapOptions(oBootstrapOptions) {
        options.bootstrapOptions = oBootstrapOptions;
        return options;
    }
}

/****** ANGULAR DATATABLES INSTANCES *******/
'use strict';

angular.module('datatables.instances', [])
    .factory('DTInstances', dtInstances)
    .factory('DTInstanceFactory', dtInstanceFactory);

/* @ngInject */
function dtInstances($q) {
    var _instances = {};
    // Promise for fetching the last DT instance
    var _deferLastDTInstance = $q.defer();
    var _lastDTInstance = null;
    // Promise for fetching the list of DT instances
    var _deferDTInstances = $q.defer();
    return {
        register: register,
        getLast: getLast,
        getList: getList
    };

    function register(dtInstance, result) {
        dtInstance.id = result.id;
        dtInstance.DataTable = result.DataTable;
        dtInstance.dataTable = result.dataTable;

        _instances[dtInstance.id] = dtInstance;
        _lastDTInstance = dtInstance;

        //previous promise
        _deferDTInstances.resolve(_instances);
        _deferLastDTInstance.resolve(_lastDTInstance);

        //new promise
        _deferDTInstances = $q.defer();
        _deferLastDTInstance = $q.defer();

        _deferDTInstances.resolve(_instances);
        _deferLastDTInstance.resolve(_lastDTInstance);

        return dtInstance;
    }

    function getLast() {
        var defer = $q.defer();
        _deferLastDTInstance.promise.then(function(lastInstance) {
            defer.resolve(lastInstance);
        });
        return defer.promise;
    }

    function getList() {
        var defer = $q.defer();
        _deferDTInstances.promise.then(function(instances) {
            defer.resolve(instances);
        });
        return defer.promise;
    }
}

function dtInstanceFactory() {
    var DTInstance = {
        reloadData: reloadData,
        changeData: changeData,
        rerender: rerender
    };
    return {
        newDTInstance: newDTInstance
    };

    function newDTInstance(renderer) {
        var dtInstance = Object.create(DTInstance);
        dtInstance._renderer = renderer;
        return dtInstance;
    }

    function reloadData() {
        /*jshint validthis:true */
        this._renderer.reloadData();
    }

    function changeData(data) {
        /*jshint validthis:true */
        this._renderer.changeData(data);
    }

    function rerender() {
        /*jshint validthis:true */
        this._renderer.rerender();
    }
}

/****** ANGULAR DATATABLES FACTORY *******/
'use strict';
angular.module('datatables.factory', [])
    .factory('DTOptionsBuilder', dtOptionsBuilder)
    .factory('DTColumnBuilder', dtColumnBuilder)
    .factory('DTColumnDefBuilder', dtColumnDefBuilder)
    .factory('DTLoadingTemplate', dtLoadingTemplate);

/* @ngInject */
function dtOptionsBuilder() {
    /**
     * The wrapped datatables options class
     * @param sAjaxSource the ajax source to fetch the data
     * @param fnPromise the function that returns a promise to fetch the data
     */
    var DTOptions = {
        hasOverrideDom: false,

        /**
         * Add the option to the datatables optoins
         * @param key the key of the option
         * @param value an object or a function of the option
         * @returns {DTOptions} the options
         */
        withOption: function(key, value) {
            if (angular.isString(key)) {
                this[key] = value;
            }
            return this;
        },

        /**
         * Add the Ajax source to the options.
         * This corresponds to the "ajax" option
         * @param ajax the ajax source
         * @returns {DTOptions} the options
         */
        withSource: function(ajax) {
            this.ajax = ajax;
            return this;
        },

        /**
         * Add the ajax data properties.
         * @param sAjaxDataProp the ajax data property
         * @returns {DTOptions} the options
         */
        withDataProp: function(sAjaxDataProp) {
            this.sAjaxDataProp = sAjaxDataProp;
            return this;
        },

        /**
         * Set the server data function.
         * @param fn the function of the server retrieval
         * @returns {DTOptions} the options
         */
        withFnServerData: function(fn) {
            if (!angular.isFunction(fn)) {
                throw new Error('The parameter must be a function');
            }
            this.fnServerData = fn;
            return this;
        },

        /**
         * Set the pagination type.
         * @param sPaginationType the pagination type
         * @returns {DTOptions} the options
         */
        withPaginationType: function(sPaginationType) {
            if (angular.isString(sPaginationType)) {
                this.sPaginationType = sPaginationType;
            } else {
                throw new Error('The pagination type must be provided');
            }
            return this;
        },

        /**
         * Set the language of the datatables
         * @param language the language
         * @returns {DTOptions} the options
         */
        withLanguage: function(language) {
            this.language = language;
            return this;
        },

        /**
         * Set the language source
         * @param languageSource the language source
         * @returns {DTOptions} the options
         */
        withLanguageSource: function(languageSource) {
            return this.withLanguage({
                url: languageSource
            });
        },

        /**
         * Set default number of items per page to display
         * @param iDisplayLength the number of items per page
         * @returns {DTOptions} the options
         */
        withDisplayLength: function(iDisplayLength) {
            this.iDisplayLength = iDisplayLength;
            return this;
        },

        /**
         * Set the promise to fetch the data
         * @param fnPromise the function that returns a promise
         * @returns {DTOptions} the options
         */
        withFnPromise: function(fnPromise) {
            this.fnPromise = fnPromise;
            return this;
        },

        /**
         * Set the Dom of the DataTables.
         * @param dom the dom
         * @returns {DTOptions} the options
         */
        withDOM: function(dom) {
            this.dom = dom;
            return this;
        }
    };

    return {
        /**
         * Create a wrapped datatables options
         * @returns {DTOptions} a wrapped datatables option
         */
        newOptions: function() {
            return Object.create(DTOptions);
        },
        /**
         * Create a wrapped datatables options with the ajax source setted
         * @param ajax the ajax source
         * @returns {DTOptions} a wrapped datatables option
         */
        fromSource: function(ajax) {
            var options = Object.create(DTOptions);
            options.ajax = ajax;
            return options;
        },
        /**
         * Create a wrapped datatables options with the data promise.
         * @param fnPromise the function that returns a promise to fetch the data
         * @returns {DTOptions} a wrapped datatables option
         */
        fromFnPromise: function(fnPromise) {
            var options = Object.create(DTOptions);
            options.fnPromise = fnPromise;
            return options;
        }
    };
}

function dtColumnBuilder() {
    /**
     * The wrapped datatables column
     * @param mData the data to display of the column
     * @param sTitle the sTitle of the column title to display in the DOM
     */
    var DTColumn = {
        /**
         * Add the option of the column
         * @param key the key of the option
         * @param value an object or a function of the option
         * @returns {DTColumn} the wrapped datatables column
         */
        withOption: function(key, value) {
            if (angular.isString(key)) {
                this[key] = value;
            }
            return this;
        },

        /**
         * Set the title of the colum
         * @param sTitle the sTitle of the column
         * @returns {DTColumn} the wrapped datatables column
         */
        withTitle: function(sTitle) {
            this.sTitle = sTitle;
            return this;
        },

        /**
         * Set the CSS class of the column
         * @param sClass the CSS class
         * @returns {DTColumn} the wrapped datatables column
         */
        withClass: function(sClass) {
            this.sClass = sClass;
            return this;
        },

        /**
         * Hide the column
         * @returns {DTColumn} the wrapped datatables column
         */
        notVisible: function() {
            this.bVisible = false;
            return this;
        },

        /**
         * Set the column as not sortable
         * @returns {DTColumn} the wrapped datatables column
         */
        notSortable: function() {
            this.bSortable = false;
            return this;
        },

        /**
         * Set the column as not searchable
         * @returns {DTColumn} the wrapped datatables column
         */
        notSearchable: function() {
            this.bSearchable = false;
            return this;
        },

        /**
         * Render each cell with the given parameter
         * @mRender mRender the function/string to render the data
         * @returns {DTColumn} the wrapped datatables column
         */
        renderWith: function(mRender) {
            this.mRender = mRender;
            return this;
        }
    };

    return {
        /**
         * Create a new wrapped datatables column
         * @param mData the data of the column to display
         * @param sTitle the sTitle of the column title to display in the DOM
         * @returns {DTColumn} the wrapped datatables column
         */
        newColumn: function(mData, sTitle) {
            if (angular.isUndefined(mData)) {
                throw new Error('The parameter "mData" is not defined!');
            }
            var column = Object.create(DTColumn);
            column.mData = mData;
            column.sTitle = sTitle || '';
            return column;
        },
        DTColumn: DTColumn
    };
}

/* @ngInject */
function dtColumnDefBuilder(DTColumnBuilder) {
    return {
        newColumnDef: function(targets) {
            if (angular.isUndefined(targets)) {
                throw new Error('The parameter "targets" must be defined! See https://datatables.net/reference/option/columnDefs.targets');
            }
            var column = Object.create(DTColumnBuilder.DTColumn);
            if (angular.isArray(targets)) {
                column.aTargets = targets;
            } else {
                column.aTargets = [targets];
            }
            return column;
        }
    };
}

function dtLoadingTemplate() {
    return {
        html: '<h3 class="dt-loading">Loading...</h3>'
    };
}

/****** ANGULAR DATATABLES RENDERER *******/
'use strict';
angular.module('datatables.renderer', ['datatables.instances', 'datatables.factory', 'datatables.options', 'datatables.instances'])
    .factory('DTRendererService', dtRendererService)
    .factory('DTRenderer', dtRenderer)
    .factory('DTDefaultRenderer', dtDefaultRenderer)
    .factory('DTNGRenderer', dtNGRenderer)
    .factory('DTPromiseRenderer', dtPromiseRenderer)
    .factory('DTAjaxRenderer', dtAjaxRenderer)
    .factory('DTRendererFactory', dtRendererFactory);

/* @ngInject */
function dtRendererService(DTLoadingTemplate) {
    var $loading = angular.element(DTLoadingTemplate.html);
    var plugins = [];
    var rendererService = {
        getLoadingElem: getLoadingElem,
        showLoading: showLoading,
        hideLoading: hideLoading,
        renderDataTable: renderDataTable,
        hideLoadingAndRenderDataTable: hideLoadingAndRenderDataTable,
        registerPlugin: registerPlugin,
        postRender: postRender,
        preRender: preRender
    };
    return rendererService;

    function getLoadingElem() {
        return $loading;
    }

    function showLoading($elem) {
        $elem.after($loading);
        $elem.hide();
        $loading.show();
    }

    function hideLoading($elem) {
        $elem.show();
        $loading.hide();
    }

    function renderDataTable($elem, options) {
        var dtId = '#' + $elem.attr('id');
        if ($.fn.dataTable.isDataTable(dtId) && angular.isObject(options)) {
            options.destroy = true;
        }
        // See http://datatables.net/manual/api#Accessing-the-API to understand the difference between DataTable and dataTable
        var DT = $elem.DataTable(options);
        var dt = $elem.dataTable();

        var result = {
            id: $elem.attr('id'),
            DataTable: DT,
            dataTable: dt
        };

        postRender(options, result);

        return result;
    }

    function hideLoadingAndRenderDataTable($elem, options) {
        rendererService.hideLoading($elem);
        return rendererService.renderDataTable($elem, options);
    }

    function registerPlugin(plugin) {
        plugins.push(plugin);
    }

    function postRender(options, result) {
        angular.forEach(plugins, function(plugin) {
            if (angular.isFunction(plugin.postRender)) {
                plugin.postRender(options, result);
            }
        });
    }

    function preRender(options) {
        angular.forEach(plugins, function(plugin) {
            if (angular.isFunction(plugin.preRender)) {
                plugin.preRender(options);
            }
        });
    }
}

function dtRenderer() {
    return {
        withOptions: function(options) {
            this.options = options;
            return this;
        }
    };
}

/* @ngInject */
function dtDefaultRenderer($q, DTRenderer, DTRendererService, DTInstanceFactory, DTInstances) {
    return {
        create: create
    };

    function create(options) {
        var _oTable;
        var _$elem;
        var renderer = Object.create(DTRenderer);
        renderer.name = 'DTDefaultRenderer';
        renderer.options = options;
        renderer.render = render;
        renderer.reloadData = reloadData;
        renderer.changeData = changeData;
        renderer.rerender = rerender;

        function render($elem) {
            _$elem = $elem;
            var dtInstance = DTInstanceFactory.newDTInstance(renderer);
            var result = DTRendererService.hideLoadingAndRenderDataTable($elem, renderer.options);
            _oTable = result.DataTable;
            return $q.when(DTInstances.register(dtInstance, result));
        }

        function reloadData() {
            // Do nothing
        }

        function changeData() {
            // Do nothing
        }

        function rerender() {
            _oTable.destroy();
            DTRendererService.showLoading(_$elem);
            render(_$elem);
        }
        return renderer;
    }
}

/* @ngInject */
function dtNGRenderer($log, $q, $compile, $timeout, DTRenderer, DTRendererService, DTInstances, DTInstanceFactory) {
    /**
     * Renderer for displaying the Angular way
     * @param options
     * @returns {{options: *}} the renderer
     * @constructor
     */
    return {
        create: create
    };

    function create(options) {
        var _staticHTML;
        var _oTable;
        var _$elem;
        var _parentScope;
        var dtInstance;
        var renderer = Object.create(DTRenderer);
        renderer.name = 'DTNGRenderer';
        renderer.options = options;
        renderer.render = render;
        renderer.reloadData = reloadData;
        renderer.changeData = changeData;
        renderer.rerender = rerender;
        return renderer;

        function render($elem, $scope, staticHTML) {
            _staticHTML = staticHTML;
            _$elem = $elem;
            _parentScope = $scope.$parent;
            dtInstance = DTInstanceFactory.newDTInstance(renderer);

            var defer = $q.defer();
            var _expression = $elem.find('tbody').html();
            // Find the resources from the comment <!-- ngRepeat: item in items --> displayed by angular in the DOM
            // This regexp is inspired by the one used in the "ngRepeat" directive
            var _match = _expression.match(/^\s*.+?\s+in\s+(\S*)\s*/);
            var _ngRepeatAttr = _match[1];

            if (!_match) {
                throw new Error('Expected expression in form of "_item_ in _collection_[ track by _id_]" but got "{0}".', _expression);
            }

            var _alreadyRendered = false;

            _parentScope.$watchCollection(_ngRepeatAttr, function() {
                if (_oTable && _alreadyRendered) {
                    _destroyAndCompile();
                }
                $timeout(function() {
                    _alreadyRendered = true;
                    var result = DTRendererService.hideLoadingAndRenderDataTable(_$elem, renderer.options);
                    _oTable = result.DataTable;
                    defer.resolve(DTInstances.register(dtInstance, result));
                }, 0, false);
            }, true);
            return defer.promise;
        }

        function reloadData() {
            $log.warn('The Angular Renderer does not support reloading data. You need to do it directly on your model');
        }

        function changeData() {
            $log.warn('The Angular Renderer does not support changing the data. You need to change your model directly.');
        }

        function rerender() {
            _destroyAndCompile();
            DTRendererService.showLoading(_$elem);
            $timeout(function() {
                var result = DTRendererService.hideLoadingAndRenderDataTable(_$elem, renderer.options);
                _oTable = result.DataTable;
                dtInstance = DTInstances.register(dtInstance, result);
            }, 0, false);
        }

        function _destroyAndCompile() {
            _oTable.ngDestroy();
            // Re-compile because we lost the angular binding to the existing data
            _$elem.html(_staticHTML);
            $compile(_$elem.contents())(_parentScope);
        }
    }
}

/* @ngInject */
function dtPromiseRenderer($q, $timeout, $log, DTRenderer, DTRendererService, DTInstances, DTInstanceFactory) {
    /**
     * Renderer for displaying with a promise
     * @param options the options
     * @returns {{options: *}} the renderer
     * @constructor
     */
    return {
        create: create
    };

    function create(options) {
        var _oTable;
        var _loadedPromise = null;
        var _$elem;

        var dtInstance;
        var renderer = Object.create(DTRenderer);
        renderer.name = 'DTPromiseRenderer';
        renderer.options = options;
        renderer.render = render;
        renderer.reloadData = reloadData;
        renderer.changeData = changeData;
        renderer.rerender = rerender;
        return renderer;

        function render($elem) {
            var defer = $q.defer();
            dtInstance = DTInstanceFactory.newDTInstance(renderer);
            _$elem = $elem;
            _resolve(renderer.options.fnPromise, DTRendererService.renderDataTable).then(function(result) {
                _oTable = result.DataTable;
                defer.resolve(DTInstances.register(dtInstance, result));
            });
            return defer.promise;
        }

        function reloadData() {
            if (angular.isFunction(renderer.options.fnPromise)) {
                _resolve(renderer.options.fnPromise, _redrawRows);
            } else {
                $log.warn('In order to use the reloadData functionality with a Promise renderer, you need to provide a function that returns a promise.');
            }
        }

        function changeData(fnPromise) {
            renderer.options.fnPromise = fnPromise;
            _resolve(renderer.options.fnPromise, _redrawRows);
        }

        function rerender() {
            _oTable.destroy();
            DTRendererService.showLoading(_$elem);
            render(_$elem);
        }

        function _resolve(fnPromise, callback) {
            var defer = $q.defer();
            if (angular.isUndefined(fnPromise)) {
                throw new Error('You must provide a promise or a function that returns a promise!');
            }
            if (_loadedPromise) {
                _loadedPromise.then(function() {
                    defer.resolve(_startLoading(fnPromise, callback));
                });
            } else {
                defer.resolve(_startLoading(fnPromise, callback));
            }
            return defer.promise;
        }

        function _startLoading(fnPromise, callback) {
            var defer = $q.defer();
            if (angular.isFunction(fnPromise)) {
                _loadedPromise = fnPromise();
            } else {
                _loadedPromise = fnPromise;
            }
            _loadedPromise.then(function(result) {
                var data = result;
                // In case the data is nested in an object
                if (renderer.options.sAjaxDataProp) {
                    var properties = renderer.options.sAjaxDataProp.split('.');
                    while (properties.length) {
                        var property = properties.shift();
                        if (property in data) {
                            data = data[property];
                        }
                    }
                }
                _loadedPromise = null;
                defer.resolve(_doRender(renderer.options, _$elem, data, callback));
            });
            return defer.promise;
        }

        function _doRender(options, $elem, data, callback) {
            var defer = $q.defer();
            // Since Angular 1.3, the promise renderer is throwing "Maximum call stack size exceeded"
            // By removing the $promise attribute, we avoid an infinite loop when jquery is cloning the data
            // See https://github.com/l-lin/angular-datatables/issues/110
            delete data.$promise;
            options.aaData = data;
            // Add $timeout to be sure that angular has finished rendering before calling datatables
            $timeout(function() {
                DTRendererService.hideLoading($elem);
                // Set it to true in order to be able to redraw the dataTable
                options.bDestroy = true;
                defer.resolve(callback($elem, options));
            }, 0, false);
            return defer.promise;
        }

        function _redrawRows() {
            _oTable.clear();
            _oTable.rows.add(options.aaData).draw();
            return {
                id: dtInstance.id,
                DataTable: dtInstance.DataTable,
                dataTable: dtInstance.dataTable
            };
        }
    }
}

/* @ngInject */
function dtAjaxRenderer($q, $timeout, DTRenderer, DTRendererService, DT_DEFAULT_OPTIONS, DTInstances, DTInstanceFactory) {
    /**
     * Renderer for displaying with Ajax
     * @param options the options
     * @returns {{options: *}} the renderer
     * @constructor
     */
    return {
        create: create
    };

    function create(options) {
        var _oTable;
        var _$elem;
        var renderer = Object.create(DTRenderer);
        renderer.name = 'DTAjaxRenderer';
        renderer.options = options;
        renderer.render = render;
        renderer.reloadData = reloadData;
        renderer.changeData = changeData;
        renderer.rerender = rerender;
        return renderer;

        function render($elem) {
            _$elem = $elem;
            var defer = $q.defer();
            var dtInstance = DTInstanceFactory.newDTInstance(renderer);
            // Define default values in case it is an ajax datatables
            if (angular.isUndefined(renderer.options.sAjaxDataProp)) {
                renderer.options.sAjaxDataProp = DT_DEFAULT_OPTIONS.sAjaxDataProp;
            }
            if (angular.isUndefined(renderer.options.aoColumns)) {
                renderer.options.aoColumns = DT_DEFAULT_OPTIONS.aoColumns;
            }
            _doRender(renderer.options, $elem).then(function(result) {
                _oTable = result.DataTable;
                defer.resolve(DTInstances.register(dtInstance, result));
            });
            return defer.promise;
        }

        function reloadData() {
            if (_oTable) {
                var ajaxUrl = renderer.options.ajax.url || renderer.options.ajax;
                _oTable.ajax.url(ajaxUrl).load();
            }
        }

        function changeData(ajax) {
            renderer.options.ajax = ajax;
            renderer.reloadData();
        }

        function rerender() {
            _oTable.destroy();
            DTRendererService.showLoading(_$elem);
            render(_$elem);
        }

        function _doRender(options, $elem) {
                var defer = $q.defer();
                // Set it to true in order to be able to redraw the dataTable
                options.bDestroy = true;
                DTRendererService.hideLoading($elem);
                // Condition to refresh the dataTable
                if (_shouldDeferRender(options)) {
                    $timeout(function() {
                        defer.resolve(DTRendererService.renderDataTable($elem, options));
                    }, 0, false);
                } else {
                    defer.resolve(DTRendererService.renderDataTable($elem, options));
                }
                return defer.promise;
            }
            // See https://github.com/l-lin/angular-datatables/issues/147
        function _shouldDeferRender(options) {
            if (angular.isDefined(options) && angular.isDefined(options.dom)) {
                // S for scroller plugin
                return options.dom.indexOf('S') >= 0;
            }
            return false;
        }
    }
}

/* @ngInject */
function dtRendererFactory(DTDefaultRenderer, DTNGRenderer, DTPromiseRenderer, DTAjaxRenderer) {
    return {
        fromOptions: fromOptions
    };

    function fromOptions(options, isNgDisplay) {
        if (isNgDisplay) {
            return DTNGRenderer.create(options);
        }
        if (angular.isDefined(options)) {
            if (angular.isDefined(options.fnPromise) && options.fnPromise !== null) {
                return DTPromiseRenderer.create(options);
            }
            if (angular.isDefined(options.ajax) && options.ajax !== null ||
                angular.isDefined(options.ajax) && options.ajax !== null) {
                return DTAjaxRenderer.create(options);
            }
            return DTDefaultRenderer.create(options);
        }
        return DTDefaultRenderer.create();
    }
}

/******** ANGULAR DATATABLES DIRECTIVE ********/
'use strict';

angular.module('datatables.directive', ['datatables.instances', 'datatables.renderer', 'datatables.options', 'datatables.util'])
    .directive('datatable', dataTable);

/* @ngInject */
function dataTable($q, $http, DTRendererFactory, DTRendererService, DTPropertyUtil) {
    return {
        restrict: 'A',
        scope: {
            dtOptions: '=',
            dtColumns: '=',
            dtColumnDefs: '=',
            datatable: '@'
        },
        compile: compileDirective,
        controller: ControllerDirective
    };

    /* @ngInject */
    function compileDirective(tElm) {
        var _staticHTML = tElm[0].innerHTML;

        return function postLink($scope, $elem, iAttrs, ctrl) {
            function handleChanges(newVal, oldVal) {
                if (newVal !== oldVal) {
                    ctrl.render($elem, ctrl.buildOptionsPromise(), _staticHTML);
                }
            }

            // Options can hold heavy data, and other deep/large objects.
            // watchcollection can improve this by only watching shallowly
            var watchFunction = iAttrs.dtDisableDeepWatchers ? '$watchCollection' : '$watch';
            angular.forEach(['dtColumns', 'dtColumnDefs', 'dtOptions'], function(tableDefField) {
                $scope[watchFunction].call($scope, tableDefField, handleChanges, true);
            });
            DTRendererService.showLoading($elem);
            ctrl.render($elem, ctrl.buildOptionsPromise(), _staticHTML);
        };
    }

    /* @ngInject */
    function ControllerDirective($scope) {
        var _dtInstance;
        var vm = this;
        vm.buildOptionsPromise = buildOptionsPromise;
        vm.render = render;

        function buildOptionsPromise() {
            var defer = $q.defer();
            // Build options
            $q.all([
                $q.when($scope.dtOptions),
                $q.when($scope.dtColumns),
                $q.when($scope.dtColumnDefs)
            ]).then(function(results) {
                var dtOptions = results[0],
                    dtColumns = results[1],
                    dtColumnDefs = results[2];
                // Since Angular 1.3, the promise throws a "Maximum call stack size exceeded" when cloning
                // See https://github.com/l-lin/angular-datatables/issues/110
                DTPropertyUtil.deleteProperty(dtOptions, '$promise');
                DTPropertyUtil.deleteProperty(dtColumns, '$promise');
                DTPropertyUtil.deleteProperty(dtColumnDefs, '$promise');
                var options;
                if (angular.isDefined(dtOptions)) {
                    options = {};
                    angular.extend(options, dtOptions);
                    // Set the columns
                    if (angular.isArray(dtColumns)) {
                        options.aoColumns = dtColumns;
                    }

                    // Set the column defs
                    if (angular.isArray(dtColumnDefs)) {
                        options.aoColumnDefs = dtColumnDefs;
                    }

                    // HACK to resolve the language source manually instead of DT
                    // See https://github.com/l-lin/angular-datatables/issues/181
                    if (options.language && options.language.url) {
                        var languageDefer = $q.defer();
                        $http.get(options.language.url).success(function(language) {
                            languageDefer.resolve(language);
                        });
                        options.language = languageDefer.promise;
                    }

                }
                return DTPropertyUtil.resolveObjectPromises(options, ['data', 'aaData', 'fnPromise']);
            }).then(function(options) {
                defer.resolve(options);
            });
            return defer.promise;
        }

        function render($elem, optionsPromise, staticHTML) {
            optionsPromise.then(function(options) {
                DTRendererService.preRender(options);

                var isNgDisplay = $scope.datatable && $scope.datatable === 'ng';
                // Render dataTable
                if (_dtInstance && _dtInstance._renderer) {
                    _dtInstance._renderer.withOptions(options)
                        .render($elem, $scope, staticHTML).then(function(dtInstance) {
                            _dtInstance = dtInstance;
                        });
                } else {
                    DTRendererFactory.fromOptions(options, isNgDisplay)
                        .render($elem, $scope, staticHTML).then(function(dtInstance) {
                            _dtInstance = dtInstance;
                        });
                }
            });
        }
    }
}

/*!
 * angular-datatables - v0.4.2
 * https://github.com/l-lin/angular-datatables
 * License: MIT
 */
(function (window, document, $, angular) {

'use strict';

// See http://datatables.net/extensions/scroller/
angular.module('datatables.scroller', ['datatables'])
    .config(dtScrollerConfig);

/* @ngInject */
function dtScrollerConfig($provide, DT_DEFAULT_OPTIONS) {
    $provide.decorator('DTOptionsBuilder', dtOptionsBuilderDecorator);

    function dtOptionsBuilderDecorator($delegate) {
        var newOptions = $delegate.newOptions;
        var fromSource = $delegate.fromSource;
        var fromFnPromise = $delegate.fromFnPromise;

        $delegate.newOptions = function() {
            return _decorateOptions(newOptions);
        };
        $delegate.fromSource = function(ajax) {
            return _decorateOptions(fromSource, ajax);
        };
        $delegate.fromFnPromise = function(fnPromise) {
            return _decorateOptions(fromFnPromise, fnPromise);
        };

        return $delegate;

        function _decorateOptions(fn, params) {
            var options = fn(params);
            options.withScroller = withScroller;
            return options;

            /**
             * Add scroller compatibility
             * @returns {DTOptions} the options
             */
            function withScroller() {
                var scrollerSuffix = 'S';
                options.dom = options.dom ? options.dom : DT_DEFAULT_OPTIONS.dom;
                if (options.dom.indexOf(scrollerSuffix) === -1) {
                    options.dom = options.dom + scrollerSuffix;
                }
                return options;
            }
        }
    }
    dtOptionsBuilderDecorator.$inject = ['$delegate'];
}
dtScrollerConfig.$inject = ['$provide', 'DT_DEFAULT_OPTIONS'];


})(window, document, jQuery, angular);
/*jshint scripturl:true*/

angular.module('vmfTabsMod', [])
  .directive('vmfTabs', function() {
    return {
      restrict: 'E',
      transclude: true,
      scope: {},
      controller: function($scope) {
        var panes = $scope.panes = [];
         var currentPane = 0;
        $scope.onKeydown = function(e) { 
          //console.log(panes);
          if(e.keyCode === 37){    //left 37
            var i = 0;
            for(;;){
              if (panes[i].selected) {
                break;
              }else{
                i = i + 1;  
              }
            }
            
            
            if(i> 0){
              angular.forEach(panes, function(pane) {
                pane.selected = false;
              });
             
              //console.log(i);
              $scope.ieselect(panes[i-1]);
            }
          }
          if(e.keyCode === 39){    //right 39
            var j = 0;
            for(;;){
              if (panes[j].selected) {
                break;
              }else{
                j = j + 1;  
              }
            }
           
            if ((j+1) !== panes.length){
              angular.forEach(panes, function(pane) {
                pane.selected = false;
              });
              $scope.ieselect(panes[j+1]);
            }
          }
         
        };
        $scope.select = function(pane) {
          
          angular.forEach(panes, function(pane) {
            pane.selected = false;
          });
          pane.selected = true;
        };
        // $scope.iflink = function(l){
        //   if(l){
        //     return l;
        //   }else{
        //     return 'javascript: void(0)';
        //   }

        // };
        $scope.ieselect = function(pane,currentIndex,curEvent) {
          angular.forEach(panes, function(pane) {
            pane.selected = false;
            $(".tab-content").find("vmf-pane[tabno="+pane.tabno+"]").children().hide();
          });
          pane.selected = true;
          
          $(".tab-content").find("vmf-pane[tabno="+pane.tabno+"]").children().show();
          //$(".navbar-collapse ul").find("li a").removeClass("activeState");
         // $(".navbar-collapse ul").find("li a").eq(currentIndex).addClass("activeState");
          $(curEvent.target).parents("ul").find("li a").removeClass("activeState");
          $(curEvent.target).addClass("activeState");
        };

        this.addPane = function(pane) {
           $(".tab-content").find("vmf-pane").children().hide();
          if (panes.length === 0) {
            $scope.select(pane);
            
          }
          panes.push(pane);
          $.each($(".tab-content"),function(){
            $(this).children().first().children().show();
          });

          
        };
      },

      template: "<div class=' vmfTab'><div class='navbar-header'><a class='navbar-toggle'></a></div><div class='collapse navbar-collapse' ><ul class=' '><li ng-keyup='onKeydown($event)' ng-repeat='pane in panes' ng-class='{active:pane.selected}'><a href='javascript:void(0);' ng-class='{activeState:pane.selected}' ng-click='select(pane);ieselect(pane,$index,$event);'>{{pane.listlabel}}</a></li></ul></div></div><div class='tab-content' ng-transclude></div>"

    };
  })
  .directive('vmfPane', function($timeout) {
    return {
      require: '^vmfTabs',
      restrict: 'E',
      transclude: true,
      scope: {
        tabno: '@',
        listlabel:'@',
        link:'@'
      },
      link: function(scope, element, attrs, tabsCtrl) {
        tabsCtrl.addPane(scope);
        $timeout(function() {
          $(".navbar-collapse ul").find("li a").eq(0).addClass("activeState");
        });
        
      },
      template: "<div class='tab-pane' ng-show='selected' ng-transclude></div>"
    };
})
  .directive('vmfTabsone', function() {
    return {
      restrict: 'E',
      transclude: true,
      scope: {},
      controller: function($scope) {
        
        var panes = $scope.panes = [];
         var currentPane = 0;
        $scope.onKeydown = function(e) {
         
          if(e.keyCode === 37){    //left 37
            var i = 0;
            for(;;){
              if (panes[i].selected) {
                break;
              }else{
                i = i + 1;  
              }
              
        
            }
            
            
            if(i> 0){
              angular.forEach(panes, function(pane) {
                pane.selected = false;
              });
             
             
              $scope.ieselect(panes[i-1]);


            }
            

          }
          if(e.keyCode === 39){    //right 39
            var j = 0;
            for(;;){
              if (panes[j].selected) {
                break;
              }else{
                j = j + 1;  
              }
              
        
            }
            
            if ((j+1) !== panes.length){
              angular.forEach(panes, function(pane) {
                pane.selected = false;
              });
             
              
              $scope.ieselect(panes[j+1]);

            }

            
           
           

          }
          
        };
        $scope.select = function(pane) {
          // console.log('select called');
          // console.log(pane);
          // currentPane = index;
          angular.forEach(panes, function(pane) {
            pane.selected = false;
          });
          pane.selected = true;
        };
        $scope.ieselect = function(pane,currentIndex,curEvent) {
          angular.forEach(panes, function(pane) {
            pane.selected = false;
            $(".tab-content").find("vmf-paneone[tabno="+pane.tabno+"]").children().hide();
          });
          pane.selected = true;
          
          $(".tab-content").find("vmf-paneone[tabno="+pane.tabno+"]").children().show();
          //$(".navbar-collapse ul").find("li a").removeClass("activeState");
         //alert(currentIndex);
          //$(".navbar-collapse ul").find("li a").eq(currentIndex).addClass("activeState");
          $(curEvent.target).parents("ul").find("li a").removeClass("activeState");
          $(curEvent.target).addClass("activeState");
        };

        this.addPane = function(pane) {
           $(".tab-content").find("vmf-paneone").children().hide();
          if (panes.length === 0) {
            $scope.select(pane);
            
          }
          panes.push(pane);
          $.each($(".tab-content"),function(){
            $(this).children().first().children().show();
          });

          //$(".navbar-collapse ul").find("li a").eq(0).addClass("activeState");
          //alert("e");
        };

      },

      template: "<div class=' vmfTab vmfTab1'><ul class=''><li ng-keyup='onKeydown($event)' ng-repeat='pane in panes' ng-class='{active:pane.selected}'><a href='{{pane.tabhref}}' ng-class='{activeState:pane.selected}' class='{{pane.customClass}}' ng-click='select(pane);ieselect(pane,$index,$event);'>{{pane.listlabel}}</a></li></ul></div><div class='tab-content' ng-transclude></div>"

    };
  })
.directive('vmfPaneone', function($timeout) {
    return {
      require: '^vmfTabsone',
      restrict: 'E',
      transclude: true,
      scope: {
        tabno: '@',
        listlabel:'@',
        link:'@',
        tabhref:'@',
        customClass:'@'
      },
      link: function(scope, element, attrs, tabsCtrl) {
        tabsCtrl.addPane(scope);
        $timeout(function() {
          $(".vmfTab.vmfTab1 ul").find("li a").eq(0).addClass("activeState");
        });
      },
      template: "<div class='tab-pane' ng-show='selected' ng-transclude></div>"
    };
})
.directive('vmfTabstwo', function() {
    return {
      restrict: 'E',
      transclude: true,
      scope: {
        labelmessage:'@'
      },
      controller: function($scope) {
        
        var panes = $scope.panes = [];
         var currentPane = 0;
        $scope.onKeydown = function(e) {
         
          if(e.keyCode === 37){    //left 37
            var i = 0;
            for(;;){
              if (panes[i].selected) {
                break;
              }else{
                i = i + 1;  
              }
              
        
            }
            
            
            if(i> 0){
              angular.forEach(panes, function(pane) {
                pane.selected = false;
              });
             
             
              $scope.ieselect(panes[i-1]);


            }
            

          }
          if(e.keyCode === 39){    //right 39
            var j = 0;
            for(;;){
              if (panes[j].selected) {
                break;
              }else{
                j = j + 1;  
              }
              
        
            }
            
            if ((j+1) !== panes.length){
              angular.forEach(panes, function(pane) {
                pane.selected = false;
              });
             
              
              $scope.ieselect(panes[j+1]);

            }

            
           
           

          }
          
        };
        $scope.select = function(pane) {
          // console.log('select called');
          // console.log(pane);
          // currentPane = index;
          angular.forEach(panes, function(pane) {
            pane.selected = false;
          });
          pane.selected = true;
        };
        $scope.ieselect = function(pane,currentIndex,curEvent) {
          angular.forEach(panes, function(pane) {
            pane.selected = false;
            $(".tab-content").find("vmf-panetwo[tabno="+pane.tabno+"]").children().hide();
          });
          pane.selected = true;
          
          $(".tab-content").find("vmf-panetwo[tabno="+pane.tabno+"]").children().show();

         // $(".navbar-collapse ul").find("li a").removeClass("activeState");
          //$(".navbar-collapse ul").find("li a").eq(currentIndex).addClass("activeState");
          $(curEvent.target).parents("ul").find("li a").removeClass("activeState");
          $(curEvent.target).addClass("activeState");
        };

        this.addPane = function(pane) {
           $(".tab-content").find("vmf-panetwo").children().hide();
          if (panes.length === 0) {
            $scope.select(pane);
            
          }
          panes.push(pane);
          $.each($(".tab-content"),function(){
            $(this).children().first().children().show();
          });

          
        };
      },

      template: "<div class='  vmfTab2'><span class='tab_head_txt pull-left'>{{labelmessage}}</span><ul class=''><li ng-keyup='onKeydown($event)' ng-repeat='pane in panes' ng-class='{active:pane.selected}'><a href='javascript:void(0);' ng-class='{activeState:pane.selected}' ng-click='select(pane);ieselect(pane,$index,$event);'>{{pane.listlabel}}</a></li></ul></div><div class='tab-content' ng-transclude></div>"

    };
  })
.directive('vmfPanetwo', function($timeout) {
    return {
      require: '^vmfTabstwo',
      restrict: 'E',
      transclude: true,
      scope: {
        tabno: '@',
        listlabel:'@',
        link:'@'
      },
      link: function(scope, element, attrs, tabsCtrl) {
        tabsCtrl.addPane(scope);
        $timeout(function() {
          $(".vmfTab2 ul").find("li a").eq(0).addClass("activeState");
        });
      },
      template: "<div class='tab-pane' ng-show='selected' ng-transclude></div>"
    };
});




angular.module('vmfSelectListMod', [])
.directive('vmfSelectList', ['$compile', '$document', '$window', '$timeout',
    function($compile, $document, $window, $timeout) {
        return {
            restrict: 'EA',
            scope: {
                dtitle: '@',        // dropdown title on left side
                defaulttext: '@',
                model: '=',
                list: '=',
                sortby: '@',
                mandatory: '@',
                customClass:'=',
                htitle:'@',         // dropdown header/button title
                sub:'=',            // false if selected value should not substitute header title but shown somewhere else otherwise true by default 
                //Truncate variables
                truncate: '@',
                listalign: '@',
                enablesearch: '@',
                searchplaceholder: '@',
                //Truncate variables
                preSelectInd: '=',  // pre selected value in dropdown
                titleColMod:'@',
                selectColMod:'@',
                showArrows : '@',
                dropdownType : '@',
                templateUrl : '@',
                controllerName : '@',
                customeventname: '@'
            },
            link: function(scope, elem, attrs) {
                //Transformation Logic
                //Transforms multidimentional Array of groups into single dimension array
                //this logic only for seperator based list.
                var listInStandardFormat = [];
                if(attrs.dropdownType == "with_seperators" || attrs.dropdownType == "with_group"){
                    if(scope.list && scope.list[0] && scope.list[0] instanceof Array){
                        angular.forEach(scope.list, function(item,ind){
                            angular.forEach(item, function(arrItem, arrIndex){
                                if(arrIndex == 0){
                                    arrItem.seperator = "true";
                                }
                                listInStandardFormat.push(arrItem);
                            });
                        });
                    }
                    scope.list = listInStandardFormat;
                }
             
                if(scope.list && scope.list[0]){
                    if(attrs.sortby == "false") {
                    }
                    else if(typeof scope.list[0] === 'string') {
                        scope.list.sort();
                    }
                    else if(typeof scope.list[0] === 'number') {
                        scope.list.sort(function (a, b) {return a - b;});
                    }
                    else if(typeof scope.list[0] === 'object') {
                    
                        if(scope.sortby === 'value') {
                    
                            if(typeof scope.list[0].value === 'number') {
                                scope.list.sort(function (a, b) {return a.value - b.value;});
                            }
                            else if(typeof scope.list[0].value === 'string') {

                                scope.list.sort(function (a, b) {
                                    if(a.value < b.value) {
                                        return -1;
                                    }
                                    else if(a.value > b.value) {
                                        return 1;
                                    }
                                    else {
                                        return 0;
                                    }
                                });
                            }

                        }
                        else if (attrs.sortby) {
                            scope.list.sort(function (a, b) {
                                if(a.text < b.text) {
                                    return -1;
                                }
                                else if(a.text > b.text) {
                                    return 1;
                                }
                                else {
                                    return 0;
                                }
                            });
                        }
                    }
                }
                scope.initializeScroll = false;

                var template;
                var titleColMod = typeof scope.titleColMod !== "undefined" ? scope.titleColMod : 'col-md-2';
                var selectColMod = typeof scope.selectColMod !== "undefined" ? scope.selectColMod : 'col-md-4';
                //Adding class if truncate 
                var truncateMod = typeof scope.truncate !== "undefined" ? 'vmf-dropdown-truncate' : '';
                var searchMod = typeof scope.enablesearch !== "undefined" ? '<div class="bootstrap-select-searchbox"><input type="text" class="input-block-level form-control search-box search-icon" autocomplete="off" placeholder="{{ searchplaceholder }}" /></div>' : '';

                var showDDArrows = typeof scope.showArrows !== "undefined" ? scope.showArrows : true;
                var sub = typeof scope.sub !== "undefined" ? scope.sub : true;
                var defaulttext = scope.defaulttext || 'Select';

                if(scope.mandatory === 'true') {
                    if(scope.dtitle) {
                        if(attrs.htitle ==='' || attrs.htitle) {
                            template = '<div class="vmf_drop-down_text"><label class="labelHeader formLabel '+titleColMod+' col-xs-12"><span class="mandatory">*</span>{{dtitle}}</label><div tabindex="0" class="vmf-dropdown '+selectColMod+' col-xs-12" ng-keyDown="keyPressTitle($event);" ng-click="changeClass($event);"><div class="vmf-dropdown-content"><span class="current-selection">{{htitle}}</span><ul class="dropDownListItems' + (attrs.dropdownType=="mega-dropdown" ? " flexWidth" : "") +'">' + searchMod;
                           
                        }
                        else if(typeof scope.preSelectInd !== 'undefined') {
                            if(scope.list && scope.list[0] && typeof scope.list[0] === 'object') {
                                template = '<div class="vmf_drop-down_text"><label class="labelHeader formLabel '+titleColMod+' col-xs-12"><span class="mandatory">*</span>{{dtitle}}</label><div tabindex="0" class="vmf-dropdown '+selectColMod+' col-xs-12" ng-keyDown="keyPressTitle($event);" ng-click="changeClass($event);"><div class="vmf-dropdown-content"><span class="current-selection">' + scope.list[scope.preSelectInd].text + '</span><ul class="dropDownListItems' + (attrs.dropdownType=="mega-dropdown" ? " flexWidth" : "") +'">' + searchMod;                       
                            }
                            else {
                                template = '<div class="vmf_drop-down_text"><label class="labelHeader formLabel '+titleColMod+' col-xs-12"><span class="mandatory">*</span>{{dtitle}}</label><div tabindex="0" class="vmf-dropdown '+selectColMod+' col-xs-12" ng-keyDown="keyPressTitle($event);" ng-click="changeClass($event);"><div class="vmf-dropdown-content"><span class="current-selection">' + scope.list[scope.preSelectInd] + '</span><ul class="dropDownListItems' + (attrs.dropdownType=="mega-dropdown" ? " flexWidth" : "") +'">' + searchMod;   
                            }    
                        }
                        else {
                            template = '<div class="vmf_drop-down_text"><label class="labelHeader formLabel '+titleColMod+' col-xs-12"><span class="mandatory">*</span>{{dtitle}}</label><div tabindex="0" class="vmf-dropdown '+selectColMod+' col-xs-12" ng-keyDown="keyPressTitle($event);" ng-click="changeClass($event);"><div class="vmf-dropdown-content"><span class="current-selection">'+ defaulttext +'</span><ul class="dropDownListItems' + (attrs.dropdownType=="mega-dropdown" ? " flexWidth" : "") +'">'+ searchMod;
                        }

                    }
                    else {
                        if(attrs.htitle ==='' || attrs.htitle) {
                            template = '<div class="vmf_drop-down_text"><span class="mandatory">*</span><div tabindex="0" class="vmf-dropdown '+selectColMod+' col-xs-12" ng-keyDown="keyPressTitle($event);" ng-click="changeClass($event);"><div class="vmf-dropdown-content"><span class="current-selection">{{htitle}}</span><ul class="dropDownListItems' + (attrs.dropdownType=="mega-dropdown" ? " flexWidth" : "") +'">'+ searchMod;
                           
                        }
                        else if(typeof scope.preSelectInd !== 'undefined') {
                            if(scope.list && scope.list[0] && typeof scope.list[0] === 'object') {
                                template = '<div class="vmf_drop-down_text"><span class="mandatory">*</span><div tabindex="0" class="vmf-dropdown '+selectColMod+' col-xs-12" ng-keyDown="keyPressTitle($event);" ng-click="changeClass($event);"><div class="vmf-dropdown-content"><span class="current-selection">' + scope.list[scope.preSelectInd].text + '</span><ul class="dropDownListItems' + (attrs.dropdownType=="mega-dropdown" ? " flexWidth" : "") +'">' + searchMod;                      
                            }
                            else {
                                template = '<div class="vmf_drop-down_text"><span class="mandatory">*</span><div tabindex="0" class="vmf-dropdown '+selectColMod+' col-xs-12" ng-keyDown="keyPressTitle($event);" ng-click="changeClass($event);"><div class="vmf-dropdown-content"><span class="current-selection">' + scope.list[scope.preSelectInd] + '</span><ul class="dropDownListItems' + (attrs.dropdownType=="mega-dropdown" ? " flexWidth" : "") +'">' + searchMod;   
                            }    
                        }

                        else {

                            template = '<div class="vmf_drop-down_text"><span class="mandatory">*</span><div tabindex="0" class="vmf-dropdown '+selectColMod+' col-xs-12" ng-keyDown="keyPressTitle($event);" ng-click="changeClass($event);"><div class="vmf-dropdown-content"><span class="current-selection">'+ defaulttext +'</span><ul class="dropDownListItems' + (attrs.dropdownType=="mega-dropdown" ? " flexWidth" : "") +'">'+ searchMod;  
                        }
                    }
                }

                else {
                    if(scope.dtitle) {
                        if(attrs.htitle ==='' || attrs.htitle) {
                            template = '<div class="vmf_drop-down_text"><label class="labelHeader formLabel '+titleColMod+' col-xs-12">{{dtitle}}</label><div tabindex="0" class="vmf-dropdown '+selectColMod+' col-xs-12" ng-keyDown="keyPressTitle($event);" ng-click="changeClass($event);"><div class="vmf-dropdown-content"><span class="current-selection">{{htitle}}</span><ul class="dropDownListItems' + (attrs.dropdownType=="mega-dropdown" ? " flexWidth" : "") +'">' + searchMod;
                        }
                        else if(typeof scope.preSelectInd !== 'undefined') {
                            if(scope.list && scope.list[0] && typeof scope.list[0] === 'object') {
                                template = '<div class="vmf_drop-down_text"><label class="labelHeader formLabel '+titleColMod+' col-xs-12">{{dtitle}}</label><div tabindex="0" class="vmf-dropdown '+selectColMod+' col-xs-12" ng-keyDown="keyPressTitle($event);" ng-click="changeClass($event);"><div class="vmf-dropdown-content"><span class="current-selection">' + scope.list[scope.preSelectInd].text + '</span><ul class="dropDownListItems' + (attrs.dropdownType=="mega-dropdown" ? " flexWidth" : "") +'">'+ searchMod;                       
                            }
                            else {
                                template = '<div class="vmf_drop-down_text"><label class="labelHeader formLabel '+titleColMod+' col-xs-12">{{dtitle}}</label><div tabindex="0" class="vmf-dropdown '+selectColMod+' col-xs-12" ng-keyDown="keyPressTitle($event);" ng-click="changeClass($event);"><div class="vmf-dropdown-content"><span class="current-selection">' + scope.list[scope.preSelectInd] + '</span><ul class="dropDownListItems' + (attrs.dropdownType=="mega-dropdown" ? " flexWidth" : "") +'">'+ searchMod;   
                            }    
                        }
                        else {
                            template = '<div class="vmf_drop-down_text"><label class="labelHeader formLabel '+titleColMod+' col-xs-12">{{dtitle}}</label><div tabindex="0" class="vmf-dropdown '+selectColMod+' col-xs-12" ng-keyDown="keyPressTitle($event);" ng-click="changeClass($event);"><div class="vmf-dropdown-content"><span class="current-selection">'+ defaulttext +'</span><ul class="dropDownListItems' + (attrs.dropdownType=="mega-dropdown" ? " flexWidth" : "") +'">'+ searchMod;
                        }
                        
                    } 
                    else {
                        if(attrs.htitle ==='' || attrs.htitle) {
                            template = '<div class="vmf_drop-down_text"><div tabindex="0" class="vmf-dropdown '+selectColMod+' col-xs-12" ng-keyDown="keyPressTitle($event);" ng-click="changeClass($event);"><div class="vmf-dropdown-content"><span class="current-selection">{{htitle}}</span><ul class="dropDownListItems' + (attrs.dropdownType=="mega-dropdown" ? " flexWidth" : "") +'">'+ searchMod;
                        }
                        
                        else if(typeof scope.preSelectInd !== 'undefined') {
                            if(scope.list && scope.list[0] && typeof scope.list[0] === 'object') {
                                template = '<div class="vmf_drop-down_text"><div tabindex="0" class="vmf-dropdown '+selectColMod+' col-xs-12" ng-keyDown="keyPressTitle($event);" ng-click="changeClass($event);"><div class="vmf-dropdown-content"><span class="current-selection">'+ scope.list[scope.preSelectInd].text +'</span><ul class="dropDownListItems' + (attrs.dropdownType=="mega-dropdown" ? " flexWidth" : "") +'">' + searchMod;   
                            }
                            else {                              
                                template = '<div class="vmf_drop-down_text"><div tabindex="0" class="vmf-dropdown '+selectColMod+' col-xs-12" ng-keyDown="keyPressTitle($event);" ng-click="changeClass($event);"><div class="vmf-dropdown-content"><span class="current-selection">'+ scope.list[scope.preSelectInd] +'</span><ul class="dropDownListItems' + (attrs.dropdownType=="mega-dropdown" ? " flexWidth" : "") +'">' + searchMod;   
                            }
                                
                        }    
                        else {

                            template = '<div class="vmf_drop-down_text"><div tabindex="0" class="vmf-dropdown '+selectColMod+' col-xs-12" ng-keyDown="keyPressTitle($event);" ng-click="changeClass($event);"><div class="vmf-dropdown-content"><span class="current-selection">'+ defaulttext +'</span><ul class="dropDownListItems' + (attrs.dropdownType=="mega-dropdown" ? " flexWidth" : "") +'">'+ searchMod;  
                        }    
                    }
                }

                //********************** All truncate functionalities  ********************//
                //Checking IE version
                var isLowerIE = function(){
                    var myNav = navigator.userAgent.toLowerCase();
                    return (myNav.indexOf('msie') != -1) ? parseInt(myNav.split('msie')[1]) : false;
                }
                //Get truncated text
                var getTruncatedVal = function(text){
                      var limit = scope.truncate;
                      var ellipsis = "...";
                      if (text.length > limit) {
                         // -4 to include the ellipsis size and also since it is an index
                         var trimmedText = text.substring(0, limit - 4); 
                             trimmedText += ellipsis;
                      }else{
                        trimmedText = text;
                      }
                      return trimmedText;
                }
                var detectedCharWidths = {};
                var avgCharWidth = 6.5;

                //Get text length for truncate value
                var detectCharWidth = function(testText){
                    var val = testText || "a b c d e f 1 2 3 4 5 6 A B C D E F ! ! %"; //correct detection depends on this more then anything
                    if(!detectedCharWidths[val]){
                            var $inp = $("<span>", {
                                "text":val,
                                "class":"optionsHolder",
                                "css": {"background":"none", "margin":0, "padding":0, "overflow":"visible", "width":"auto", "color":"#FFF","font":"15px normal arial"}
                            });
                            $("body").append($inp);
                            detectedCharWidths[val] = ($inp.width() / val.length);
                            $inp.remove();
                    }
                    return detectedCharWidths[val];
                };
                //Changing position of option list if align attribute is given
                var resizeOptions = function(){
                    var listLeftPos = "auto";
                    if(scope.listalign === "right"){
                        elem.find('.vmf-dropdown-content').addClass("vmf-dropdown-align-right");
                    }else if(scope.listalign === "center"){
                        var _parentWidth = elem.find('.vmf-dropdown-content').width()/2,
                            _listWidth = ul.width()/2;
                            listLeftPos = (_parentWidth - _listWidth); 
                    }else{
                        elem.find('.vmf-dropdown-content').removeClass("vmf-dropdown-align-right");
                        listLeftPos = 0;
                    }
                    //Setting ul's width
                    if(itemLengthExceed && $document.width() > 768 && elem.find('.vmf-dropdown-truncate').width() < (scope.truncate * avgCharWidth) && elem.find('.vmf-dropdown-truncate ul.dropDownListItems').width() > elem.find('.vmf-dropdown-truncate').width()){
                        ul.css({"width":(scope.truncate * avgCharWidth),"left":listLeftPos});
                    }else{
                        ul.css({"width":"100%","left":"0"});
                    }
                };
                var itemLengthExceed = false;
                if (scope.list && scope.list[0] && typeof scope.list[0] === 'object') {

                    angular.forEach(scope.list, function(item,ind) {
                        var itemText = item.text;
                        template += '<li data-value="'+ item.value +'" ';

                        // adding title to the li, when showtitle attribute was given (used when text has ellipsis and user cant see....)
                        if( attrs.hasOwnProperty("showtitle") && attrs.showtitle === "true" ){
                          template += 'title="'+ itemText +'"';
                        }
                        
                        //For manipulating click event on menu items
                        if(attrs.dropdownType == "with_submenu"){
                            if(item.submenu && item.submenu.length > 0){
                                template += 'ng-mouseover="mouseOverObj($event,' + ind + ');"';
                            }else{
                                template += 'ng-click="selectObj($event,' + ind + ');"';
                            }
                        }else {
                             if(item.label == 'true' && item.selectable == 'true'){
                                template += 'ng-click="selectObj($event,' + ind + ');"';
                            }else if(!(item.label == 'true')){
                                template += 'ng-click="selectObj($event,' + ind + ');"';
                            }
                        }
                       
                        //For manipulating classes  on menu items for seperator and intendation
                        if(attrs.dropdownType == "with_seperators" && item.seperator == 'true'){
                            template += ' class=" seperator_bar " ';
                        }else if(attrs.dropdownType == "with_group" && item.label == "true"){
                            template += ' class=" main-item" ';
                        }else if(attrs.dropdownType == "with_group" && !item.label){
                            template += ' class=" sub-item" ';
                        }else if(attrs.dropdownType == "with_submenu" && scope.list[ind].submenu && scope.list[ind].submenu.length > 0){
                            template += ' class=" main-menu" ';
                        }
                        if(scope.truncate){
                          template += 'title="' + item.text +'"';
                          avgCharWidth = detectCharWidth(item.text);
                          //itemText =  getTruncatedVal(item.text);
                          if(!itemLengthExceed && item.text.length > scope.truncate){
                            itemLengthExceed = true;
                          }
                        }
                        template += '>' + itemText + '</li>';
                    });
                } 
                else {

                    angular.forEach(scope.list, function(item) {
                        var itemText = item;
                        template += '<li ng-click="select($event);"';
                        if(scope.truncate){
                          template += 'title="' + item +'"';
                          avgCharWidth = detectCharWidth(item);
                          //itemText =  getTruncatedVal(item);
                          if(!itemLengthExceed && item.length > scope.truncate){
                            itemLengthExceed = true;
                          }
                        }
                        template += '>' + itemText + '</li>';
                    });
                }
                
                //Inserting the dirctive inside the main directive,
                //Shouuld pass the template url and controller name
                if(attrs.templateUrl){
                    var value = '<div vm-template-insert template='+ attrs.templateUrl +' controller-name=' + attrs.controllerName +'></div>';
                    template += value;
                }
                template += '</ul>';
                // if(attrs.dropdownType = "with_submenu"){
                //     template += '<ul style = "position: absolute; width: 100%; left: 100%;" class = "submenu-list">'
                //     +'<li>hello1</li><li>hello2</li><li>hello3</li>'
                //     +'</ul>';
                // }
                template +='</div></div></div>';

                elem.append(template);

                if(scope.customClass){
                    angular.forEach(scope.customClass, function(item) {
                        elem.find(item.selector).addClass(item.cusclass);


                    });
                }

                $compile(elem.contents())(scope);

                if(scope.list && scope.list.length > 15) {
                    scope.initializeScroll = true;
                }

                var ul = elem.find('ul');
                
                var scrollPane, scrollPaneApi;
                //Searchbox functionality
                var searchBox =  elem.find('input.search-box');
                searchBox.on('focus',function(e){
                    e.preventDefault();
                    e.stopPropagation();
                });
                $.expr[':'].icontains = function(obj, index, meta) {
                    return $(obj).text().toUpperCase().indexOf(meta[3].toUpperCase()) >= 0;
                };
                var liveSearchListener = function() {
                    var no_results = $('<li class="search-list no-results" style="display:block;"></li>');
                    var $lis = ul.find("li").not('.no-results');
                    searchBox.on('keyup',function(e){
                        //scope.currentIndex = -1;
                        no_results.html('No results for "'+ searchBox.val() + '"').show();
                        ul.find('li').last().after(no_results);
                        //**** search event ****//
                        if (searchBox.val()) {
                            $lis.not('.is-hidden').removeClass('hide').not(':icontains(' + searchBox.val() + ')').addClass('hide'); 
                            if (!ul.find('li').filter(':visible:not(.no-results)').length) {
                                if (!!no_results.parent().length) no_results.remove();
                                no_results.html('No results for "'+ searchBox.val() + '"').show();
                                ul.find('li').last().after(no_results);
                            } else if (!!no_results.parent().length) {
                                no_results.remove();
                            }
                        } else {
                            $lis.not('.is-hidden').removeClass('hide');
                            if (!!no_results.parent().length) no_results.remove();
                        }
                        ul.find('li.active').removeClass('active');
                        //ul.find('li').filter(':visible:not(.divider)').eq(0).addClass('active').find('a').focus();
                        $(this).focus();

                    });
                };

                liveSearchListener();

                /*if(scope.initializeScroll) {
                    
                        
                    scrollPane = ul.jScrollPane({
                        autoReinitialise: true,
                        showArrows: showDDArrows,
                        verticalArrowPositions: 'after'
                    });
                

                    scrollPaneApi = scrollPane.data('jsp');
                }*/

                //** Updating width of UL as per character limit
                var currentSelection = elem.find('span.current-selection');

                ul.hide();

                var options = elem.find('li').not('.no-results, .hide');

                /* scroll bar for exceeding browser edge when scrolling for list with less than 15 items */
                var scrollDestroyed = true;
                /* for list*/
                var scrollDestroyed2 = false;
                var dTop, dBottom, maxHeight, initialHeight = ul.height();

                scope.subscribe('closeAllDropdowns', function(ev){
                    var dds = $('.vmf-dropdown').find("ul");
                    var i;

                    for(i = 0; i < dds.length; i++) {
                        $(dds[i]).removeClass('active');
                        $(dds[i]).parents(".vmf-dropdown-content").removeClass('_active');
                        
                        if ($(dds[i]).is(":visible"))
                            $(dds[i]).hide();
                    }
                });
                
                scope.changeClass = function($event) {
                    if($($event.target).closest("div.yearDropDown").length === 0){
                      // checking if the clicked dropdown element is within filter or not
                        if( $($event.target).closest('ul.filterDropDown').length === 0 ){
                          //if the element is NOT in filterdropdown(length == 0), then close filterdropdown AND actions dropdown
                          scope.publish('closeAllFilters');
                          $document.trigger('click.actionsDropdown');
                        }else{
                          // if the element is in filterdropdown, then close the calendardropdown
                          $document.trigger('click.calendarDirective');
                        }
                        scope.publish('closeSelectPicker');
                    }

                    if(!angular.element($event.target).hasClass('form-control') && !angular.element($event.target).hasClass('jspDrag') && !angular.element($event.target).hasClass('jspTrack') && !(angular.element($event.target).parents('div[vm-template-insert]').length > 0)) {
                        var dds = $('.vmf-dropdown').find("ul");
                      
                        var i;
                        
                        var ul = elem.find('ul');

                        for(i = 0; i < dds.length; i++) {
                      
                            if(dds[i] !== ul.get(0)) {
                      
                                $(dds[i]).removeClass('active');
                                $(dds[i]).parents(".vmf-dropdown-content").removeClass('_active');
                                
                                if ($(dds[i]).is(":visible"))
                                    $(dds[i]).hide();
                            }
                        }
                    
                        if(elem.find('.vmf-dropdown-content').hasClass('_active')) {
                            elem.find('.vmf-dropdown-content').removeClass('_active');
                        }
                        else {
                            elem.find('.vmf-dropdown-content').addClass('_active');
                        }
                            
                        angular.element('.vmf-dropdown .vmf-dropdown-content').removeClass('has-error');
                        angular.element('.vmf-dropdown').find(".error-msg").remove();
                    
                        elem.find('span.current-selection').toggleClass('_active-drop');
                    
                        elem.find("ul").toggleClass('active');

                        $(elem[0]).closest('.form-group').toggleClass('active');

                        if (ul.is(":visible") || $event.which==undefined) { // $event.which is available for manual click, not for trigger() click
                            ul.hide();
                        }    
                        else {
                            resizeOptions();
                            searchBox.val("").trigger("keyup");
                            ul.show();
                            

                            $('.vmf-text-input > form.searchArea').removeClass('active');
                        }

                        /* scroll bar for exceeding browser edge when clicked on dropdown */

                        if(!scope.initializeScroll && elem.find("ul").hasClass('active')) {
                            

                            dTop = ul.offset().top - $document.scrollTop();
                            if($window.innerHeight) {
                                dBottom = $window.innerHeight - dTop - ul.height();
                            }
                            else {
                                /* falling back to jquery $(window) for IE 7, 8 */
                                dBottom = $(window).height() - dTop - ul.height();    
                            }    

                            if(dBottom < 0 && scrollDestroyed) {
                                maxHeight = ul.height() + dBottom;
                                ul.css('max-height', maxHeight);
                                /*scrollPane = ul.jScrollPane({
                                    autoReinitialise: true,
                                    showArrows: showDDArrows,
                                    verticalArrowPositions: 'after'
                                });*/
                            
                                //scrollPaneApi = scrollPane.data('jsp');
                                //scrollDestroyed = false;
                            }
                            else if(dBottom > 0 && !scrollDestroyed) {
                            
                                maxHeight = ul.height() + dBottom;

                                //scrollPaneApi.destroy();

                                ul = elem.find('ul');
                                ul.css('max-height', maxHeight);
                            
                                /*if(initialHeight > ul.height()) {
                                    scrollPane = ul.jScrollPane({
                                        autoReinitialise: true,
                                        showArrows: showDDArrows,
                                        verticalArrowPositions: 'after'
                                    });
                                
                                    scrollPaneApi = scrollPane.data('jsp');
                                    scrollDestroyed = false;
                                }
                                else {
                                    scrollDestroyed = true;    
                                }*/    
                            }
                            else if(dBottom < 0 && !scrollDestroyed) {
                            
                                maxHeight = ul.height() + dBottom;

                                //scrollPaneApi.destroy();

                                ul = elem.find('ul');
                                ul.css('max-height', maxHeight);
                            
                                /*if(initialHeight > ul.height()) {
                                    scrollPane = ul.jScrollPane({
                                        autoReinitialise: true,
                                        showArrows: showDDArrows,
                                        verticalArrowPositions: 'after'
                                    });
                                
                                    scrollPaneApi = scrollPane.data('jsp');
                                    scrollDestroyed = false;
                                }
                                else {
                                    scrollDestroyed = true;    
                                }*/    
                            }
                            
                        }
                        else if(scope.initializeScroll && elem.find("ul").hasClass('active')) {
                            

                            dTop = ul.offset().top - $document.scrollTop();
                            if($window.innerHeight) {
                                dBottom = $window.innerHeight - dTop - ul.height();
                            }
                            else {
                                /* falling back to jquery $(window) for IE 7, 8 */
                                dBottom = $(window).height() - dTop - ul.height();    
                            }    

                            if(dBottom < 0 && scrollDestroyed2) {
                                maxHeight = ul.height() + dBottom;
                                ul.css('max-height', maxHeight);
                                /*scrollPane = ul.jScrollPane({
                                    autoReinitialise: true,
                                    showArrows: showDDArrows,
                                    verticalArrowPositions: 'after'
                                });
                            
                                scrollPaneApi = scrollPane.data('jsp');
                                scrollDestroyed2 = false;*/
                            }
                            else if(dBottom > 0 && !scrollDestroyed2) {
                            
                                maxHeight = ul.height() + dBottom;
                                

                                   // scrollPaneApi.destroy();

                                    ul = elem.find('ul');
                                    ul.addClass('active');
                                    if(maxHeight < 350) {
                                        ul.css('max-height', maxHeight);
                                    }
                                    else {
                                        ul.css('max-height', 350);    
                                    }    
                                
                                    /*if(initialHeight >= ul.height()) {
                                        scrollPane = ul.jScrollPane({
                                            autoReinitialise: true,
                                            showArrows: showDDArrows,
                                            verticalArrowPositions: 'after'
                                        });
                                    
                                        scrollPaneApi = scrollPane.data('jsp');
                                        scrollDestroyed2 = false;
                                    }
                                    else {
                                        scrollDestroyed2 = true;    
                                    }*/    
                                    
                            }
                            else if(dBottom < 0 && !scrollDestroyed2) {
                            
                                maxHeight = ul.height() + dBottom;

                                //scrollPaneApi.destroy();

                                ul = elem.find('ul');
                                ul.addClass('active');
                                ul.css('max-height', maxHeight);
                            
                                /*if(initialHeight > ul.height()) {
                                    scrollPane = ul.jScrollPane({
                                        autoReinitialise: true,
                                        showArrows: showDDArrows,
                                        verticalArrowPositions: 'after'
                                    });
                                
                                    scrollPaneApi = scrollPane.data('jsp');
                                    scrollDestroyed2 = false;
                                }
                                else {
                                    scrollDestroyed2 = true;    
                                }*/    
                            }
                            
                        }
                        
                    }   

                    $event.stopPropagation();
                    
                };

                $document.on('click', function($event) {

                    if(!angular.element($event.target).hasClass('form-control') && !angular.element($event.target).hasClass('jspDrag') && !angular.element($event.target).hasClass('jspTrack')) {
         
                        elem.find('ul').removeClass('active');
                        elem.find('.vmf-dropdown .vmf-dropdown-content').removeClass('_active');

                        /* need to reinitialise ul as scroll may have been destroyed */
                        ul = elem.find('ul');
                        if (ul.is(':visible')) {
                            ul.hide();
                        }
                        $(elem[0]).closest('.form-group').removeClass('active');
                    }    

                });

                /*scroll bar for window resize */

                $window.onresize = function() {

                    if(!scope.initializeScroll && elem.find('ul').hasClass('active')) {
                        dTop = ul.offset().top - $document.scrollTop();
                        if($window.innerHeight) {
                            dBottom = $window.innerHeight - dTop - ul.height();
                        }
                        else {
                            /* falling back to jquery $(window) for IE 7, 8 */
                            dBottom = $(window).height() - dTop - ul.height();    
                        }    

                        /*if(dBottom < 0 && scrollDestroyed) {
                            maxHeight = ul.height() + dBottom;
                            ul.css('max-height', maxHeight);
                            scrollPane = ul.jScrollPane({
                                autoReinitialise: true,
                                showArrows: showDDArrows,
                                verticalArrowPositions: 'after'
                            });
                        
                            scrollPaneApi = scrollPane.data('jsp');
                            scrollDestroyed = false;
                        }
                        else if(dBottom > 0 && !scrollDestroyed) {
                        
                            maxHeight = ul.height() + dBottom;

                            scrollPaneApi.destroy();

                            ul = elem.find('ul');
                            ul.css('max-height', maxHeight);
                        
                            if(initialHeight > ul.height()) {
                                scrollPane = ul.jScrollPane({
                                    autoReinitialise: true,
                                    showArrows: showDDArrows,
                                    verticalArrowPositions: 'after'
                                });
                            
                                scrollPaneApi = scrollPane.data('jsp');
                                scrollDestroyed = false;
                            }
                            else {
                                scrollDestroyed = true;    
                            }    
                        }
                        else if(dBottom < 0 && !scrollDestroyed) {
                        
                            maxHeight = ul.height() + dBottom;

                            scrollPaneApi.destroy();

                            ul = elem.find('ul');
                            ul.css('max-height', maxHeight);
                        
                            if(initialHeight > ul.height()) {
                                scrollPane = ul.jScrollPane({
                                    autoReinitialise: true,
                                    showArrows: showDDArrows,
                                    verticalArrowPositions: 'after'
                                });
                            
                                scrollPaneApi = scrollPane.data('jsp');
                                scrollDestroyed = false;
                            }
                            else {
                                scrollDestroyed = true;    
                            }    
                        }*/

                    }
                    else if(scope.initializeScroll && elem.find("ul").hasClass('active')) {
                        

                        dTop = ul.offset().top - $document.scrollTop();
                        if($window.innerHeight) {
                            dBottom = $window.innerHeight - dTop - ul.height();
                        }
                        else {
                            /* falling back to jquery $(window) for IE 7, 8 */
                            dBottom = $(window).height() - dTop - ul.height();    
                        }    

                        if(dBottom < 0 && scrollDestroyed2) {
                            maxHeight = ul.height() + dBottom;
                            ul.css('max-height', maxHeight);
                            /*scrollPane = ul.jScrollPane({
                                autoReinitialise: true,
                                showArrows: showDDArrows,
                                verticalArrowPositions: 'after'
                            });
                        
                            scrollPaneApi = scrollPane.data('jsp');
                            scrollDestroyed2 = false;*/
                        }
                        else if(dBottom > 0 && !scrollDestroyed2) {
                        
                            maxHeight = ul.height() + dBottom;
                            

                                //scrollPaneApi.destroy();

                                ul = elem.find('ul');
                                if(maxHeight < 350) {
                                    ul.css('max-height', maxHeight);
                                }
                                else {
                                    ul.css('max-height', 350);    
                                }    
                            
                                /*if(initialHeight >= ul.height()) {
                                    scrollPane = ul.jScrollPane({
                                        autoReinitialise: true,
                                        showArrows: showDDArrows,
                                        verticalArrowPositions: 'after'
                                    });
                                
                                    scrollPaneApi = scrollPane.data('jsp');
                                    scrollDestroyed2 = false;
                                }
                                else {
                                    scrollDestroyed2 = true;    
                                }    */
                                
                        }
                        else if(dBottom < 0 && !scrollDestroyed2) {
                        
                            maxHeight = ul.height() + dBottom;

                            //scrollPaneApi.destroy();

                            ul = elem.find('ul');
                            ul.addClass('active');
                            ul.css('max-height', maxHeight);
                        
                            /*if(initialHeight > ul.height()) {
                                scrollPane = ul.jScrollPane({
                                    autoReinitialise: true,
                                    showArrows: showDDArrows,
                                    verticalArrowPositions: 'after'
                                });
                            
                                scrollPaneApi = scrollPane.data('jsp');
                                scrollDestroyed2 = false;
                            }
                            else {
                                scrollDestroyed2 = true;    
                            }    */
                        }
                        
                    }
                    resizeOptions();
                };

                /* scroll bar for exceeding browser edge when scrolling */

                /*angular.element($window).on('scroll', function($event) {
                    
                    if($event.target.nodeName === '#document') {
                        
                        if(!scope.initializeScroll && elem.find('ul').hasClass('active')) {
                            dTop = ul.offset().top - $document.scrollTop();
                            if($window.innerHeight) {
                                dBottom = $window.innerHeight - dTop - ul.height();
                            }
                            else {
                                // falling back to jquery $(window) for IE 7, 8 
                                dBottom = $(window).height() - dTop - ul.height();    
                            }    

                            if(dBottom < 0 && scrollDestroyed) {
                                maxHeight = ul.height() + dBottom;
                                ul.css('max-height', maxHeight);
                                scrollPane = ul.jScrollPane({
                                    autoReinitialise: true,
                                    showArrows: showDDArrows,
                                    verticalArrowPositions: 'after'
                                });
                            
                                scrollPaneApi = scrollPane.data('jsp');
                                scrollDestroyed = false;
                            }
                            else if(dBottom > 0 && !scrollDestroyed) {
                            
                                maxHeight = ul.height() + dBottom;

                                scrollPaneApi.destroy();

                                ul = elem.find('ul');
                                ul.css('max-height', maxHeight);
                            
                                if(initialHeight > ul.height()) {
                                    scrollPane = ul.jScrollPane({
                                        autoReinitialise: true,
                                        showArrows: showDDArrows,
                                        verticalArrowPositions: 'after'
                                    });
                                
                                    scrollPaneApi = scrollPane.data('jsp');
                                    scrollDestroyed = false;
                                }
                                else {
                                    scrollDestroyed = true;    
                                }    
                            }
                            else if(dBottom < 0 && !scrollDestroyed) {
                            
                                maxHeight = ul.height() + dBottom;

                                scrollPaneApi.destroy();

                                ul = elem.find('ul');
                                ul.css('max-height', maxHeight);
                            
                                if(initialHeight > ul.height()) {
                                    scrollPane = ul.jScrollPane({
                                        autoReinitialise: true,
                                        showArrows: showDDArrows,
                                        verticalArrowPositions: 'after'
                                    });
                                
                                    scrollPaneApi = scrollPane.data('jsp');
                                    scrollDestroyed = false;
                                }
                                else {
                                    scrollDestroyed = true;    
                                }    
                            }

                        }
                        else if(scope.initializeScroll && elem.find("ul").hasClass('active')) {
                            

                            dTop = ul.offset().top - $document.scrollTop();
                            if($window.innerHeight) {
                                dBottom = $window.innerHeight - dTop - ul.height();
                            }
                            else {
                                // falling back to jquery $(window) for IE 7, 8 
                                dBottom = $(window).height() - dTop - ul.height();    
                            }    

                            if(dBottom < 0 && scrollDestroyed2) {
                                maxHeight = ul.height() + dBottom;
                                ul.css('max-height', maxHeight);
                                scrollPane = ul.jScrollPane({
                                    autoReinitialise: true,
                                    showArrows: showDDArrows,
                                    verticalArrowPositions: 'after'
                                });
                            
                                scrollPaneApi = scrollPane.data('jsp');
                                scrollDestroyed2 = false;
                            }
                            else if(dBottom > 0 && !scrollDestroyed2) {
                            
                                maxHeight = ul.height() + dBottom;
                                

                                    scrollPaneApi.destroy();

                                    ul = elem.find('ul');
                                    if(maxHeight < 350) {
                                        ul.css('max-height', maxHeight);
                                    }
                                    else {
                                        ul.css('max-height', 350);    
                                    }    
                                
                                    if(initialHeight >= ul.height()) {
                                        scrollPane = ul.jScrollPane({
                                            autoReinitialise: true,
                                            showArrows: showDDArrows,
                                            verticalArrowPositions: 'after'
                                        });
                                    
                                        scrollPaneApi = scrollPane.data('jsp');
                                        scrollDestroyed2 = false;
                                    }
                                    else {
                                        scrollDestroyed2 = true;    
                                    }    
                                    
                            }
                            else if(dBottom < 0 && !scrollDestroyed2) {
                            
                                maxHeight = ul.height() + dBottom;

                                scrollPaneApi.destroy();

                                ul = elem.find('ul');
                                ul.addClass('active');
                                ul.css('max-height', maxHeight);
                            
                                if(initialHeight > ul.height()) {
                                    scrollPane = ul.jScrollPane({
                                        autoReinitialise: true,
                                        showArrows: showDDArrows,
                                        verticalArrowPositions: 'after'
                                    });
                                
                                    scrollPaneApi = scrollPane.data('jsp');
                                    scrollDestroyed2 = false;
                                }
                                else {
                                    scrollDestroyed2 = true;    
                                }    
                            }
                            
                        }
                    }
                });  */          


                if(typeof scope.preSelectInd !== 'undefined') {
                    
                    if(scope.list && scope.list[0] && typeof scope.list[0] === 'object') {
                        scope.model = scope.list[scope.preSelectInd].value;
                    }
                    else {
                        scope.model = scope.list[scope.preSelectInd];   
                    }    
                    
                    var list2 = elem.find('li');

                    angular.element(list2[scope.preSelectInd]).addClass('dd-opt-selected');                    
                }

                scope.select = function($event) {
                    var opt = $event.currentTarget;

                    if(sub) {
                        elem.find('span.current-selection').text($(opt).text());
                    }    
                    scope.model = $(opt).text(); 
                    
                    var list = elem.find('li'); 
                    angular.forEach(list, function(item) {
                        
                        angular.element(item).removeClass('dd-opt-selected');
                    });

                    angular.element(opt).addClass('dd-opt-selected');

                    scope.$emit('vmfDDOptionClicked', $event);

                    if( scope.customeventname ){
                        scope.publish(scope.customeventname, scope.model, $event);
                    }
                };

                scope.selectObj = function($event, index) {
                    var opt = $event.currentTarget;
                    //to be removed
                    if(attrs.dropdownType = 'with_submenu'){
                        //console.log(scope.list[index].text);
                    }

                    if(sub) {
                        elem.find('span.current-selection').text($(opt).text());
                    }    

                    scope.model = scope.list[index].value; 
                    var list = elem.find('li'); 

                    angular.forEach(list, function(item) {
                        
                        angular.element(item).removeClass('dd-opt-selected');
                    });

                    angular.element(opt).addClass('dd-opt-selected');

                    scope.$emit('vmfDDOptionClicked', $event);

                    if( scope.customeventname ){
                      scope.publish(scope.customeventname, {
                        value: scope.list[index].value,
                        inputId: scope.list[index].inputId
                      });
                    }
                };

                // scope.selectSubMenuObj = function($event, index){
                //     var opt = $event.currentTarget;
                //     if(sub) {
                //         elem.find('span.current-selection').text($(opt).text());
                //     }    
                // }

                scope.mouseOverObj = function($event, index){

                    if(attrs.dropdownType = 'with_submenu'){
                        //console.log(scope.list[index].submenu);
                    }
                    if($($event.target).hasClass('main-menu')){
                        elem.find(".submenu_container").remove()
                    }
                    var subMenu_Template = '<ul style="display: block; width: 100%; left: 100%;position : absolute;" class="active submenu_container">';
                    angular.forEach(scope.list[index].submenu, function(item, ind) {
                        var itemText = item.text;
                        subMenu_Template += '<li ';
                        subMenu_Template += 'ng-click="selectObj($event,' + index + ',' + ind + ');"';
                        subMenu_Template += 'title="' + item.text +'">' + itemText + '</li>';

                    });

                    subMenu_Template += '</ul>';

                    //elem.find(".dropDownListItems").append(subMenu_Template);
                    if($($event.target).hasClass('main-menu')){
                        $($event.target).append(subMenu_Template);
                    }

                };
                /*
                * fallback event - ng-click events do not propagate on some occassions when dropdown is integrated 
                * with other components
                */

                scope.$on('vmfDDOptionClicked', function(customEvent, $event) {
                    scope.changeClass($event);
                    customEvent.stopPropagation();
                });

                scope.selectByKey = function($event, index) {
                    var currentOptions = elem.find('li').not('.no-results, .hide');
                    if(sub) {
                        elem.find('span.current-selection').text($(currentOptions[index]).text());
                    }    

                    if(scope.list && scope.list[0] &&  typeof scope.list[0] === 'object') {
                        scope.model = scope.list[index].value;
                    }
                    else {
                        scope.model = scope.list[index];
                    }
                        
                    var list = elem.find('li');
                    angular.forEach(list, function(item) {
                        
                        angular.element(item).removeClass('dd-opt-selected');
                    });

                    angular.element(currentOptions[index]).addClass('dd-opt-selected');
                };


                scope.currentIndex = -1;
                var lowestEleIndex = 14;

                scope.keyPressTitle = function($event) {
                    
                    var list = elem.find('li').not(".no-results, .hide");

                    if($event.which === 40) {
                        $event.preventDefault();

                        if(scope.currentIndex < list.length - 1) {

                            scope.currentIndex += 1;
                            scope.selectByKey($event, scope.currentIndex);
                            if(scope.currentIndex >= 15) {
                                //scrollPaneApi.scrollToElement(list[scope.currentIndex]);
                                lowestEleIndex = scope.currentIndex;
                            }
                        }
                    
                    }

                    else if($event.which === 38) {
                        $event.preventDefault();

                        if(scope.currentIndex > 0) {
                            scope.currentIndex -= 1;
                            scope.selectByKey($event, scope.currentIndex);
                            if(lowestEleIndex - scope.currentIndex >= 15) {
                                //scrollPaneApi.scrollToElement(list[scope.currentIndex]);
                                lowestEleIndex -= 1;
                            }
                        }
                    
                    }

                    else if($event.which === 13 && ul.hasClass('active')) {
                        elem.find('.vmf-dropdown-content').removeClass('_active');
                        elem.find('.current-selection').removeClass('_active-drop');
                        ul.removeClass('active');
                        ul.hide();
                    }

                    else if(($event.which >= 48 && $event.which <= 57) || ($event.which >= 65 && $event.which <= 90) || ($event.which >= 97 && $event.which <= 122)) {
                        
                        var i, text, matchingIndex = -1;
                        if(scope.list && scope.list[0] &&  typeof scope.list[0] === 'object') {
                            for(i = scope.currentIndex + 1; i < scope.list.length; i++) {
                                text = scope.list[i].text;
                                
                                if(text.charCodeAt(0) === $event.which) {
                                    matchingIndex = i;
                                    break;
                                }
                                
                            }
                            
                            if(matchingIndex === -1) {
                                for(i = 0; i < scope.currentIndex; i++) {
                                    text = scope.list[i].text;
                                    
                                    if(text.charCodeAt(0) === $event.which) {
                                        matchingIndex = i;
                                        break;
                                    }
                                    
                                }    
                            }

                            if(matchingIndex !== -1) {
                                if(sub) {
                                    elem.find('span.current-selection').text(text);
                                }    

                                scope.model = scope.list[matchingIndex].value; 
                                scope.currentIndex = matchingIndex;

                                list = elem.find('li'); 

                                angular.forEach(list, function(item) {
                                    
                                    angular.element(item).removeClass('dd-opt-selected');
                                });

                                angular.element(elem.find('li').not(".no-results, .hide")[matchingIndex]).addClass('dd-opt-selected');

                                matchingIndex = -1;
                            }        
    
                        }

                        else if(scope.list && scope.list[0]){
                            for(i = scope.currentIndex + 1; i < scope.list.length; i++) {
                                if(scope.list && scope.list[0] &&  typeof scope.list[0] !== 'string') {
                                    text = scope.list[i].toString();
                                }
                                else {
                                    text = scope.list[i];    
                                }
                                
                                if(text.charCodeAt(0) === $event.which) {
                                    matchingIndex = i;
                                    break;
                                }
                                
                            }

                            if(matchingIndex === -1) {
                                for(i = 0; i < scope.currentIndex; i++) {
                                    text = scope.list[i].toString();
                                    
                                    if(text.charCodeAt(0) === $event.which) {
                                        matchingIndex = i;
                                        break;
                                    }
                                    
                                }    
                            }

                            if(matchingIndex !== -1) {
                                if(sub) {
                                    elem.find('span.current-selection').text(text);
                                }    
                                
                                scope.model = scope.list[i]; 
                                scope.currentIndex = i;
                                
                                list = elem.find('li'); 
                                angular.forEach(list, function(item) {
                                    angular.element(item).removeClass('dd-opt-selected');
                                });
                                angular.element(elem.find('li').not(".no-results, .hide")[i]).addClass('dd-opt-selected');
                                matchingIndex = -1;

                            }    

                        }                            

                    }

                };

                scope.$watch('model', function(n,o) {
                    if(n === null && sub) {
                        $timeout(function() {
                            if(attrs.htitle ==='' || attrs.htitle) {
                                elem.find('span.current-selection').text(scope.htitle);
                            }
                            else {
                                elem.find('span.current-selection').text('Select');    
                            }
                            elem.find('li').removeClass('dd-opt-selected');                     
                        });    

                    }
                });

            }
        };
    }
])
.directive('vmTemplateInsert', ['$compile', '$document', '$window', '$timeout',
    function($compile, $document, $window, $timeout) {
        return {
            restrict: 'A',
            scope: {
                template : '@',
            },
            controller : '@',
            name:"controllerName",
            //hack to get controller name to be set.
            template : '<div ng-include = "getTemplate()" style = "display:table;"></div>',
            link : function(scope,element,attrs){
                    //hack to get template from the scope that is passed.
                    scope.getTemplate = function(){
                        return scope.template;
                    }
                }
        }
    }
])
.directive('vmfSelectListEaDropdown', ['$compile', '$document', '$window', '$timeout','globalData',
    function($compile, $document, $window, $timeout, globalData) {
        return {
            restrict: 'EA',
            scope: {
                dtitle: '@',        // dropdown title on left side
                model: '=',
                list: '=',
                sortby: '@',
                mandatory: '@',
                customClass:'=',
                htitle:'@',         // dropdown header/button title
                sub:'=',            // false if selected value should not substitute header title but shown somewhere else otherwise true by default 
                preSelectInd: '=',  // pre selected value in dropdown
                titleColMod:'@',
                selectColMod:'@',
                showArrows : '@'
            },

            link: function(scope, elem, attrs) { 
                
        if(typeof scope.sortby === "undefined"){
                        scope.sortby=attrs.sortby;
                }
                
                if(typeof scope.list[0] === 'string') {
                    scope.list.sort();

                }
                else if(typeof scope.list[0] === 'number') {
                    scope.list.sort(function (a, b) {return a - b;});
                }
                else if(typeof scope.list[0] === 'object') {
                
                    if(scope.sortby) {
                
                        if(typeof scope.list[0].eaNumber === 'number') {
                            scope.list.sort(function (a, b) {return a.eaNumber - b.eaNumber;});
                        }
                        else if(typeof scope.list[0].eaNumber === 'string') {

                            scope.list.sort(function (a, b) {
                                if(a.eaNumber < b.eaNumber) {
                                    return -1;
                                }
                                else if(a.eaNumber > b.eaNumber) {
                                    return 1;
                                }
                                else {
                                    return 0;
                                }
                            });
                        }

                    }
                    else {
                        scope.list.sort(function (a, b) {
                            if(a.text < b.text) {
                                return -1;
                            }
                            else if(a.text > b.text) {
                                return 1;
                            }
                            else {
                                return 0;
                            }
                        });
                    }
                    angular.forEach(scope.list, function(item,ind) {
                          if( item.eaNumber === eaSelectorJSON.defaultEANumber ){
                            var value = scope.list.splice( ind, 1 )[0];
                            scope.list.unshift(value)
                          }
                    });
                }

                scope.initializeScroll = false;

                var template;
                var titleColMod = typeof scope.titleColMod !== "undefined" ? scope.titleColMod : 'col-md-2';
                var selectColMod = typeof scope.selectColMod !== "undefined" ? scope.selectColMod : 'col-md-4';
                var showDDArrows = typeof scope.showArrows !== "undefined" ? scope.showArrows : true;
                var titlePrefix = typeof attrs.titleprefix !== "undefined" ? attrs.titleprefix+" " : "";
                var sub = typeof scope.sub !== "undefined" ? scope.sub : true;

                if(scope.mandatory === 'true') {
                    if(scope.dtitle) {
                        if(attrs.htitle ==='' || attrs.htitle) {
                            template = '<div class="vmf_drop-down_text"><label class="labelHeader formLabel '+titleColMod+' col-xs-12"><span class="mandatory">*</span>{{dtitle}}</label><div tabindex="0" class="vmf-dropdown '+selectColMod+' col-xs-12" ng-keyDown="keyPressTitle($event);" ng-click="changeClass($event);"><div class="vmf-dropdown-content"><span class="current-selection">{{htitle}}</span><ul class="dropDownListItems">';
                           
                        }
                        else if(typeof scope.preSelectInd !== 'undefined') {
                            if(typeof scope.list[0] === 'object') {
                                template = '<div class="vmf_drop-down_text"><label class="labelHeader formLabel '+titleColMod+' col-xs-12"><span class="mandatory">*</span>{{dtitle}}</label><div tabindex="0" class="vmf-dropdown '+selectColMod+' col-xs-12" ng-keyDown="keyPressTitle($event);" ng-click="changeClass($event);"><div class="vmf-dropdown-content"><span class="current-selection">' + titlePrefix + scope.list[scope.preSelectInd].eaNumber  + " - "+scope.list[scope.preSelectInd].eaName + '</span><ul class="dropDownListItems">';                       
                            }
                            else {
                                template = '<div class="vmf_drop-down_text"><label class="labelHeader formLabel '+titleColMod+' col-xs-12"><span class="mandatory">*</span>{{dtitle}}</label><div tabindex="0" class="vmf-dropdown '+selectColMod+' col-xs-12" ng-keyDown="keyPressTitle($event);" ng-click="changeClass($event);"><div class="vmf-dropdown-content"><span class="current-selection">' + scope.list[scope.preSelectInd] + '</span><ul class="dropDownListItems">';   
                            }    
                        }
                        else {
                            template = '<div class="vmf_drop-down_text"><label class="labelHeader formLabel '+titleColMod+' col-xs-12"><span class="mandatory">*</span>{{dtitle}}</label><div tabindex="0" class="vmf-dropdown '+selectColMod+' col-xs-12" ng-keyDown="keyPressTitle($event);" ng-click="changeClass($event);"><div class="vmf-dropdown-content"><span class="current-selection">Select</span><ul class="dropDownListItems">';
                        }

                    }
                    else {
                        if(attrs.htitle ==='' || attrs.htitle) {
                            template = '<div class="vmf_drop-down_text"><span class="mandatory">*</span><div tabindex="0" class="vmf-dropdown '+selectColMod+' col-xs-12" ng-keyDown="keyPressTitle($event);" ng-click="changeClass($event);"><div class="vmf-dropdown-content"><span class="current-selection">{{htitle}}</span><ul class="dropDownListItems">';
                           
                        }
                        else if(typeof scope.preSelectInd !== 'undefined') {
                            if(typeof scope.list[0] === 'object') {
                                template = '<div class="vmf_drop-down_text"><span class="mandatory">*</span><div tabindex="0" class="vmf-dropdown '+selectColMod+' col-xs-12" ng-keyDown="keyPressTitle($event);" ng-click="changeClass($event);"><div class="vmf-dropdown-content"><span class="current-selection">' + titlePrefix + scope.list[scope.preSelectInd].eaNumber  + " - "+scope.list[scope.preSelectInd].eaName + '</span><ul class="dropDownListItems">';                       
                            }
                            else {
                                template = '<div class="vmf_drop-down_text"><span class="mandatory">*</span><div tabindex="0" class="vmf-dropdown '+selectColMod+' col-xs-12" ng-keyDown="keyPressTitle($event);" ng-click="changeClass($event);"><div class="vmf-dropdown-content"><span class="current-selection">' + scope.list[scope.preSelectInd] + '</span><ul class="dropDownListItems">';   
                            }    
                        }

                        else {

                            template = '<div class="vmf_drop-down_text"><span class="mandatory">*</span><div tabindex="0" class="vmf-dropdown '+selectColMod+' col-xs-12" ng-keyDown="keyPressTitle($event);" ng-click="changeClass($event);"><div class="vmf-dropdown-content"><span class="current-selection">Select</span><ul class="dropDownListItems">';   
                        }
                    }
                }

                else {
                    if(scope.dtitle) {
                        if(attrs.htitle ==='' || attrs.htitle) {
                            template = '<div class="vmf_drop-down_text"><label class="labelHeader formLabel '+titleColMod+' col-xs-12">{{dtitle}}</label><div tabindex="0" class="vmf-dropdown '+selectColMod+' col-xs-12" ng-keyDown="keyPressTitle($event);" ng-click="changeClass($event);"><div class="vmf-dropdown-content"><span class="current-selection">{{htitle}}</span><ul class="dropDownListItems">';
                        }
                        else if(typeof scope.preSelectInd !== 'undefined') {
                            if(typeof scope.list[0] === 'object') {
                                template = '<div class="vmf_drop-down_text"><label class="labelHeader formLabel '+titleColMod+' col-xs-12">{{dtitle}}</label><div tabindex="0" class="vmf-dropdown '+selectColMod+' col-xs-12" ng-keyDown="keyPressTitle($event);" ng-click="changeClass($event);"><div class="vmf-dropdown-content"><span class="current-selection">' + titlePrefix + scope.list[scope.preSelectInd].eaNumber  + " - "+scope.list[scope.preSelectInd].eaName + '</span><ul class="dropDownListItems">';                       
                            }
                            else {
                                template = '<div class="vmf_drop-down_text"><label class="labelHeader formLabel '+titleColMod+' col-xs-12">{{dtitle}}</label><div tabindex="0" class="vmf-dropdown '+selectColMod+' col-xs-12" ng-keyDown="keyPressTitle($event);" ng-click="changeClass($event);"><div class="vmf-dropdown-content"><span class="current-selection">' + scope.list[scope.preSelectInd] + '</span><ul class="dropDownListItems">';   
                            }    
                        }
                        else {
                            template = '<div class="vmf_drop-down_text"><label class="labelHeader formLabel '+titleColMod+' col-xs-12">{{dtitle}}</label><div tabindex="0" class="vmf-dropdown '+selectColMod+' col-xs-12" ng-keyDown="keyPressTitle($event);" ng-click="changeClass($event);"><div class="vmf-dropdown-content"><span class="current-selection">Select</span><ul class="dropDownListItems">';
                        }
                        
                    } 
                    else {
                        if(attrs.htitle ==='' || attrs.htitle) {
                            template = '<div class="vmf_drop-down_text"><div tabindex="0" class="vmf-dropdown '+selectColMod+' col-xs-12" ng-keyDown="keyPressTitle($event);" ng-click="changeClass($event);"><div class="vmf-dropdown-content"><span class="current-selection">{{htitle}}</span><ul id="dropDownListItems">';
                        }
                        
                        else if(typeof scope.preSelectInd !== 'undefined') {
                            if(typeof scope.list[0] === 'object') {
                                var eaSelectorToBeSelected = eaSelectorJSON.selectedEANumber || eaSelectorJSON.defaultEANumber;
                                angular.forEach(scope.list, function(item,ind) {
                                  if( item.eaNumber === eaSelectorToBeSelected ){
                                    scope.preSelectInd = ind;
                                  }
                                });

                                template = '<div class="vmf_drop-down_text"><div tabindex="0" class="vmf-dropdown '+selectColMod+' col-xs-12" ng-keyDown="keyPressTitle($event);" ng-click="changeClass($event);"><div class="vmf-dropdown-content"><span class="current-selection">'+ titlePrefix + scope.list[scope.preSelectInd].eaNumber  + " - "+scope.list[scope.preSelectInd].eaName +'</span><ul class="dropDownListItems">';   
                            }
                            else {                              
                                template = '<div class="vmf_drop-down_text"><div tabindex="0" class="vmf-dropdown '+selectColMod+' col-xs-12" ng-keyDown="keyPressTitle($event);" ng-click="changeClass($event);"><div class="vmf-dropdown-content"><span class="current-selection">'+ scope.list[scope.preSelectInd] +'</span><ul class="dropDownListItems">';   
                            }
                                
                        }    
                        else {

                            template = '<div class="vmf_drop-down_text"><div tabindex="0" class="vmf-dropdown '+selectColMod+' col-xs-12" ng-keyDown="keyPressTitle($event);" ng-click="changeClass($event);"><div class="vmf-dropdown-content"><span class="current-selection">Select</span><ul class="dropDownListItems">';   
                        }    
                    }
                }

                if (typeof scope.list[0] === 'object') {

                    angular.forEach(scope.list, function(item,ind) {
                            template += '<li data-ea-display-name="' +item.eaNumber +' - ' + item.eaName + '" ng-click="selectObj($event,' + ind + ');"  title= "' +item.eaNumber +' - ' + item.eaName + '"><span class="eaText">' + item.eaNumber +" - " + item.eaName + '</span></li>';
                    });
                } 
                else {

                    angular.forEach(scope.list, function(item) {
                        template += '<li ng-click="select($event);">' + item + '</li>';
                    });
                }

                template += '</ul></div></div></div>';

                elem.append(template);

                if(scope.customClass){
                    angular.forEach(scope.customClass, function(item) {
                        elem.find(item.selector).addClass(item.cusclass);


                    });
                }

                $compile(elem.contents())(scope);

                if(scope.list.length > 15) {
                    scope.initializeScroll = true;
                }

                var ul = elem.find('ul');
                
                var scrollPane, scrollPaneApi;

                /*if(scope.initializeScroll) {
                    
                        
                    scrollPane = ul.jScrollPane({
                        autoReinitialise: true,
                        showArrows: showDDArrows,
                        verticalArrowPositions: 'after'
                    });
                

                    scrollPaneApi = scrollPane.data('jsp');
                }*/


                var currentSelection = elem.find('span.current-selection');

                ul.hide();

                var options = elem.find('li');

                /* scroll bar for exceeding browser edge when scrolling for list with less than 15 items */
                var scrollDestroyed = true;
                /* for list*/
                var scrollDestroyed2 = false;
                var dTop, dBottom, maxHeight, initialHeight = ul.height();

                scope.subscribe('closeAllDropdowns', function(ev){
                    var dds = $('.vmf-dropdown').find("ul");
                    var i;

                    for(i = 0; i < dds.length; i++) {
                        $(dds[i]).removeClass('active');
                        $(dds[i]).parents(".vmf-dropdown-content").removeClass('_active');
                        
                        if ($(dds[i]).is(":visible"))
                            $(dds[i]).hide();
                    }
                });

                scope.changeClass = function($event) {
                    
                    if($($event.target).closest("div.yearDropDown").length === 0){
                      // checking if the clicked dropdown element is within filter or not
                        if( $($event.target).closest('ul.filterDropDown').length === 0 ){
                          //if the element is NOT in filterdropdown(length == 0), then close filterdropdown AND actions dropdown
                          scope.publish('closeAllFilters');
                          $document.trigger('click.actionsDropdown');
                        }else{
                          // if the element is in filterdropdown, then close the calendardropdown
                          $document.trigger('click.calendarDirective');
                        }
                        scope.publish('closeSelectPicker');
                    }

                    if(!angular.element($event.target).hasClass('jspDrag') && !angular.element($event.target).hasClass('jspTrack')) {
                        var dds = $('.vmf-dropdown').find("ul");
                      
                        var i;
                        
                        var ul = elem.find('ul');

                        for(i = 0; i < dds.length; i++) {
                      
                            if(dds[i] !== ul.get(0)) {
                      
                                $(dds[i]).removeClass('active');
                                $(dds[i]).parents(".vmf-dropdown-content").removeClass('_active');
                                
                                if ($(dds[i]).is(":visible"))
                                    $(dds[i]).hide();
                            }
                        }
                    
                        if(elem.find('.vmf-dropdown-content').hasClass('_active')) {
                            elem.find('.vmf-dropdown-content').removeClass('_active');
                        }
                        else {
                            elem.find('.vmf-dropdown-content').addClass('_active');
                        }
                            
                        angular.element('.vmf-dropdown .vmf-dropdown-content').removeClass('has-error');
                        angular.element('.vmf-dropdown').find(".error-msg").remove();
                    
                        elem.find('span.current-selection').toggleClass('_active-drop');
                    
                        elem.find("ul").toggleClass('active');

                        $(elem[0]).closest('.form-group').toggleClass('active');

                        if (ul.is(":visible")) {
                            ul.hide();
                        }    
                        else {
                            ul.show();
                            

                            $('.vmf-text-input > form.searchArea').removeClass('active');
                        }

                        /* scroll bar for exceeding browser edge when clicked on dropdown */

                        if(!scope.initializeScroll && elem.find("ul").hasClass('active')) {
                            

                            dTop = ul.offset().top - $document.scrollTop();
                            if($window.innerHeight) {
                                dBottom = $window.innerHeight - dTop - ul.height();
                            }
                            else {
                                /* falling back to jquery $(window) for IE 7, 8 */
                                dBottom = $(window).height() - dTop - ul.height();    
                            }    

                            if(dBottom < 0 && scrollDestroyed) {
                                maxHeight = ul.height() + dBottom;
                                ul.css('max-height', maxHeight);
                                /*scrollPane = ul.jScrollPane({
                                    autoReinitialise: true,
                                    showArrows: showDDArrows,
                                    verticalArrowPositions: 'after'
                                });
                            
                                scrollPaneApi = scrollPane.data('jsp');*/
                                scrollDestroyed = false;
                            }
                            else if(dBottom > 0 && !scrollDestroyed) {
                            
                                maxHeight = ul.height() + dBottom;

                                //scrollPaneApi.destroy();

                                ul = elem.find('ul');
                                ul.css('max-height', maxHeight);
                            
                                /*if(initialHeight > ul.height()) {
                                    scrollPane = ul.jScrollPane({
                                        autoReinitialise: true,
                                        showArrows: showDDArrows,
                                        verticalArrowPositions: 'after'
                                    });
                                
                                    scrollPaneApi = scrollPane.data('jsp');
                                    scrollDestroyed = false;
                                }
                                else {
                                    scrollDestroyed = true;    
                                }   */ 
                            }
                            else if(dBottom < 0 && !scrollDestroyed) {
                            
                                maxHeight = ul.height() + dBottom;

                                //scrollPaneApi.destroy();

                                ul = elem.find('ul');
                                ul.css('max-height', maxHeight);
                            
                                /*if(initialHeight > ul.height()) {
                                    scrollPane = ul.jScrollPane({
                                        autoReinitialise: true,
                                        showArrows: showDDArrows,
                                        verticalArrowPositions: 'after'
                                    });
                                
                                    scrollPaneApi = scrollPane.data('jsp');
                                    scrollDestroyed = false;
                                }
                                else {
                                    scrollDestroyed = true;    
                                }   */ 
                            }
                            
                        }
                        else if(scope.initializeScroll && elem.find("ul").hasClass('active')) {
                            

                            dTop = ul.offset().top - $document.scrollTop();
                            if($window.innerHeight) {
                                dBottom = $window.innerHeight - dTop - ul.height();
                            }
                            else {
                                /* falling back to jquery $(window) for IE 7, 8 */
                                dBottom = $(window).height() - dTop - ul.height();    
                            }    

                            if(dBottom < 0 && scrollDestroyed2) {
                                maxHeight = ul.height() + dBottom;
                                ul.css('max-height', maxHeight);
                               /* scrollPane = ul.jScrollPane({
                                    autoReinitialise: true,
                                    showArrows: showDDArrows,
                                    verticalArrowPositions: 'after'
                                });
                            
                                scrollPaneApi = scrollPane.data('jsp');*/
                                scrollDestroyed2 = false;
                            }
                            else if(dBottom > 0 && !scrollDestroyed2) {
                            
                                maxHeight = ul.height() + dBottom;
                                

                                    //scrollPaneApi.destroy();

                                    ul = elem.find('ul');
                                    ul.addClass('active');
                                    if(maxHeight < 350) {
                                        ul.css('max-height', maxHeight);
                                    }
                                    else {
                                        ul.css('max-height', 350);    
                                    }    
                                
                                   /* if(initialHeight >= ul.height()) {
                                        scrollPane = ul.jScrollPane({
                                            autoReinitialise: true,
                                            showArrows: showDDArrows,
                                            verticalArrowPositions: 'after'
                                        });
                                    
                                        scrollPaneApi = scrollPane.data('jsp');
                                        scrollDestroyed2 = false;
                                    }
                                    else {
                                        scrollDestroyed2 = true;    
                                    }    */
                                    
                            }
                            else if(dBottom < 0 && !scrollDestroyed2) {
                            
                                maxHeight = ul.height() + dBottom;

                                //scrollPaneApi.destroy();

                                ul = elem.find('ul');
                                ul.addClass('active');
                                ul.css('max-height', maxHeight);
                            
                               /* if(initialHeight > ul.height()) {
                                    scrollPane = ul.jScrollPane({
                                        autoReinitialise: true,
                                        showArrows: showDDArrows,
                                        verticalArrowPositions: 'after'
                                    });
                                
                                    scrollPaneApi = scrollPane.data('jsp');
                                    scrollDestroyed2 = false;
                                }
                                else {
                                    scrollDestroyed2 = true;    
                                }    */
                            }
                            
                        }
                        
                    }   

                    $event.stopPropagation();
                    
                };

                $document.on('click', function($event) {

                    if(!angular.element($event.target).hasClass('jspDrag') && !angular.element($event.target).hasClass('jspTrack')) {
         
                        elem.find('ul').removeClass('active');
                        elem.find('.vmf-dropdown .vmf-dropdown-content').removeClass('_active');

                        /* need to reinitialise ul as scroll may have been destroyed */
                        ul = elem.find('ul');
                        if (ul.is(':visible')) {
                            ul.hide();
                        }
                        $(elem[0]).closest('.form-group').removeClass('active');
                    }    

                });

                /*scroll bar for window resize */

                $window.onresize = function() {

                    if(!scope.initializeScroll && elem.find('ul').hasClass('active')) {
                        dTop = ul.offset().top - $document.scrollTop();
                        if($window.innerHeight) {
                            dBottom = $window.innerHeight - dTop - ul.height();
                        }
                        else {
                            /* falling back to jquery $(window) for IE 7, 8 */
                            dBottom = $(window).height() - dTop - ul.height();    
                        }    

                        if(dBottom < 0 && scrollDestroyed) {
                            maxHeight = ul.height() + dBottom;
                            ul.css('max-height', maxHeight);
                           /* scrollPane = ul.jScrollPane({
                                autoReinitialise: true,
                                showArrows: showDDArrows,
                                verticalArrowPositions: 'after'
                            });
                        
                            scrollPaneApi = scrollPane.data('jsp');
                            scrollDestroyed = false;*/
                        }
                        else if(dBottom > 0 && !scrollDestroyed) {
                        
                            maxHeight = ul.height() + dBottom;

                            //scrollPaneApi.destroy();

                            ul = elem.find('ul');
                            ul.css('max-height', maxHeight);
                        
                            /*if(initialHeight > ul.height()) {
                                scrollPane = ul.jScrollPane({
                                    autoReinitialise: true,
                                    showArrows: showDDArrows,
                                    verticalArrowPositions: 'after'
                                });
                            
                                scrollPaneApi = scrollPane.data('jsp');
                                scrollDestroyed = false;
                            }
                            else {
                                scrollDestroyed = true;    
                            }   */ 
                        }
                        else if(dBottom < 0 && !scrollDestroyed) {
                        
                            maxHeight = ul.height() + dBottom;

                           // scrollPaneApi.destroy();

                            ul = elem.find('ul');
                            ul.css('max-height', maxHeight);
                        
                           /* if(initialHeight > ul.height()) {
                                scrollPane = ul.jScrollPane({
                                    autoReinitialise: true,
                                    showArrows: showDDArrows,
                                    verticalArrowPositions: 'after'
                                });
                            
                                scrollPaneApi = scrollPane.data('jsp');
                                scrollDestroyed = false;
                            }
                            else {
                                scrollDestroyed = true;    
                            }    */
                        }

                    }
                    else if(scope.initializeScroll && elem.find("ul").hasClass('active')) {
                        

                        dTop = ul.offset().top - $document.scrollTop();
                        if($window.innerHeight) {
                            dBottom = $window.innerHeight - dTop - ul.height();
                        }
                        else {
                            /* falling back to jquery $(window) for IE 7, 8 */
                            dBottom = $(window).height() - dTop - ul.height();    
                        }    

                        if(dBottom < 0 && scrollDestroyed2) {
                            maxHeight = ul.height() + dBottom;
                            ul.css('max-height', maxHeight);
                            /*scrollPane = ul.jScrollPane({
                                autoReinitialise: true,
                                showArrows: showDDArrows,
                                verticalArrowPositions: 'after'
                            });
                        
                            scrollPaneApi = scrollPane.data('jsp');
                            scrollDestroyed2 = false;*/
                        }
                        else if(dBottom > 0 && !scrollDestroyed2) {
                        
                            maxHeight = ul.height() + dBottom;
                            

                                //scrollPaneApi.destroy();

                                ul = elem.find('ul');
                                if(maxHeight < 350) {
                                    ul.css('max-height', maxHeight);
                                }
                                else {
                                    ul.css('max-height', 350);    
                                }    
                            
                               /* if(initialHeight >= ul.height()) {
                                    scrollPane = ul.jScrollPane({
                                        autoReinitialise: true,
                                        showArrows: showDDArrows,
                                        verticalArrowPositions: 'after'
                                    });
                                
                                    scrollPaneApi = scrollPane.data('jsp');
                                    scrollDestroyed2 = false;
                                }
                                else {
                                    scrollDestroyed2 = true;    
                                }    */
                                
                        }
                        else if(dBottom < 0 && !scrollDestroyed2) {
                        
                            maxHeight = ul.height() + dBottom;

                          //  scrollPaneApi.destroy();

                            ul = elem.find('ul');
                            ul.addClass('active');
                            ul.css('max-height', maxHeight);
                        
                            /*if(initialHeight > ul.height()) {
                                scrollPane = ul.jScrollPane({
                                    autoReinitialise: true,
                                    showArrows: showDDArrows,
                                    verticalArrowPositions: 'after'
                                });
                            
                                scrollPaneApi = scrollPane.data('jsp');
                                scrollDestroyed2 = false;
                            }
                            else {
                                scrollDestroyed2 = true;    
                            }    */
                        }
                        
                    }
                    
                };

                /* scroll bar for exceeding browser edge when scrolling */

                angular.element($window).on('scroll', function($event) {
                    
                    if($event.target.nodeName === '#document') {
                        
                        if(!scope.initializeScroll && elem.find('ul').hasClass('active')) {
                            dTop = ul.offset().top - $document.scrollTop();
                            if($window.innerHeight) {
                                dBottom = $window.innerHeight - dTop - ul.height();
                            }
                            else {
                                /* falling back to jquery $(window) for IE 7, 8 */
                                dBottom = $(window).height() - dTop - ul.height();    
                            }    

                            if(dBottom < 0 && scrollDestroyed) {
                                maxHeight = ul.height() + dBottom;
                                ul.css('max-height', maxHeight);
                               /* scrollPane = ul.jScrollPane({
                                    autoReinitialise: true,
                                    showArrows: showDDArrows,
                                    verticalArrowPositions: 'after'
                                });
                            
                                scrollPaneApi = scrollPane.data('jsp');
                                scrollDestroyed = false;*/
                            }
                            else if(dBottom > 0 && !scrollDestroyed) {
                            
                                maxHeight = ul.height() + dBottom;

                                //scrollPaneApi.destroy();

                                ul = elem.find('ul');
                                ul.css('max-height', maxHeight);
                            
                               /* if(initialHeight > ul.height()) {
                                    scrollPane = ul.jScrollPane({
                                        autoReinitialise: true,
                                        showArrows: showDDArrows,
                                        verticalArrowPositions: 'after'
                                    });
                                
                                    scrollPaneApi = scrollPane.data('jsp');
                                    scrollDestroyed = false;
                                }
                                else {
                                    scrollDestroyed = true;    
                                }    */
                            }
                            else if(dBottom < 0 && !scrollDestroyed) {
                            
                                maxHeight = ul.height() + dBottom;

                               // scrollPaneApi.destroy();

                                ul = elem.find('ul');
                                ul.css('max-height', maxHeight);
                            
                                /*if(initialHeight > ul.height()) {
                                    scrollPane = ul.jScrollPane({
                                        autoReinitialise: true,
                                        showArrows: showDDArrows,
                                        verticalArrowPositions: 'after'
                                    });
                                
                                    scrollPaneApi = scrollPane.data('jsp');
                                    scrollDestroyed = false;
                                }
                                else {
                                    scrollDestroyed = true;    
                                }    */
                            }

                        }
                        else if(scope.initializeScroll && elem.find("ul").hasClass('active')) {
                            

                            dTop = ul.offset().top - $document.scrollTop();
                            if($window.innerHeight) {
                                dBottom = $window.innerHeight - dTop - ul.height();
                            }
                            else {
                                /* falling back to jquery $(window) for IE 7, 8 */
                                dBottom = $(window).height() - dTop - ul.height();    
                            }    

                            if(dBottom < 0 && scrollDestroyed2) {
                                maxHeight = ul.height() + dBottom;
                                ul.css('max-height', maxHeight);
                               /* scrollPane = ul.jScrollPane({
                                    autoReinitialise: true,
                                    showArrows: showDDArrows,
                                    verticalArrowPositions: 'after'
                                });
                            
                                scrollPaneApi = scrollPane.data('jsp');
                                scrollDestroyed2 = false;*/
                            }
                            else if(dBottom > 0 && !scrollDestroyed2) {
                            
                                maxHeight = ul.height() + dBottom;
                                

                                  //  scrollPaneApi.destroy();

                                    ul = elem.find('ul');
                                    if(maxHeight < 350) {
                                        ul.css('max-height', maxHeight);
                                    }
                                    else {
                                        ul.css('max-height', 350);    
                                    }    
                                
                                    /*if(initialHeight >= ul.height()) {
                                        scrollPane = ul.jScrollPane({
                                            autoReinitialise: true,
                                            showArrows: showDDArrows,
                                            verticalArrowPositions: 'after'
                                        });
                                    
                                        scrollPaneApi = scrollPane.data('jsp');
                                        scrollDestroyed2 = false;
                                    }
                                    else {
                                        scrollDestroyed2 = true;    
                                    }    */
                                    
                            }
                            else if(dBottom < 0 && !scrollDestroyed2) {
                            
                                maxHeight = ul.height() + dBottom;

                               // scrollPaneApi.destroy();

                                ul = elem.find('ul');
                                ul.addClass('active');
                                ul.css('max-height', maxHeight);
                            
                                /*if(initialHeight > ul.height()) {
                                    scrollPane = ul.jScrollPane({
                                        autoReinitialise: true,
                                        showArrows: showDDArrows,
                                        verticalArrowPositions: 'after'
                                    });
                                
                                    scrollPaneApi = scrollPane.data('jsp');
                                    scrollDestroyed2 = false;
                                }
                                else {
                                    scrollDestroyed2 = true;    
                                } */   
                            }
                            
                        }
                    }
                });            


                if(typeof scope.preSelectInd !== 'undefined') {
                    if(typeof scope.list[0] === 'object') {
                        scope.model = scope.list[scope.preSelectInd].eaNumber;
                    }
                    else {
                        scope.model = scope.list[scope.preSelectInd];   
                    }    
                    
                    var list2 = elem.find('li');
                    angular.element(list2[scope.preSelectInd]).addClass('dd-opt-selected').append('<span class="tickIcon"></span>');
                }

                var liFirstChild = elem.find('ul.dropDownListItems li:first-child');
                if( liFirstChild.find('.tickIcon').length ){
                    $('<span class="defaultEAText">Default</span>').insertAfter( liFirstChild.find('.tickIcon') );
                }else{
                    liFirstChild.append('<span class="defaultEAText">Default</span>');
                }

                scope.select = function($event) {
                    var opt = $event.currentTarget;

                    if(sub) {
                        elem.find('span.current-selection').text(titlePrefix + $(opt).text());
                    }    
                    scope.model = $(opt).text(); 
                    
                    var list = elem.find('li'); 
                    angular.forEach(list, function(item) {
                        
                        angular.element(item).removeClass('dd-opt-selected');
                    });

                    angular.element(opt).addClass('dd-opt-selected');

                    scope.$emit('vmfDDOptionClicked', $event);
                };

                scope.selectObj = function($event, index) {
                    var opt = $event.currentTarget;

                    if(sub) {
                        elem.find('span.current-selection').text(titlePrefix + $(opt).data('ea-display-name'));
                    }    
                    scope.model = scope.list[index].eaNumber; 
                    var list = elem.find('li'); 

                    angular.forEach(list, function(item) {
                        
                        angular.element(item).removeClass('dd-opt-selected').find('.tickIcon').remove();
                    });

                    $(opt).addClass('dd-opt-selected');
                    
                    if( $(opt).find('.defaultEAText').length ){
                      $('<span class="tickIcon"></span>').insertBefore( $(opt).find('.defaultEAText') );
                    }else{
                      $(opt).append('<span class="tickIcon"></span>');
                    }

                    scope.$emit('vmfDDOptionClicked', $event);
                };


                /*
                * fallback event - ng-click events do not propagate on some occassions when dropdown is integrated 
                * with other components
                */

                scope.$on('vmfDDOptionClicked', function(customEvent, $event) {
                    scope.changeClass($event);
                    customEvent.stopPropagation();
                });

                scope.selectByKey = function($event, index) {
                    if(sub) {
                        elem.find('span.current-selection').text(titlePrefix + $(options[index]).text());
                    }    

                    if(typeof scope.list[0] === 'object') {
                        scope.model = scope.list[index].eaNumber;
                    }
                    else {
                        scope.model = scope.list[index];
                    }
                        
                    var list = elem.find('li');
                    angular.forEach(list, function(item) {
                        
                        angular.element(item).removeClass('dd-opt-selected');
                    });

                    angular.element(options[index]).addClass('dd-opt-selected');
                };


                scope.currentIndex = -1;
                var lowestEleIndex = 14;

                scope.keyPressTitle = function($event) {
                    
                    var list = elem.find('li');

                    if($event.which === 40) {
                        $event.preventDefault();

                        if(scope.currentIndex < options.length - 1) {

                            scope.currentIndex += 1;
                            scope.selectByKey($event, scope.currentIndex);
                            if(scope.currentIndex >= 15) {
                                //scrollPaneApi.scrollToElement(list[scope.currentIndex]);
                                lowestEleIndex = scope.currentIndex;
                            }
                        }
                    
                    }

                    else if($event.which === 38) {
                        $event.preventDefault();

                        if(scope.currentIndex > 0) {
                            scope.currentIndex -= 1;
                            scope.selectByKey($event, scope.currentIndex);
                            if(lowestEleIndex - scope.currentIndex >= 15) {
                                //scrollPaneApi.scrollToElement(list[scope.currentIndex]);
                                lowestEleIndex -= 1;
                            }
                        }
                    
                    }

                    else if($event.which === 13 && ul.hasClass('active')) {
                        elem.find('.vmf-dropdown-content').removeClass('_active');
                        elem.find('.current-selection').removeClass('_active-drop');
                        ul.removeClass('active');
                        ul.hide();
                    }

                    else if(($event.which >= 48 && $event.which <= 57) || ($event.which >= 65 && $event.which <= 90) || ($event.which >= 97 && $event.which <= 122)) {
                        
                        var i, text, matchingIndex = -1;
                        if(typeof scope.list[0] === 'object') {
                            for(i = scope.currentIndex + 1; i < scope.list.length; i++) {
                                text = scope.list[i].text;
                                
                                if(text.charCodeAt(0) === $event.which) {
                                    matchingIndex = i;
                                    break;
                                }
                                
                            }
                            
                            if(matchingIndex === -1) {
                                for(i = 0; i < scope.currentIndex; i++) {
                                    text = scope.list[i].text;
                                    
                                    if(text.charCodeAt(0) === $event.which) {
                                        matchingIndex = i;
                                        break;
                                    }
                                    
                                }    
                            }

                            if(matchingIndex !== -1) {
                                if(sub) {
                                    elem.find('span.current-selection').text(titlePrefix + text);
                                }    
                                scope.model = scope.list[matchingIndex].eaNumber; 
                                scope.currentIndex = matchingIndex;

                                list = elem.find('li'); 

                                angular.forEach(list, function(item) {
                                    
                                    angular.element(item).removeClass('dd-opt-selected');
                                });

                                angular.element(elem.find('li')[matchingIndex]).addClass('dd-opt-selected');

                                matchingIndex = -1;
                            }        
    
                        }

                        else {
                            for(i = scope.currentIndex + 1; i < scope.list.length; i++) {
                                if(typeof scope.list[0] !== 'string') {
                                    text = scope.list[i].toString();
                                }
                                else {
                                    text = scope.list[i];    
                                }
                                
                                if(text.charCodeAt(0) === $event.which) {
                                    matchingIndex = i;
                                    break;
                                }
                                
                            }

                            if(matchingIndex === -1) {
                                for(i = 0; i < scope.currentIndex; i++) {
                                    text = scope.list[i].text;
                                    
                                    if(text.charCodeAt(0) === $event.which) {
                                        matchingIndex = i;
                                        break;
                                    }
                                    
                                }    
                            }

                            if(matchingIndex !== -1) {
                                if(sub) {
                                    elem.find('span.current-selection').text(titlePrefix + text);
                                }    
                                scope.model = scope.list[i]; 
                                scope.currentIndex = i;
                                
                                list = elem.find('li'); 
                                angular.forEach(list, function(item) {
                                    
                                    angular.element(item).removeClass('dd-opt-selected');
                                });

                                angular.element(elem.find('li')[i]).addClass('dd-opt-selected');
                                matchingIndex = -1;

                            }    

                        }                            

                    }

                };

                scope.$watch('model', function(n,o) {
                    if(n!=o){
                        scope.publish('eaDropdownChange', scope.model);
                    }
                    if(n === null && sub) {
                        $timeout(function() {
                            if(attrs.htitle ==='' || attrs.htitle) {
                                elem.find('span.current-selection').text(scope.htitle);
                            }
                            else {
                                elem.find('span.current-selection').text('Select');    
                            }
                            elem.find('li').removeClass('dd-opt-selected');                     
                        });    

                    }
                });

            }
        };
    }
])
.directive('vmLabelDropdown', ['$compile', '$document', '$window', '$timeout','$http','globalData',
    function($compile, $document, $window, $timeout, $http, globalData) {
        return {
            restrict: 'EA',
            scope: {
                list: '=',
                controls: '='
            },
            //hack to get controller name to be set.
            //hack to get controller name to be set.
            link : function(scope,elem,attrs){
                    //hack to get template from the scope that is passed.
                    scope.controlsDisplay = true;
                    scope.list = globalData.customLabels;
                              scope.globalVars = globalVariables;
                    

                    scope.addSelectPicker = function(){
                        elem.find('.selectpicker').selectpicker('refresh');
                        elem.find('.selectpicker li').eq(0).hide();
                        scope.isErr = false;
                        //** Adding create - rename label links **//
                        if(scope.controls == true){
                            $timeout(function() {
                                //var labelOperationsHtml = '<div class="controlOptions"><p class="divider"></p><div ng-show="controlsDisplay"><p class="createLabelLink" ng-click="controlsDisplay = false">Create New Custom Label</p><p class="renameLabelLink" ng-click="showRenameLabels()">Rename Custom Label</p></div><div ng-show="!controlsDisplay"><input type="text" class="newLabelName" /><div class="buttons"><button type="button" class="vmf-btn vmf-primary" ng-click="confirmBtn()">Save</button><button type="button" class="vmf-btn vmf-secondary" ng-click="controlsDisplay = true">Cancel</button></div></div></div>';
                                var labelOperationsHtml = '<p class="divider"></p>'+
                                                            '<div ng-show="controlsDisplay">'+
                                                                '<p class="createLabelLink" ng-click="createNewLabel($event)">'+scope.globalVars.createNewLbl+'</p>'+
                                                                '<p class="renameLabelLink" ng-click="showRenameLabels()">'+scope.globalVars.renameLabelLbl+'</p>'+
                                                            '</div>'+
                                                            '<div ng-show="!controlsDisplay" class="createLabelLinkContainer">'+
                                                                '<p class="errorTextStyle" ng-if="maximumLabels">Maximum 10 labels</p>'+
                                                                
                                                                '<input type="text" class="newLabelName" maxlength="25" ng-model="newLabelName" ng-class="{\'error\': isErr}"/>'+
                                                                '<div class="newLabelNameError" ng-show="isErr">{{errMsg}}</div>'+
                                                                '<div class="buttons">'+
                                                                    '<button type="button" class="vmf-btn vmf-primary" ng-click="confirmBtn($event)">'+scope.globalVars.textSave+'</button>'+
                                                                    '<button type="button" class="vmf-btn vmf-secondary" ng-click="cancelCreateLabel($event)">'+scope.globalVars.textCancel+'</button>'+
                                                                '</div>'+
                                                            '</div>';
                                    elem.find(".dropdown-menu").append($compile(labelOperationsHtml)(scope));
                                    $timeout(function(){
                                        elem.find("input.newLabelName").on("focus keydown click",function(e){
                                            e.stopPropagation();
                                        })
                                    },80);
                            },80);
                        }
                    }

                    scope.subscribe('closeSelectPicker', function( ev ){
                      elem.find('.labelsDropDown.open').removeClass('open');
                    });
                    
                    scope.subscribe('closeAllDropdowns', function( ev ){
                      if( elem.find( ev.target ).length === 0 ){
                        elem.find('.labelsDropDown.open').removeClass('open');
                      }
                    });

                    $document.on('show.bs.dropdown', '.bootstrap-select.labelsDropDown', function (ev) {
                        scope.publish('closeAllDropdowns', ev);
                        $document.trigger('click.actionsDropdown');
                    });

                    scope.confirmBtn = function($event){
                        
                        $event.preventDefault();
                        $event.stopPropagation();
                        scope.isErr = false;
                        scope.maximumLabels = false;
                        if( globalData.checkSpecialCharacters( scope.newLabelName ) ){
                            scope.isErr = true;
                            scope.errMsg = globalVariables.charsNotAllowedMsg;
                            elem.find('.createLabelLinkContainer .newLabelNameError').removeClass('hidden');
                            return;
                        }
                        if( scope.newLabelName != undefined && scope.newLabelName.length > 0){
                          angular.element(".createLabelLinkContainer").addClass()
                          var reqUrl = globalVariables.createLabelUrl+"&newLabelName="+scope.newLabelName;

                            var postData =  { 
                                'newLabelName' : scope.newLabelName
                            };

                            var postDataEncoded = $.param(postData);

                            $http({
                                method: 'POST',
                                url: globalVariables.createLabelUrl,
                                data: postDataEncoded,
                                headers: {'Content-Type': 'application/x-www-form-urlencoded'}
                            }).
                            success(function(data, status, headers, config) {
                              if(data.labels){
                                globalData.customLabels = data.labels;
                                  //scope.publish('newLabels',globalData.customLabels);
                                  var _newOption = elem.find("input.newLabelName").val();
                                      scope.controlsDisplay = true;
                                      elem.find('input.newLabelName').val('');
                                  $(".editor select.labelsDropDown option").remove();
                                 var _optionHtml = '<option value="">'+scope.globalVars.selectLabelMsg+'</option>';
                                  globalData.customLabels.sort();
                                  for(var i=0; i<globalData.customLabels.length; i++){
                                      _optionHtml += '<option value='+globalData.customLabels[i]+'>'+globalData.customLabels[i]+'</option>';
                                  }
                                  $(".editor select.labelsDropDown").append(_optionHtml);
                                  //$(".controlOptions").remove();
                                  $('.selectpicker').selectpicker('refresh');
                                  $('.editor ul.dropdown-menu').each(function(i,obj){
                                          $(obj).find('li').eq(0).hide();
                                      var _obj = $(obj).find('li');
                                          $(obj).find('li').remove();
                                          $(obj).prepend(_obj);
                                  });
                                  //scope.regenerateSelectPicker();
                              }else{
                                    scope.maximumLabels = true;
                                }
                            }).
                            error(function(data, status, headers, config) {
                                $scope.ftAjaxLoader = false;
                                $scope.ftErrorMsg = globalVariables.commonAjaxErrorMessage;
                                // called asynchronously if an error occurs
                                // or server returns response with an error status.
                            });
                        }else{
                          scope.isErr = true;
                          scope.errMsg = globalVariables.enterLabelNameLbl;
                          elem.find('.createLabelLinkContainer .newLabelNameError').removeClass('hidden');
                        }
                    }

                    scope.showRenameLabels = function(){
                        globalData.renameLabels = true;
                        //globalData.renameLabels = false;
                    }
                    scope.createNewLabel = function($event){
                      $event.preventDefault();
                      $event.stopPropagation();
                      scope.controlsDisplay = false;
                    }
                    scope.cancelCreateLabel = function($event){
                      $event.preventDefault();
                      $event.stopPropagation();
                      scope.controlsDisplay = true;
                      scope.maximumLabels = false;
                      scope.isErr = false;
                    }
                    scope.getTemplate = function(){
                        var template = '<select class="labelsDropDown selectpicker"><option value="">'+scope.globalVars.selectLabelMsg+'</option><option ng-repeat="val in list" value="{{val}}">{{val}}</option></select>';
                            elem.html($compile(template)(scope));
                            $timeout(function() {
                                scope.addSelectPicker();                           
                            }, 80);
                    }
                    scope.getTemplate();
                    
                }
        }
    }
]);

angular.module('vmfTextInputMod', [])
.directive('vmfTextInput', ['$compile', '$document', '$timeout', 
    function($compile, $document, $timeout) {
        return {
            restrict: 'EA',
            scope: {
                type: '@',
                optionId: '@',
                name: '@',
                title: '@',
                model: '=',
                searchCallback: '&',
                psearchCallback: '=',
                hint: '@',
                rows: '@',
                clearTextLength: '@',
                searchModel: '=',
                mandatory: '@',
                customClass: '=',
                shortDescription: '@'
            },
            controller: ['$scope',
                function($scope) {

                    $scope.defaults = {
                        rows: 10,
                        hint: '',
                        clearTextLength: 3

                    };


                    $scope.options = {};
                    
                    if ($scope.rows) {
                        $scope.options.rows = $scope.rows;
                    } else {
                        $scope.options.rows = $scope.defaults.rows;
                    }

                    if ($scope.hint) {
                        $scope.options.hint = $scope.hint;
                    } else {
                        $scope.options.hint = $scope.defaults.hint;
                    }

                    if ($scope.clearTextLength) {
                        $scope.options.clearTextLength = $scope.clearTextLength;
                    } else {
                        $scope.options.clearTextLength = $scope.defaults.clearTextLength;
                    }

                }
            ],

            link: function(scope, elem, attrs) {
                var template;

                var shortDesc;


                scope.checkDesc = function() {
                    if (scope.shortDescription) {
                        shortDesc = scope.shortDescription;
                    } else {
                        shortDesc = "";
                    }
                    return shortDesc;

                };

                if (attrs.type === 'normal') {
                    if (scope.mandatory === 'true') {
                        template = '<div class="formRow"><label class="col-md-3 formLabel"><span class="mandatory">*</span> ' + scope.title + '   <span class="shortDesc">{{ checkDesc()}}</span></label><div class="col-md-4"><input type="text" name="name" ng-model="model" id={{options.optionId}} placeholder={{options.hint}} /></div></div>';
                    } else {
                        template = '<div class="formRow"><label class="col-md-3 formLabel">' + scope.title + '<span class="shortDesc">{{ checkDesc()}}</span></label><div class="col-md-4"><input type="text" id={{options.optionId}} name="name" ng-model="model" placeholder={{options.hint}} /></div></div>';
                    }

                    elem.append(template);
                    if (scope.customClass) {
                        angular.forEach(scope.customClass, function(item) {
                            elem.find(item.selector).addClass(item.cusclass);


                        });
                    }
                    $compile(elem.contents())(scope);

                } else if (attrs.type === 'password') {
                    
                    if (scope.mandatory === 'true') {
                        template = '<div class="formRow"><label class="col-md-3 formLabel"><span class="mandatory">*</span> ' + scope.title + '</label><div class="col-md-4 placeholderWrap"><input type="password" ng-model="model" id="' + scope.optionId + '" ng-focus="placeholderFocus(this)" ng-blur="placeholderBlur(this)"  /><span class="placeholder" ng-click="placeholderFocusSpan(this)">{{options.hint}}</span></div></div>';
                    } else {
                        template = '<div class="formRow"><label class="col-md-3 formLabel">' + scope.title + '</label><div class="col-md-4 placeholderWrap"><input type="password" id="' + scope.optionId + '" ng-model="model" name="name" ng-focus="placeholderFocus(this)" ng-blur="placeholderBlur(this)" /><span class="placeholder" ng-click="placeholderFocus(this)">{{options.hint}}</span></div></div>';
                    }

                    elem.append(template);
                    if (scope.customClass) {
                        angular.forEach(scope.customClass, function(item) {
                            elem.find(item.selector).addClass(item.cusclass);


                        });
                    }
                    $compile(elem.contents())(scope);

                } else if (attrs.type === 'search') {
                    template = '<form autocomplete="off" class="searchArea"><input type="text" name="name" ng-model="model" ng-focus="onsearchFocus()" ng-blur="onsearchBlur()" ng-keyup="keyPressSearch($event)" placeholder={{options.hint}} id={{options.optionId}} /><input type="button" class="vmf-search-button" ng-click="searchAction()"/></form>';
                    elem.append(template);
                    if (scope.customClass) {
                        angular.forEach(scope.customClass, function(item) {
                            elem.find(item.selector).addClass(item.cusclass);


                        });
                    }
                    $compile(elem.contents())(scope);

                    scope.$watch('model', function(n, o) {

                        
                        if (n && n.length >= scope.options.clearTextLength) {
                            elem.find('.searchArea').addClass('active');
                        } else {
                            elem.find('.searchArea').removeClass('active');
                        }

                    });
                } else if (attrs.type === 'psearch') {

                    template = '<form autocomplete="off" class="searchArea psearch"><input  type="text" ng-model="model" name="name" ng-keyup="keyPressSearch($event)" placeholder={{options.hint}} id={{options.optionId}} /><input type="button" class="searchBtn" ng-click="psearchAction()"/><ul class="searchWrap"><li ng-repeat="item in filteredData = (searchModel | filter:model:comparator)" ng-bind-html="item | highlight:model" ng-click="optionSelect(item)" ng-keyup="optionSelectByKey($event, item)" tabindex="0"></li></ul></form>';
                    elem.append(template);
                    if (scope.customClass) {
                        angular.forEach(scope.customClass, function(item) {
                            elem.find(item.selector).addClass(item.cusclass);


                        });
                    }
                    $compile(elem.contents())(scope);

                    scope.$watch('model', function(n, o) {
                        $timeout(function() {
                            if (n && n.length >= 1) {
                                elem.find('.searchArea').addClass('active');
                                if (!scope.empty) {
                                    elem.find('.searchWrap').show();
                                    $(elem[0]).closest('.form-group').addClass('active');
                                }    
                            } else {
                                elem.find('.searchArea').removeClass('active');
                                elem.find('.searchWrap').hide();
                                $(elem[0]).closest('.form-group').removeClass('active');
                            }
                        });

                    });

                    scope.empty = false;

                    scope.$watchCollection('filteredData', function(n, o) {
                        if (n.length === 0) {
                            scope.empty = true;
                            
                            elem.find('.searchWrap').hide();
                            $(elem[0]).closest('.form-group').removeClass('active');
                        } else {
                            scope.empty = false;
                            
                        }

                    });


                }


                scope.searchAction = function() {
                    /*if (scope.model.length >= scope.options.clearTextLength) {
                        scope.clearText();
                    } else {*/
                        scope.searchCallback(scope.model);
                    /*}*/
                };

                scope.selected = false;

                scope.psearchAction = function() {
                    if (scope.model.length >= 1 && !scope.selected) {
                        scope.clearText();
                    } else {
                        
                        scope.psearchCallback(elem.find(':text').val());
                        scope.selected = false;
                    }
                };

                scope.clearText = function() {
                    
                    elem.find(':text').val('');
                    scope.model = '';
                    elem.find('.searchArea').removeClass('active');
                };

                scope.keyPressSearch = function($event) {
                    if ($event.keyCode === 13) {
                        if (scope.type === 'search') {
                            scope.searchCallback();
                        } else {
                            scope.selected = true;
                            scope.psearchAction();
                            elem.find('.searchArea').removeClass('active');
                        }
                    }
                };


                scope.optionSelect = function(item) {
                    
                    elem.find(':text').val(item);
                    elem.find('.searchArea').removeClass('active');
                    
                    scope.selected = true;
                };

                scope.optionSelectByKey = function($event, item) {
                    

                    if ($event.keyCode === 13) {
                        
                        elem.find(':text').val(item);
                        elem.find('.searchArea').removeClass('active');
                        
                        scope.selected = true;
                    }

                };
                scope.onsearchBlur = function() {
                    
                    elem.find('.searchArea').removeClass('active');
                };
                
                scope.onsearchFocus = function() {
                    elem.find('.searchArea').addClass('active');

                };
                scope.placeholderFocus = function(target) {
                    
                    $('#' + scope.optionId).closest('.placeholderWrap').find('.placeholder').hide();
                };
                scope.placeholderBlur = function(target) {
                    
                    if (scope.model === null || scope.model === "") {
                        $('#' + scope.optionId).closest('.placeholderWrap').find('.placeholder').show();
                    } else {
                        $('#' + scope.optionId).closest('.placeholderWrap').find('.placeholder').hide();
                    }
                };

                scope.placeholderFocusSpan = function() {

                    $('#' + scope.optionId).closest('.placeholderWrap').find('.placeholder').hide();
                    $('#' + scope.optionId).focus();

                };

                $document.on('click', function() {
                    
                    elem.find('.psearch').removeClass('active');
                    elem.find('.searchWrap').hide();
                    $(elem[0]).closest('.form-group').removeClass('active');

                });

                scope.comparator = function(actual, expected) {
                    var actualWords = actual.split(' ');
                    var expectedWords = expected.split(' ');
                    
                    var i, j;

                    var match = true;

                    for (i = 0; i < expectedWords.length; i++) {
                        expectedWords[i] = expectedWords[i].toLowerCase();
                    
                    }

                    for (j = 0; j < actualWords.length; j++) {
                        actualWords[j] = actualWords[j].toLowerCase();
                    }

                    
                    var startingIndex = 0;
                    for (i = 0; i < expectedWords.length; i++) {
                        var found = false;

                        for (j = startingIndex; j < actualWords.length; j++) {
                            
                            if (actualWords[j].indexOf(expectedWords[i]) !== -1) {
                                found = true;
                                startingIndex = j + 1;
                                break;
                            }
                        }

                        if (!found) {
                            return false;
                        }

                    }

                    return true;
                };

            }

        };
    }
])
    .filter('highlight', function() {
        return function(text, phrases) {

            /* returns position of ith occurrence of m in str */
            var getPosition = function(str, m, i) {
                return str.split(m, i).join(m).length;
            };


            if (phrases) {
                phrases = phrases.split(' ');

                angular.forEach(phrases, function(phrase, index) {

                    /* word boundary */
                    var splitIndex = getPosition(text, ' ', index);


                    if (splitIndex !== 0) {
                        var subText = text.substring(splitIndex + 1).replace('<span>', '', 'gi');
                        subText = subText.replace('</span>', '', 'gi');
                        text = text.substring(0, splitIndex + 1) + subText.replace(new RegExp('(' + phrase + ')', 'gi'), '<span>$1</span>');

                    } else {
                        text = text.replace(new RegExp('(' + phrase + ')', 'gi'), '<span>$1</span>');

                    }

                });

            }

            text = '<a href="javascript: void(0);" tabindex="-1">' + text + '</a>';
            return text;
        };
    });
/* Calendar Directive */
angular.module('vmfCalendarMod', [])
.directive('vmfCalendar', ['$compile', '$document', '$timeout', function($compile, $document, $timeout) {
    return {
        restrict: 'EA',
        scope: {
            historic:'=',
            startyear:'=',
            endyear:'=',
            customeventname: '@',
            calendarInputId: '@'
        },
        link: function(scope, elem, attrs) {
            var template;
            var j;
            var ind;
            var cfsd;
            var fsm;
            var fsy;
            var fsd;
            var firstdateofmonth;
            var lastdateofmonth;
            var split_first;
            var temp_check;
            //console.log('historic');
            //console.log(scope.historic);
            var temp_historic = scope.historic.split('/');
            var indexFirstCal;
            scope.historic = new Date(temp_historic[2],temp_historic[1]-1,temp_historic[0]);
            //console.log(scope.historic);
            scope.firstyearlist = [];      
            for(i=parseInt(scope.startyear);i<=parseInt(scope.endyear);i++){
                scope.firstyearlist.push(i);
            }

            var today = new Date();
            var dd = today.getDate();
            var mm = today.getMonth(); 
            var yyyy = today.getFullYear();
            scope.first_year = yyyy;
            indexFirstCal = scope.firstyearlist.indexOf(parseInt(yyyy));
            scope.first_month = mm;
            var day = today.getDay();

            
            scope.secondyearlist = new Array(10);
            j = 0;
            for (i = scope.first_year; i <= (scope.first_year + 30); i++) {
                scope.secondyearlist[j++] = i;
            }

            // for first calendar calculating the dates needed , basically first and last day
            var lastday = new Date(yyyy, mm + 1, 0);

            var lastdate = lastday.getDate();
            

            var firstday = new Date(yyyy, mm, 1);
            
            firstday = firstday.getDay();

            var cal_data_first = [];
            var daycount = 1;
            
            daycount = 1;
            cal_data_first = [];
            i = firstday;
            counter = lastdate;
            while (counter !== 0) {
                cal_data_first[i++] = daycount++;

                counter = counter - 1;
            }
           
            daycount = 1;
            
            scope.first_cal = cal_data_first;
            
            mm = mm + 1;

            scope.second_year = yyyy;
            scope.second_month = mm;

          
            var slastday = new Date(yyyy, mm + 1, 0);
            var slastdate = slastday.getDate();
            
            var sfirstday = new Date(yyyy, mm, 1);
            sfirstday = sfirstday.getDay();
            var cal_data_second = [];
            daycount = 1;
            
            cal_data_first = [];
            i = sfirstday;
            counter = slastdate;
            while (counter !== 0) {
                cal_data_second[i++] = daycount++;
                counter = counter - 1;
            }   
            daycount = 1;
            scope.second_cal = cal_data_second;



            // scope.check_if_in_between('first');
            // scope.check_if_in_between('second');
            // functions to support left and right arrows of first calendar
            scope.goleftwithfirst = function(month, year) {
                // if(scope.first_selected_date && !scope.second_selected_date){
                //     scope.first_selected_date = undefined;
                // }   
                // if(!scope.first_selected_date || (scope.first_selected_date && scope.second_selected_date)){        
                    if (scope.first_year === scope.firstyearlist[0] && scope.first_month === 0) {
                        
                        return;
                    }
                    for (i = 0; i < cal_data_first.length; i++) {
                        elem.find('.first-calendar .' + i).removeClass('activefirstcal');
                        elem.find('.first-calendar .' + i).removeClass('activeselectfirstcal');
                    }
                    if (month === 0) {
                        
                        year = year - 1;
                        ////console.log('change in year');
                        //console.log('this is changing the year')
                        elem.find('.firstcaldir .current-selection').text(year);
                        month = 11;
                    } else {
                      
                        month = month - 1;
                    }               
                    var firstday = new Date(year, month, 1);               
                    firstday = firstday.getDay();       
                    var lastday = new Date(year, month + 1, 0);             
                    var lastdate = lastday.getDate();
                    var daycount = 1;
                    cal_data_first = [];
                    i = firstday;
                    counter = lastdate;
                    while (counter !== 0) {
                        cal_data_first[i++] = daycount++;

                        counter = counter - 1;
                    }          
                    scope.first_cal = cal_data_first;           
                    scope.first_month = month;
                    scope.first_year = year;
                // }
                scope.check_if_in_between('first');
                 if(scope.second_month ===(scope.first_month) && scope.first_year === scope.second_year){
                    elem.find('.arrow-left').addClass('hiddenarrow').parent().addClass("disabledarrow");
                }else{
                    elem.find('.arrow-left').removeClass('hiddenarrow').parent().removeClass("disabledarrow");

                }
                
            };
            scope.gorightwithfirst = function(month, year) { 
                //console.log('go right with first');
                // if(!scope.first_selected_date || (scope.first_selected_date && scope.second_selected_date)){ 
                    // if(scope.first_selected_date && !scope.second_selected_date){
                    //     scope.first_selected_date = undefined;
                    // }   
                    for (i = 0; i < cal_data_first.length; i++) {
                        elem.find('.first-calendar .' + i).removeClass('activefirstcal');
                        elem.find('.first-calendar .' + i).removeClass('activeselectfirstcal');
                    }
                    if (month === 11) {
                     
                        year = parseInt(year) + 1;
                        elem.find('.firstcaldir .current-selection').text(year);

                        month = 0;

                    } else {
                       
                        month = month + 1;
                    }

               
                    var firstday = new Date(year, month, 1);
                   
                    firstday = firstday.getDay();
                   

                    var lastday = new Date(year, month + 1, 0);
                    
                    var lastdate = lastday.getDate();
                   


                    var daycount = 1;
                    cal_data_first = [];
                    i = firstday;
                    counter = lastdate;
                    while (counter !== 0) {
                        cal_data_first[i++] = daycount++;

                        counter = counter - 1;
                    }
                   
                    scope.first_cal = cal_data_first;


                    scope.first_month = month;
                    scope.first_year = year;

                    if (scope.first_year === scope.second_year && (scope.first_month === scope.second_month || (scope.first_month -1) === scope.second_month)) {
                        ////console.log('its meeting the condition');
                        scope.gorightwithsecond(scope.first_month, scope.first_year);
                    }
                // }
                scope.check_if_in_between('first');
                 if(scope.second_month ===(scope.first_month) && scope.first_year === scope.second_year){
                    elem.find('.second-calendar .arrow-left').addClass('hiddenarrow').parent().addClass("disabledarrow");
                }else{
                    elem.find('.second-calendar .arrow-left').removeClass('hiddenarrow').parent().removeClass("disabledarrow");

                }
            };
            // end for first            
            // functions to support left and right arrows of second calendar
            scope.goleftwithsecond = function(month, year) {
                ////console.log('go left with second');
                if ((scope.first_year === scope.second_year && (scope.first_month ) === scope.second_month) && !(scope.first_year === (scope.second_year - 1) && scope.first_month === 11)) {
                    ////console.log('can\'t go left ');

                    return;
                }


                if (month === 0) {
                  
                    year = year - 1;

                    month = 11;
                } else {
                   
                    month = month - 1;
                }

           
                var firstday = new Date(year, month, 1);
            
                firstday = firstday.getDay();
              

                var lastday = new Date(year, month + 1, 0);
           
                var lastdate = lastday.getDate();
            


                var daycount = 1;
                cal_data_second = [];
                i = firstday;
                counter = lastdate;
                while (counter !== 0) {
                    cal_data_second[i++] = daycount++;

                    counter = counter - 1;
                }
                
                scope.second_cal = cal_data_second;
                scope.second_month = month;
                scope.second_year = year;
                // for(i=1;i<=42;i++){
                //     elem.find('.second-calendar .' + i).removeClass('vmf-disabled-date');
                // } 
                if(scope.first_selected_date && !scope.second_selected_date){
                    ////console.log('bhagwan chal ja');
                    var fd = new Date(scope.first_selected_date);
                    var sec_cal_first_date = new Date(scope.second_year,scope.second_month,1);
                    var first_date = fd.getDate();
                    // if(!(sec_cal_first_date>= fd)){
                    //     for(i=cal_data_second.indexOf(1);i<cal_data_second.indexOf(first_date);i++){
                    //         elem.find('.second-calendar .' + i).addClass('vmf-disabled-date');
                    //     }    
                    // }
                    
                }
                // //////console.log("currect scope month and year");
                // //////console.log(scope.first_month);
                // //////console.log(scope.first_year);
                 if(scope.second_month ===(scope.first_month) && scope.first_year === scope.second_year){
                    elem.find('.second-calendar .arrow-left').addClass('hiddenarrow').parent().addClass("disabledarrow");
                }else{
                    elem.find('.second-calendar .arrow-left').removeClass('hiddenarrow').parent().removeClass("disabledarrow");

                }
                scope.clearsecondcal();
                scope.check_if_in_between('second');


            };
            scope.gorightwithsecond = function(month, year) {
                // for(i=1;i<=42;i++){
                //     elem.find('.second-calendar .' + i).removeClass('vmf-disabled-date');
                // } 
                if (month === 11) {
                    year = parseInt(year) + 1;
                    month = 0;
                } else {
                    month = month + 1;
                }
                var firstday = new Date(year, month, 1);
                firstday = firstday.getDay();
                var lastday = new Date(year, month + 1, 0);
                var lastdate = lastday.getDate();
                var daycount = 1;
                cal_data_second = [];
                i = firstday;
                counter = lastdate;
                while (counter !== 0) {
                    cal_data_second[i++] = daycount++;

                    counter = counter - 1;
                }
                scope.second_cal = cal_data_second;
                scope.second_month = month;
                scope.second_year = year;
                if(scope.second_month ===(scope.first_month+1) && scope.first_year === scope.second_year){
                    // elem.find('.second-calendar .arrow-left').hide();
                }else{
                    elem.find('.second-calendar .arrow-left').show();

                }
                scope.clearsecondcal();
                ////console.log('go right with second');
                scope.check_if_in_between('second');
                if(scope.second_month ===(scope.first_month) && scope.first_year === scope.second_year){
                    elem.find('.second-calendar .arrow-left').addClass('hiddenarrow').parent().addClass("disabledarrow");
                }else{
                    elem.find('.second-calendar .arrow-left').removeClass('hiddenarrow').parent().removeClass("disabledarrow");

                }



            };
            scope.$watch("first_year", function(newval, oldval) {
                newval = parseInt(newval);
                if (newval) {
                    if(scope.first_selected_date && !scope.second_selected_date){
                        scope.first_selected_date = undefined;
                    }   
                    if((newval > scope.second_year )){
                        ////console.log('changing years');
                        newval = parseInt(newval);
                        scope.first_year = parseInt(newval);                  
                        j = 0;
                        scope.secondyearlist = [];
                        for (i = scope.first_year; i <= (scope.first_year + 25); i++) {
                            scope.secondyearlist[j++] = i;
                        }   
                        ////console.log('replacing the dropdown');               
                        scope.gorightwithfirst(scope.first_month - 1, newval);
                        // elem.find('.secondcaldir').replaceWith($compile('<div vmf-select-list model="second_year" list="secondyearlist" class="yearDropDown secondcaldir"></div>')(scope));
                        
                        
                        $timeout(function() {
                            //console.log('this is changing the year');
                            elem.find('.secondcaldir').replaceWith('<div vmf-select-list model="second_year" list="secondyearlist" pre-select-ind="0" class="yearDropDown secondcaldir"></div>');
                            $compile(elem.find('.secondcaldir')[0])(scope);
                            return;
                            
                        });
                        //console.log('this is changing the year')
                        elem.find('.secondcaldir .current-selection').text(scope.secondyearlist[0]);    
                        
                        if(scope.second_selected_date){
                            if(scope.first_month === scope.second_month){
                                scope.gorightwithsecond(scope.second_month+1,newval);
                            }
                            

                        }else{
                            scope.gorightwithsecond(scope.first_month, newval);    
                        }
                        
                    }else{
                        scope.gorightwithfirst(scope.first_month - 1, newval);
                        scope.first_year = parseInt(newval);   
//                        console.log(scope.first_year);
                        j = 0;
                        scope.secondyearlist = [];
                        for (i = scope.first_year; i <= scope.endyear; i++) {
                            scope.secondyearlist[j++] = i;
                        }  
                        //console.log(scope.secondyearlist);
                        $timeout(function() {
//                            console.log('this is changing the second year');
//                            console.log(scope.second_year);
//                            console.log(scope.secondyearlist);
//                            console.log(scope.secondyearlist.indexOf(scope.second_year));
                            var newIndex = scope.secondyearlist.indexOf(scope.second_year);
                            str = '<div vmf-select-list model="second_year" list="secondyearlist" pre-select-ind="';
                            str += newIndex;
                            str += '" class="yearDropDown secondcaldir"></div>';
                            elem.find('.secondcaldir').replaceWith( str );
                            $compile(elem.find('.secondcaldir')[0])(scope);
                            return;
                            
                        });
                        //  if(scope.second_selected_date){
                        //     if(scope.first_month === scope.second_month){
                        //         // scope.gorightwithsecond(scope.second_month+1,newval);
                        //     }
                            

                        // }else{
                        //     // scope.gorightwithsecond(scope.first_month, newval);    
                        // }


                    }
                }
                
            });

            scope.$watch("second_year", function(newval, oldval) {
                if (newval) {
                    ////console.log("changing second year");
                    //////console.log(scope.second_month);
                    scope.second_year = parseInt(newval);
                    //////console.log(scope.second_year);
                    var index = scope.secondyearlist.indexOf(newval);
                    //console.log('this is changing the year')
                    elem.find('.secondcaldir .current-selection').text(scope.secondyearlist[index]);
                    ////console.log(scope.second_selected_date)
                    if(scope.second_selected_date && scope.second_month === (scope.second_selected_date.split('/')[1]-1)){
                        scope.second_selected_date = newval +'/'+ scope.second_selected_date.split('/')[1] +'/'+ scope.second_selected_date.split('/')[2]  ;

                    }
                    if(scope.second_month < scope.first_month){
                        scope.gorightwithsecond(scope.first_month - 1, scope.second_year);
                    }else{
                        scope.gorightwithsecond(scope.second_month - 1, scope.second_year);    
                    }
                    


                }
            });

            scope.displayCalendar = function() {
                if( elem.find(".calIcon").hasClass("activeCal") ){
                    scope.hideCalendar();
                  }else{
                    elem.find(".calIcon").addClass("activeCal");
                    elem.find('.calendercontainer').css("visibility", "visible");
                    elem.find('.calendercontainer').closest('.vmf-calendar-drop').addClass('calendercontainerActive');
                    elem.find('.first-calendar .month').focus();
                    scope.calendar = true;
                    if(scope.first_selected_date && scope.second_selected_date){
                        //console.log('');
                    }
                }
                // for(i=cal_data_first.indexOf(1);i<=42;i++){
                //     elem.find('.first-calendar .' + i).removeClass('vmf-disabled-date');
                // }
                // for(i=cal_data_second.indexOf(1);i<=42;i++){
                //     elem.find('.second-calendar .' + i).removeClass('vmf-disabled-date');
                // }
                // scope.first_selected_date = "";
                // scope.second_selected_date = "";
            };
            scope.hideCalendar = function() {
                elem.find(".calIcon").removeClass("activeCal");
                elem.find('.calendercontainer').css("visibility", "hidden");
                elem.find('.calendercontainer').closest('.vmf-calendar-drop').removeClass('calendercontainerActive');
                if(scope.first_selected_date && scope.second_selected_date){
                    elem.find('.placeholdersjs').removeClass('placeholdersjs');
                }
                scope.calendar = false;
            };
            scope.convertMonth = function(m_index) {
                var m = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
                return m[m_index];

            };
            scope.month_double = function(m_index) {
                var m = ['00','01', '02', '03', '04', '05', '06', '07', '08', '09', '10', '11', '12'];
                return m[m_index];

            };
            scope.date_double = function(date){
                if((date < 9)){
                    var d = ['00','01', '02', '03', '04', '05', '06', '07', '08', '09'];
                    return d[date];
                }else{
                    return date;
                }
            };

            scope.selectFirstDate = function(date, month, year) {
                //console.log('select first date');
                // date = date;
                //////console.log(date);
                //////console.log(month);
                //////console.log(year);
                // if(!scope.first_selected_date || (scope.first_selected_date && scope.second_selected_date)){
                    if (cal_data_first[date]) {
                        for (i = 0; i < cal_data_first.length; i++) {
                            elem.find('.first-calendar .' + i).removeClass('activefirstcal');
                            elem.find('.first-calendar .' + i).removeClass('activeselectfirstcal');
                            // elem.find('.first-calendar .' + i).removeClass('vmf-disabled-date');
                        }
                        // for (i = cal_data_first.indexOf(1); i < date; i++) {
                        //     elem.find('.first-calendar .' + i).addClass('vmf-disabled-date');

                        // }

                        
                    }
                    // var temp_f = scope.first_year + '/' + (parseInt(scope.first_month)) + '/' + (parseInt(cal_data_first[date]));
                    // //console.log(temp_f);
                    temp_f = new Date(scope.first_year,parseInt(scope.first_month),parseInt(cal_data_first[date]));
                    //console.log(temp_f);
                    //console.log(scope.historic);
                    if(temp_f>scope.historic){
                        //console.log(temp_f);
                        //console.log(scope.historic);
                        scope.first_selected_date = scope.first_year + '/' + (parseInt(scope.first_month) + 1) + '/' + (parseInt(cal_data_first[date]));
                        scope.show_first_selected_date =  scope.month_double((parseInt(scope.first_month) + 1))   + '/' +  scope.date_double((parseInt(cal_data_first[date]))) + '/' +scope.first_year;
                        elem.find('.first-calendar .' + date).addClass('activeselectfirstcal');
                    // scope.show_date = scope.show_first_selected_date;    
                    }
                    
                    if(scope.second_selected_date){
                        var afsd = scope.first_selected_date.split('/');
                        var fsd = new Date(afsd[0],afsd[1]-1,afsd[2]);
                        var assd = scope.show_second_selected_date.split('/');
                        var ssd = new Date(parseInt(assd[2]),parseInt(assd[0])-1,parseInt(assd[1]));
                        //console.log(fsd);
                        //console.log(ssd);
                        if((fsd < ssd)){
                            scope.show_date = scope.show_first_selected_date + " to " + scope.show_second_selected_date; 
							elem.find(".error-msg").remove();
							elem.find(".has-error").removeClass("has-error");							
                        }
                        
                    }

                    scope.check_if_in_between('first');
                    scope.check_if_in_between('second');

                    // scope.clearsecondcal();
                    //////console.log(scope.first_selected_date);
                // }
                
            };
            scope.hoverFirstDate = function(date, month, year) {
                
                // if(!scope.first_selected_date || (scope.first_selected_date && scope.second_selected_date)){
                    if (cal_data_first[date]) {
                        for (i = 0; i < cal_data_first.length; i++) {
                            elem.find('.first-calendar .' + i).removeClass('hoverselectfirstcal');

                        }
                        for (i = 0; i < cal_data_first.length; i++) {
                            elem.find('.first-calendar .' + i).removeClass('activefirstcalhover');

                        }
                        for (i = date; i < cal_data_first.length; i++) {
                            elem.find('.first-calendar .' + i).addClass('activefirstcalhover');

                        }


                        // elem.find('.first-calendar').removeClass('hoverselectfirstcal');
                        elem.find('.first-calendar .' + date).addClass('hoverselectfirstcal');
                        //////console.log(date);

                    }
                // }
                
                


            };
            scope.hoverSecondDate = function(date, month, year) {
                //console.log('hover second date');               
                if (scope.first_selected_date && scope.first_month !== scope.second_month || (scope.first_selected_date && scope.first_year !== scope.second_year) ) {
                  
                    cfsd = scope.first_selected_date.split('/');
                    fsm = parseInt(cfsd[1]) - 1;
                    fsy = parseInt(cfsd[0]);
                    fsd = parseInt(cfsd[2]);
                    
                    if(parseInt(fsy) === parseInt(scope.first_year)){
                        ind = cal_data_first.indexOf(fsd);     
                    }else{
                        ind = cal_data_first.indexOf(1);
                    }
                   
                   for (i=0;i<cal_data_first.length;i++){
                        elem.find('.first-calendar .' + i).removeClass('activefirstcal');
                   }
                   for (i=ind;i<cal_data_first.length;i++){
                        elem.find('.first-calendar .' + i).addClass('activefirstcal');
                        
                   }                 
                    if (cal_data_second[date] ) {
                        for (i = 0; i < cal_data_second.length; i++) {
                            elem.find('.second-calendar .' + i).removeClass('hoverselectsecondcal');
                            elem.find('.second-calendar .' + i).removeClass('activesecondcal');

                        }
                        for (i = 0; i < date; i++) {
                            if (cal_data_second[i]) {
                                elem.find('.second-calendar .' + i).addClass('activesecondcal');
                            }


                        } 
                        if(cal_data_second[date]){
                            elem.find('.second-calendar .' + date).addClass('hoverselectsecondcal');
                        }            
                                           
                    }
                }
                if(scope.first_selected_date && scope.first_month === month && scope.first_year === year){
                    
                    
                    cfsd = scope.first_selected_date.split('/');
                    fsm = parseInt(cfsd[1]) - 1;
                    fsy = parseInt(cfsd[0]);
                    fsd = parseInt(cfsd[2]);
                    

                   ind = cal_data_first.indexOf(fsd);
                   
                    if(date >= ind){
                        for (i = 0; i < cal_data_second.length; i++) {
                            elem.find('.second-calendar .' + i).removeClass('hoverselectsecondcal');
                            elem.find('.second-calendar .' + i).removeClass('activesecondcal');

                        }
                        for (i = ind; i < date; i++) {
                            if (cal_data_second[i]) {
                                ////console.log(i);
                                ////console.log(cal_data_second[i]);

                                if(elem.find('.second-calendar .'+ i).text()!==''){
                                    elem.find('.second-calendar .' + i).addClass('activesecondcal');    
                                }
                                
                            }


                        }    
                        if(cal_data_second[date]){
                            elem.find('.second-calendar .' + date).addClass('hoverselectsecondcal');
                        }           
                        for (i=0;i<cal_data_first.length;i++){
                            elem.find('.first-calendar .' + i).removeClass('activefirstcal');
                        }
                        for (i=ind;i<=date;i++){
                            if(cal_data_first[i]){
                                elem.find('.first-calendar .' + i).addClass('activefirstcal');
                            }

                            
                                
                        }



                    }
                }


            };
            scope.leavingfirstcal = function() {
                for (i = 0; i < cal_data_first.length; i++) {
                    elem.find('.first-calendar .' + i).removeClass('hoverselectfirstcal');

                }
                for (i = 0; i < cal_data_first.length; i++) {
                    elem.find('.first-calendar .' + i).removeClass('activefirstcalhover');

                }
            };
            scope.clearsecondcal = function() {
                if((scope.first_selected_date && scope.second_selected_date)){
                    //////console.log('leaving second calendar mouseover');
                    for (i = 0; i < 41; i++) {
                        elem.find('.second-calendar .' + i).removeClass('hoverselectsecondcal');
                        elem.find('.second-calendar .' + i).removeClass('activesecondcal');
                        elem.find('.second-calendar .' + i).removeClass('activeselectSecondcal');
                        elem.find('.second-calendar .' + i).removeClass('vmf-disabled-date');

                    }
                    //////console.log('inside if first left');
                    //////console.log(scope.first_selected_date);
                    var cfsd = scope.first_selected_date.split('/');
                    var fsm = parseInt(cfsd[1]) - 1;
                    var fsy = parseInt(cfsd[0]);
                    var fsd = parseInt(cfsd[2]);
                    

                   var ind = cal_data_first.indexOf(fsd);
                   // for (i=0;i<cal_data_first.length;i++){
                   //      elem.find('.first-calendar .' + i).removeClass('activefirstcal');
                   // }
                   // for (i = 0; i < cal_data_second.length; i++) {
                   //      elem.find('.second-calendar .' + i).removeClass('hoverselectsecondcal');
                   //      elem.find('.second-calendar .' + i).removeClass('activesecondcal');

                   //  }

                }
                
            };
            scope.clearfirstcal = function(){
                if((scope.first_selected_date && scope.second_selected_date)){
                    //////console.log('leaving second calendar mouseover');
                    for (i = 0; i <= 41; i++) {
                        elem.find('.first-calendar .' + i).removeClass('activeselectfirstcal');
                        elem.find('.first-calendar .' + i).removeClass('activefirstcal');
                        elem.find('.first-calendar .' + i).removeClass('activeselectSecondcal');
                        elem.find('.first-calendar .' + i).removeClass('vmf-disabled-date');
                         // elem.find('.first-calendar .' + i).removeClass('activefirstcal');


                    }
                    

                }

            };
            scope.leavingsecondcal = function() {
                // if(!scope.second_selected_date && scope.first_selected_date){
                    //////console.log('leaving second calendar mouseover');
                    for (i = 0; i < cal_data_second.length; i++) {
                        elem.find('.second-calendar .' + i).removeClass('hoverselectsecondcal');
                        elem.find('.second-calendar .' + i).removeClass('activesecondcal');

                    }
                    //////console.log('inside if first left');
                    //////console.log(scope.first_selected_date);
                    // var cfsd = scope.first_selected_date.split('/');
                    // var fsm = parseInt(cfsd[1]) - 1;
                    // var fsy = parseInt(cfsd[0]);
                    // var fsd = parseInt(cfsd[2]);
                    

                   // var ind = cal_data_first.indexOf(fsd);
                   for (i=0;i<cal_data_first.length;i++){
                        elem.find('.first-calendar .' + i).removeClass('activefirstcal');
                   }
                   for (i = 0; i < cal_data_second.length; i++) {
                        elem.find('.second-calendar .' + i).removeClass('hoverselectsecondcal');
                        elem.find('.second-calendar .' + i).removeClass('activesecondcal');

                    }
                if(scope.first_selected_date && scope.second_selected_date){
                    scope.check_if_in_between('first');
                    scope.check_if_in_between('second');    
                }
                



                // }
                
            };

            scope.selectSecondDate = function(date, month, year) {
                ////console.log('select second date');
                if(scope.second_selected_date){
                    var ssd = new Date(scope.second_selected_date);
                    var ssdate = ssd.getDate();
                    elem.find('.second-calendar .' + cal_data_second.indexOf(ssdate)).removeClass('activeselectSecondcal');
                }

                if (scope.first_selected_date && cal_data_second[date]) {
                    var fd = parseInt(scope.first_selected_date.split('/')[2]);
                    // ////console.log(cal_data_first);
                    var ind = cal_data_first.indexOf(fd);
                    if(scope.first_month === month){
                        if(date >= ind){
                            
                            scope.second_selected_date = scope.second_year + '/' + (parseInt(scope.second_month) + 1) + '/' + (parseInt(cal_data_second[date]));
                            scope.date_range = scope.first_selected_date + " to " + scope.second_selected_date;
                            scope.show_second_selected_date =  scope.month_double((parseInt(scope.second_month) + 1))  + '/' + scope.date_double((parseInt(cal_data_second[date]))) + '/' + scope.second_year;
                            scope.show_date = scope.show_first_selected_date + " to " + scope.show_second_selected_date; 
                            elem.find('.second-calendar .'+date).addClass('activeselectSecondcal');
							elem.find(".error-msg").remove();
							elem.find(".has-error").removeClass("has-error");
                            scope.hideCalendar();
                        }


                    }else{
                        
                        scope.second_selected_date = scope.second_year + '/' + (parseInt(scope.second_month) + 1) + '/' + (parseInt(cal_data_second[date]));
                        scope.date_range = scope.first_selected_date + " to " + scope.second_selected_date;
                        scope.show_second_selected_date = scope.month_double((parseInt(scope.second_month) + 1)) + '/' +  scope.date_double((parseInt(cal_data_second[date]))) + '/' + scope.second_year;
                        scope.show_date = scope.show_first_selected_date + " to " + scope.show_second_selected_date; 
                        elem.find('.second-calendar .'+date).addClass('activeselectSecondcal');
						elem.find(".error-msg").remove();
						elem.find(".has-error").removeClass("has-error");
                        scope.hideCalendar();


                    }
                                        
                    //////console.log(scope.second_selected_date);
                    
                    //////console.log(scope.date_range);

                    // if(scope.first_selected_date){
                    //              if(cal_data_second[date]){
                    //              for (i=0;i< cal_data_second.length;i++){
                    //                  elem.find('.second-calendar .' + i).removeClass('hoverselectsecondcal');
                    //                  elem.find('.second-calendar .' + i).removeClass('activesecondcal');

                    //              }
                    //              for (i=0;i< date;i++){
                    //                  elem.find('.second-calendar .' + i).addClass('activesecondcal');

                    //              }

                    //              // elem.find('.first-calendar').removeClass('hoverselectfirstcal');
                    //              elem.find('.second-calendar .' + date).addClass('hoverselectsecondcal');
                    //              //////console.log(date);

                    //          }


                    //          }


                    // publishing the custom-event (provided through the scope-options of the directive) 
                    if( scope.customeventname ){
                        scope.publish(scope.customeventname, {
                            'fromDate': scope.first_selected_date,
                            'toDate': scope.second_selected_date
                        });
                    }
                    
                }

            };

            // keyboard events
            scope.onKeydownfirstcal = function(e,first_month,first_year){
                //////console.log(e.keyCode);
                if(e.keyCode === 39){
                    scope.gorightwithfirst(first_month,first_year);
                }
                if(e.keyCode === 37){
                    scope.goleftwithfirst(first_month,first_year);
                }
            }; 
            scope.keyDateChangeFirst =function(e,x,y,z){
                //////console.log(e.keyCode);
                if(e.keyCode === 13){
                   
                    elem.find('.second-calendar .month').focus();
                    scope.selectFirstDate(x,y,z);

                }

                
            };
            scope.checkEmpty = function(val){
                // //////console.log("checkEmpty");
                // //////console.log(val);
                if(val){
                    return true;
                }else{
                    return false;
                }

            };


            $timeout(function() {
                scope.check_if_in_between('first');
                scope.check_if_in_between('second');
                // elem.find('.current-selection').text(scope.first_year);
                // elem.find('.second-calendar .arrow-left').hide();
                // var ul = elem.find('.secondcaldir ul');
                // var scrollPane = ul.jScrollPane({
                //     showArrows: true,
                //     verticalArrowPositions: 'after'
                // });

                // $(".jspDrag").bind('click',function(event) {
                //         event.stopImmediatePropagation();
                //     }
                // );
            });
            
            elem.bind('click',function(e){
                e.stopPropagation();
            });
            $document.bind('click.calendarDirective',function(){
                scope.hideCalendar();
            });

            scope.check_if_in_between = function(calindex){
                //console.log('check if in between ');
                var fsd;
                var ind;
                if(scope.first_selected_date && scope.second_selected_date){
                    var cfsd = scope.first_selected_date.split('/');
                    var fsm = parseInt(cfsd[1]) - 1; 
                    var fsy = parseInt(cfsd[0]);
                    fsd = parseInt(cfsd[2]);                     
                    ind = cal_data_first.indexOf(fsd);

                    var cssd = scope.second_selected_date.split('/');
                    var ssm = parseInt(cssd[1]) - 1; 
                    var ssy = parseInt(cssd[0]);
                    var ssd = parseInt(cssd[2]);                     
                    var sind = cal_data_second.indexOf(ssd);

                    if(scope.first_month === fsm && parseInt(scope.first_year) === fsy && calindex === 'first'){
                        scope.highlightfirst();

                    }

                    if(scope.second_month === ssm && parseInt(scope.second_year) === ssy && calindex === 'second'){
                        scope.clearsecondcal();
                        scope.highlightsecond();


                    }
                    var firstsdate = new Date(scope.first_selected_date);
                    var secondsdate = new Date(scope.second_selected_date);
                    // ////console.log(firstsdate);
                    // ////console.log(secondsdate);
                    if(calindex==="first"){
                        ////console.log('inside to check for highlight whole');
                        firstdateofmonth = new Date(scope.first_year,scope.first_month,1);
                        if(scope.first_month === 11){
                            lastdateofmonth = new Date(scope.first_year+1,0,0);
                        }else{
                            lastdateofmonth = new Date(scope.first_year,scope.first_month+1,0);
                        }
                        if(firstdateofmonth >= firstsdate && lastdateofmonth <= secondsdate){
                            ////console.log('in between the selected dates');
                            scope.fullhighlightfirst(firstdateofmonth,lastdateofmonth);
                        }
                        if(firstdateofmonth <= secondsdate && secondsdate <= lastdateofmonth){
                            if(firstdateofmonth <= firstsdate){
                                ////console.log('we have both here');
                                scope.highlight_both_in_first(firstdateofmonth,lastdateofmonth,firstsdate,secondsdate,false);
                            }else{
                                ////console.log('Your r right bro we have an end date here.');
                                scope.highlight_both_in_first(firstdateofmonth,lastdateofmonth,firstdateofmonth,secondsdate,true);
                            }
                            
                        }
                                                
                        // ////console.log(firstdateofmonth);
                        // ////console.log(lastdateofmonth);
                    }
                    if(calindex==="second"){

                        ////console.log('full highlight for second calendar ');
                        firstdateofmonth = new Date(scope.second_year,scope.second_month,1);
                        if(scope.second_month === 11){
                            lastdateofmonth = new Date(scope.second_year+1,0,0);
                        }else{
                            lastdateofmonth = new Date(scope.second_year,scope.second_month+1,0);
                        }
                        if(firstdateofmonth > firstsdate && lastdateofmonth < secondsdate){
                            ////console.log('in between the selected dates');
                            scope.fullhighlightsecond(firstdateofmonth,lastdateofmonth);
                        }
                        if(firstdateofmonth <= firstsdate && firstsdate <= lastdateofmonth){
                            if(secondsdate <= lastdateofmonth){
                                ////console.log('we have both here for second month');
                                scope.highlight_both_in_second(firstdateofmonth,lastdateofmonth,firstsdate,secondsdate,false);
                            }else{
                                ////console.log('Your r right bro we have an start date here.');
                                scope.highlight_both_in_second(firstdateofmonth,lastdateofmonth,firstsdate,lastdateofmonth,true);
                            }
                            
                        }

                                                
                        ////console.log(firstdateofmonth);
                        ////console.log(lastdateofmonth);
                        
                    }



                }
                if(calindex==='first'){
                    firstdateofmonth = new Date(scope.first_year,scope.first_month,1);
                    if(scope.first_month === 11){
                        lastdateofmonth = new Date(scope.first_year+1,0,0);
                    }else{
                        lastdateofmonth = new Date(scope.first_year,scope.first_month+1,0);
                    }
                    if(firstdateofmonth <= scope.historic && scope.historic <= lastdateofmonth){
                        //console.log('disabled dates in first calendar');
                        for (i = 0; i <= 41; i++) {
                            elem.find('.first-calendar .' + i).removeClass('vmf-disabled-date');

                        }
                        for (i = cal_data_first.indexOf(1); i <= cal_data_first.indexOf(scope.historic.getDate()); i++) {
                            elem.find('.first-calendar .' + i).addClass('vmf-disabled-date');

                        }

                    }else if(lastdateofmonth< scope.historic){
                        for (i = 0; i <= 41; i++) {
                            elem.find('.first-calendar .' + i).removeClass('vmf-disabled-date');

                        }
                        for (i = cal_data_first.indexOf(1); i <= cal_data_first.indexOf(lastdateofmonth.getDate()); i++) {
                            elem.find('.first-calendar .' + i).addClass('vmf-disabled-date');

                        }

                    }else{
                        for (i = 0; i <= 41; i++) {
                            elem.find('.first-calendar .' + i).removeClass('vmf-disabled-date');

                        }


                    }
                    if(scope.first_selected_date && !scope.second_selected_date){
                        //console.log('check if in between and only first selected date');
                        //console.log(scope.first_selected_date);
                        fsd = new Date(scope.first_selected_date);
                        //console.log(fsd);
                        if(firstdateofmonth <= fsd && fsd <= lastdateofmonth){
                            ind = cal_data_first.indexOf(parseInt(fsd.getDate()));
                            elem.find('.first-calendar .' + ind).addClass('activeselectfirstcal');
                            elem.find('.first-calendar .' + ind).addClass('activefirstcal');
                        }
                    }



                }else{
                    firstdateofmonth = new Date(scope.second_year,scope.second_month,1);
                    if(scope.first_selected_date){
                        split_first = scope.first_selected_date.split('/');
                        temp_check = new Date(parseInt(split_first[0]),parseInt(split_first[1] - 1),parseInt(split_first[2])); 
                    }else{  
                        temp_check = scope.historic;
                    }
                    if(scope.second_month === 11){
                        lastdateofmonth = new Date(scope.second_year+1,0,0);
                    }else{
                        lastdateofmonth = new Date(scope.second_year,scope.second_month+1,0);
                    }
                    if(firstdateofmonth <= temp_check && temp_check <= lastdateofmonth){
                        //console.log('disabled dates in second calendar');
                        for (i = 0; i <= 41; i++) {
                            elem.find('.second-calendar .' + i).removeClass('vmf-disabled-date');

                        }
                        for (i = cal_data_second.indexOf(1); i <= cal_data_second.indexOf(temp_check.getDate()); i++) {
                            elem.find('.second-calendar .' + i).addClass('vmf-disabled-date');

                        }
                    }else if(lastdateofmonth < temp_check){
                        for (i = 0; i <= 41; i++) {
                            elem.find('.second-calendar .' + i).removeClass('vmf-disabled-date');

                        }
                        for (i = cal_data_second.indexOf(1); i <= cal_data_second.indexOf(lastdateofmonth.getDate()); i++) {
                            elem.find('.second-calendar .' + i).addClass('vmf-disabled-date');

                        }


                    }else{
                        for (i = 0; i <= 41; i++) {
                            elem.find('.second-calendar .' + i).removeClass('vmf-disabled-date');

                        }


                    }





                }



            };
            scope.highlight_both_in_second = function(first,last,firstsdate,secondsdate,onlyenddate){
                ////console.log('highlight_both_in_second');
                scope.clearsecondcal();
                var daycount = 1;
                cal_data = [];
                firstday = first.getDay();
                lastdate = last.getDate();
                i = firstday;
                counter = lastdate;
                while (counter !== 0) {
                    cal_data[i++] = daycount++;

                    counter = counter - 1;
                }
                // var findex = cal_data.indexOf(fday);
                var fstart = firstsdate.getDate();
                var fend = secondsdate.getDate();
                if(!onlyenddate){
                    elem.find('.second-calendar .'+ cal_data.indexOf(secondsdate.getDate()) ).addClass('activeselectSecondcal');
                }
                // elem.find('.first-calendar .'+ cal_data.indexOf(fend)).addClass('activeselectSecondcal');
                for(i=cal_data.indexOf(firstsdate.getDate());i<=cal_data.indexOf(secondsdate.getDate());i++){
                    elem.find('.second-calendar .'+ i).addClass('activesecondcal');
                }
                // elem.find('.first-calendar .'+ cal_data.indexOf(fend)).addClass('activeselectSecondcal');

            };
            scope.highlight_both_in_first = function(first,last,firstsdate,secondsdate,onlyenddate){
                ////console.log('highlight_both_in_first');
                scope.clearfirstcal();
                var daycount = 1;
                cal_data = [];
                firstday = first.getDay();
                lastdate = last.getDate();
                i = firstday;
                counter = lastdate;
                while (counter !== 0) {
                    cal_data[i++] = daycount++;

                    counter = counter - 1;
                }
                // var findex = cal_data.indexOf(fday);
                var fstart = firstsdate.getDate();
                var fend = secondsdate.getDate();
                if(!onlyenddate){
                    elem.find('.first-calendar .'+ cal_data.indexOf(fstart) ).addClass('activeselectfirstcal');
                }
                // elem.find('.first-calendar .'+ cal_data.indexOf(fend)).addClass('activeselectSecondcal');
                for(i=cal_data.indexOf(fstart);i<=cal_data.indexOf(fend);i++){
                    elem.find('.first-calendar .'+ i).addClass('activefirstcal');
                }
                // elem.find('.first-calendar .'+ cal_data.indexOf(fend)).addClass('activeselectSecondcal');

            };
            scope.fullhighlightfirst = function(first,last){
                ////console.log('fullhighlightfirst');
                var daycount = 1;
                cal_data = [];
                firstday = first.getDay();
                lastdate = last.getDate();
                i = firstday;
                counter = lastdate;
                while (counter !== 0) {
                    cal_data[i++] = daycount++;

                    counter = counter - 1;
                }
                // var findex = cal_data.indexOf(fday);
                for(i=firstday;i<=cal_data.indexOf(lastdate);i++){
                    elem.find('.first-calendar .'+ i).addClass('activefirstcal');
                }

            };
            scope.fullhighlightsecond = function(first,last){
                ////console.log('fullhighlightsecond');
                scope.clearsecondcal();
                var daycount = 1;
                cal_data = [];
                firstday = first.getDay();
                lastdate = last.getDate();
                i = firstday;
                counter = lastdate;
                while (counter !== 0) {
                    cal_data[i++] = daycount++;

                    counter = counter - 1;
                }
                // var findex = cal_data.indexOf(fday);
                for(i=firstday;i<=cal_data.indexOf(lastdate);i++){
                    elem.find('.second-calendar .'+ i).addClass('activesecondcal');
                }

            };
            scope.highlightfirst = function(){
                var fday = parseInt(scope.first_selected_date.split('/')[2]);
                var fy = parseInt(scope.first_selected_date.split('/')[0]);
                var fm = parseInt(scope.first_selected_date.split('/')[1])-1;
                var lastday = new Date(fy, fm + 1, 0);
                var lastdate = lastday.getDate();
                var firstday = new Date(fy, fm, 1);
                firstday = firstday.getDay();
                var cal_data = [];
                var daycount = 1;
                
                
                cal_data = [];
                i = firstday;
                counter = lastdate;
                while (counter !== 0) {
                    cal_data[i++] = daycount++;

                    counter = counter - 1;
                }
                var findex = cal_data.indexOf(fday);
                elem.find('.first-calendar .' + findex).addClass('activeselectfirstcal');
                elem.find('.first-calendar .' + findex).addClass('activefirstcal');
                var end_date  = scope.find_if_in_same();
                if(end_date){
                    end_date = parseInt(scope.second_selected_date.split('/')[2]);
                    end_date = cal_data_second.indexOf(end_date);
                }else{
                    end_date = cal_data.length;
                }
                for(i=findex;i<end_date;i++){
                        elem.find('.first-calendar .' + i).addClass('activefirstcal');                    
                }
            };
            scope.highlightsecond = function(){
                ////console.log('highlight second being called.');
                var fday = parseInt(scope.second_selected_date.split('/')[2]);
                var fy = parseInt(scope.second_selected_date.split('/')[0]);
                var fm = parseInt(scope.second_selected_date.split('/')[1])-1;
                var lastday = new Date(fy, fm + 1, 0);
                var lastdate = lastday.getDate();
                var firstday = new Date(fy, fm, 1);
                firstday = firstday.getDay();
                var cal_data = [];
                daycount = 1;
                
                daycount = 1;
                scal_data = [];
                i = firstday;
                counter = lastdate;
                while (counter !== 0) {
                    scal_data[i++] = daycount++;

                    counter = counter - 1;
                }
                var findex = scal_data.indexOf(fday);
                // var firstdayindex = scal_data.indexOf(firstday);
                elem.find('.second-calendar .' + findex).addClass('activeselectsecondcal');
                elem.find('.second-calendar .' + findex).addClass('activesecondcal');
                var end_date  = scope.find_if_in_same();
                if(end_date){
                    end_date = parseInt(scope.second_selected_date.split('/')[2]);
                    end_date = cal_data_second.indexOf(end_date);
                }else{
                    end_date = scal_data.length;
                }
                for(i=firstday;i<findex;i++){
                        elem.find('.second-calendar .' + i).addClass('activesecondcal');                    
                }
                elem.find('.second-calendar .' + findex).addClass('activeselectSecondcal');                    
            };
            scope.find_if_in_same = function(){
                var fsm = parseInt(scope.first_selected_date.split('/')[1]);
                var fsy =  parseInt(scope.first_selected_date.split('/')[0]);
                var ssm = parseInt(scope.second_selected_date.split('/')[1]);
                var ssy =  parseInt(scope.second_selected_date.split('/')[0]);
                if(fsm === ssm && fsy === ssy){
                    return true;
                }else{
                    return false;
                }
                

            };

            scope.change_date_format = function(date_string){
                return "amit";
            };
			
			scope.$on('resetCalendar', function(){
				scope.clearsecondcal();
				scope.clearfirstcal();
			});

            // end for second

            template = '<div class="vmf-calContainer" ng-click="displayCalendar();"><input ng-model="show_date"  class="vmf-calInput" type="text" id="'+scope.calendarInputId+'" placeholder="Select Dates" readonly><span class="calIcon" ></span></div>' +
                '<div class="calendercontainer">' +
                '<div class="vmf-dateContainer tableBorder">' +
                '   <div class="calSubHeader">' +
                '       <span class="dateSubHead">From..' +
                '       </span>' +
                '       <div vmf-select-list model="first_year" list="firstyearlist"  pre-select-ind="'+ indexFirstCal +'" class="yearDropDown firstcaldir" show-arrows="false">' +
                '       </div>' +
                '   </div>' +
                '<table class="table-condensed first-calendar">' +
                '   <thead>' +
                '      <tr>' +
                '         <th class="prev available"><a href="javascript:void(0)" ng-click="goleftwithfirst(first_month,first_year);" ><span class="arrow-left"></span></a></th>' +
                '         <th colspan="5" tabindex="0" ng-keyup="onKeydownfirstcal($event,first_month,first_year);" class="month" ng-bind="convertMonth(first_month);"> </th>' +
                '         <th class="next available"><a href="javascript:void(0)" ng-click="gorightwithfirst(first_month,first_year);" ><span class="arrow-right"></span></a></th>' +
                '      </tr>  ' +
                '      <tr>' +
                '         <th>S</th>' +
                '         <th>M</th>' +
                '         <th>T</th>' +
                '         <th>W</th>' +
                '         <th>T</th>' +
                '         <th>F</th>' +
                '         <th>S</th>' +
                '      </tr>' +
                '   </thead>' +
                '   <tbody ng-mouseleave = "leavingfirstcal();" ng-swipe-left="gorightwithfirst(first_month,first_year);" ng-swipe-right="goleftwithfirst(first_month,first_year);"  >' +
                '      <tr>' +
                '         <td ng-mouseover="hoverFirstDate(i,first_month,first_year);" tabindex="0" ng-keyup="keyDateChangeFirst($event,i,first_month,first_year);" ng-click="selectFirstDate(i,first_month,first_year);" ng-repeat="i in [0,1,2,3,4,5,6]" class="{{i}}" data-title="r0c0"><a href="javascript:void(0)" ng-if="checkEmpty(first_cal[i]);">{{first_cal[i]}}</a></td>' +

                '      </tr>' +
                '      <tr>' +
                '         <td ng-mouseover="hoverFirstDate(i,first_month,first_year);" tabindex="0" ng-keyup="keyDateChangeFirst($event,i,first_month,first_year);" ng-click="selectFirstDate(i,first_month,first_year);" ng-repeat="i in [7,8,9,10,11,12,13]" class="{{i}}" data-title="r0c0"><a href="javascript:void(0)" ng-if="checkEmpty(first_cal[i]);">{{first_cal[i]}}</a></td>' +

                '      </tr>' +
                '      <tr>' +
                '         <td ng-mouseover="hoverFirstDate(i,first_month,first_year);" tabindex="0" ng-keyup="keyDateChangeFirst($event,i,first_month,first_year);" ng-click="selectFirstDate(i,first_month,first_year);" ng-repeat="i in [14,15,16,17,18,19,20]" class="{{i}}" data-title="r0c0"><a href="javascript:void(0)" ng-if="checkEmpty(first_cal[i]);">{{first_cal[i]}}</a></td>' +
                '      </tr>' +
                '      <tr>' +
                '         <td ng-mouseover="hoverFirstDate(i,first_month,first_year);" tabindex="0" ng-keyup="keyDateChangeFirst($event,i,first_month,first_year);" ng-click="selectFirstDate(i,first_month,first_year);" ng-repeat="i in [21,22,23,24,25,26,27]" class="{{i}}" data-title="r0c0"><a href="javascript:void(0)" ng-if="checkEmpty(first_cal[i]);">{{first_cal[i]}}</a></td>' +
                '      </tr>' +
                '      <tr  >' +
                '         <td ng-mouseover="hoverFirstDate(i,first_month,first_year);" tabindex="0" ng-keyup="keyDateChangeFirst($event,i,first_month,first_year);" ng-click="selectFirstDate(i,first_month,first_year);" ng-repeat="i in [28,29,30,31,32,33,34]" class="{{i}}" data-title="r0c0"><a href="javascript:void(0)" ng-if="checkEmpty(first_cal[i]);">{{first_cal[i]}}</a></td>' +
                '      </tr>' +
                '      <tr  >' +
                '         <td ng-mouseover="hoverFirstDate(i,first_month,first_year);" tabindex="0" ng-keyup="keyDateChangeFirst($event,i,first_month,first_year);" ng-click="selectFirstDate(i,first_month,first_year);" ng-repeat="i in [35,36,37,38,39,40,41]" class="{{i}}" data-title="r0c0"><a href="javascript:void(0)" ng-if="checkEmpty(first_cal[i]);">{{first_cal[i]}}</a></td>' +
                '      </tr>' +
                '   </tbody>' +
                '</table>' +
                '</div>' +
                '<div class="vmf-dateContainer">' +
                '<div class="calSubHeader">' +
                '   <span class="dateSubHead">To..' +
                '   </span>' +
                '   <span ><div vmf-select-list show-arrows="false" model="second_year" list="secondyearlist" pre-select-ind="0" class="yearDropDown secondcaldir"></div></span>' +
                 
                '</div>' +
                '<table class="table-condensed second-calendar">' +
                '   <thead>' +
                '      <tr>' +
                '         <th class="prev available"><a href="javascript:void(0)" ng-click="goleftwithsecond(second_month,second_year);" ><span class="arrow-left"></span></a></th>' +

                '         <th colspan="5" class="month" ng-bind="convertMonth(second_month);"> </th>' +
                '         <th class="next available"><a href="javascript:void(0)" ng-click="gorightwithsecond(second_month,second_year);" ><span class="arrow-right"></span></a></th>' +
                '      </tr>' +
                '      <tr>' +
                '         <th>S</th>' +
                '         <th>M</th>' +
                '         <th>T</th>' +
                '         <th>W</th>' +
                '         <th>T</th>' +
                '         <th>F</th>' +
                '         <th>S</th>' +
                '      </tr>' +
                '   </thead>' +
                '   <tbody ng-mouseleave = "leavingsecondcal();" ng-swipe-left="gorightwithsecond(second_month,second_year);" ng-swipe-right="goleftwithsecond(second_month,second_year);" >' +
                '      <tr>' +
                '         <td ng-mouseover="hoverSecondDate(i,second_month,second_year);" ng-click="selectSecondDate(i,second_month,second_year);" ng-repeat="i in [0,1,2,3,4,5,6]" class="{{i}}" data-title="r0c0"><a href="javascript:void(0)" ng-if="checkEmpty(second_cal[i]);">{{second_cal[i]}}</a></td>' +

                '      </tr>' +
                '      <tr>' +
                '         <td ng-mouseover="hoverSecondDate(i,second_month,second_year);" ng-click="selectSecondDate(i,second_month,second_year);" ng-repeat="i in [7,8,9,10,11,12,13]" class="{{i}}" data-title="r0c0"><a href="javascript:void(0)" ng-if="checkEmpty(second_cal[i]);">{{second_cal[i]}}</a></td>' +

                '      </tr>' +
                '      <tr>' +
                '         <td ng-mouseover="hoverSecondDate(i,second_month,second_year);" ng-click="selectSecondDate(i,second_month,second_year);" ng-repeat="i in [14,15,16,17,18,19,20]" class="{{i}}" data-title="r0c0"><a href="javascript:void(0)">{{second_cal[i]}}</a></td>' +
                '      </tr>' +
                '      <tr>' +
                '         <td ng-mouseover="hoverSecondDate(i,second_month,second_year);" ng-click="selectSecondDate(i,second_month,second_year);" ng-repeat="i in [21,22,23,24,25,26,27]" class="{{i}}" data-title="r0c0"><a href="javascript:void(0)" ng-if="checkEmpty(second_cal[i]);">{{second_cal[i]}}</a></td>' +
                '      </tr>' +
                '      <tr>' +
                '         <td ng-mouseover="hoverSecondDate(i,second_month,second_year);" ng-click="selectSecondDate(i,second_month,second_year);" ng-repeat="i in [28,29,30,31,32,33,34]" class="{{i}}" data-title="r0c0"><a href="javascript:void(0)" ng-if="checkEmpty(second_cal[i]);">{{second_cal[i]}}</a></td>' +
                '      </tr>' +
                '      <tr>' +
                '         <td ng-mouseover="hoverSecondDate(i,second_month,second_year);" ng-click="selectSecondDate(i,second_month,second_year);" ng-repeat="i in [35,36,37,38,39,40,41]" class="{{i}}" data-title="r0c0"><a href="javascript:void(0)" ng-if="checkEmpty(second_cal[i]);">{{second_cal[i]}}</a></td>' +
                '      </tr>' +
                '   </tbody>' +
                '</table></div></div>';




            elem.append(template);
            // if(scope.customClass){
            //     angular.forEach(scope.customClass, function(item) {
            //         elem.find(item.selector).addClass(item.cusclass);


            //     });
            // }
            $compile(elem.contents())(scope);


        }

    };
}])



/* Calendar Directive Single */
.directive('vmfCalendarSingle', ['$compile', '$document', '$timeout', function($compile, $document, $timeout) {
    return {
        restrict: 'EA',
        scope: {
            sdate: '@',
            edate: '@'
            
        },
        controller: ['$scope', function($scope) {

           

        }],

        link: function(scope, elem, attrs) {
            var template;
            temp_start = scope.sdate.split('/');
            scope.startdate = new Date(temp_start[2],temp_start[1]-1,temp_start[0]);


            temp_end = scope.edate.split('/');
            scope.enddate = new Date(temp_end[2],temp_end[1]-1,temp_end[0]);

            //console.log(scope.startdate);
            //console.log(scope.enddate);

            scope.firstyearlist = [];
            for(i=scope.startdate.getFullYear();i<= scope.enddate.getFullYear();i++){
                scope.firstyearlist.push(i);
            }
          
            var today = new Date();
            var dd = today.getDate();
            var mm = today.getMonth(); //January is 0!
            var yyyy = today.getFullYear();
            scope.first_year = yyyy;
            var curIndex = scope.firstyearlist.indexOf(yyyy);
            //console.log(curIndex);

            scope.first_month = mm;
            var day = today.getDay();

            // scope.secondyearlist = new Array(10);
            // var j = 0;
            // for (i = scope.first_year; i <= (scope.first_year + 20); i++) {
            //     scope.secondyearlist[j++] = i;
            // }

            var lastday = new Date(yyyy, mm + 1, 0);

            var lastdate = lastday.getDate();
            

            var firstday = new Date(yyyy, mm, 1);
            
            firstday = firstday.getDay();
            
            var cal_data_first = [];
            var daycount = 1;
            
            daycount = 1;
            cal_data_first = [];
            i = firstday;
            counter = lastdate;
            while (counter !== 0) {
                cal_data_first[i++] = daycount++;

                counter = counter - 1;
            }
            
            daycount = 1;
        
            scope.first_cal = cal_data_first;
            
            mm = mm + 1;

            scope.second_year = yyyy;
            scope.second_month = mm;

            
            var slastday = new Date(yyyy, mm + 1, 0);
            var slastdate = slastday.getDate();
          

            var sfirstday = new Date(yyyy, mm, 1);
            sfirstday = sfirstday.getDay();
           



            var cal_data_second = [];
            daycount = 1;
            
            cal_data_first = [];
            i = sfirstday;
            counter = slastdate;
            while (counter !== 0) {
                cal_data_second[i++] = daycount++;

                counter = counter - 1;
            }


            
            daycount = 1;
         
            scope.second_cal = cal_data_second;
           

            scope.goleftwithfirst = function(month, year) {   
                    ////console.log('go left with first');
                    elem.find('.arrow-right').removeClass('hiddenarrow').parent().removeClass("disabledarrow");
                    var firstday;
                    if (scope.first_year === scope.firstyearlist[0] && scope.first_month === 0) {
                        
                        return;
                    }
                    for (i = 0; i < cal_data_first.length; i++) {
                        elem.find('.first-calendar .' + i).removeClass('activefirstcal');
                        elem.find('.first-calendar .' + i).removeClass('activeselectfirstcal');
                    }
                    if (month === 0) {
                        //////console.log('inside if ');
                        year = year - 1;
                        firstday = new Date(year, month, 1);   
                        if(firstday < scope.startdate){
                            //console.log('cant go beyond this date');
                            return;
                        }


                        //console.log('this is changing the year')
                        elem.find('.current-selection').text(year);
                        month = 11;
                    } else {
                        //////console.log('inside else');
                        month = month - 1;
                    }               
                    firstday = new Date(year, month, 1);               
                    firstday = firstday.getDay();       
                    var lastday = new Date(year, month + 1, 0);             
                    var lastdate = lastday.getDate();
                    var daycount = 1;
                    cal_data_first = [];
                    i = firstday;
                    counter = lastdate;
                    while (counter !== 0) {
                        cal_data_first[i++] = daycount++;

                        counter = counter - 1;
                    }          
                    scope.first_cal = cal_data_first;           
                    scope.first_month = month;
                    scope.first_year = year;
                    if(scope.first_selected_date){
                        var fd = new Date(scope.first_selected_date);
                        var firstdate = fd.getDate();
                        var fm = fd.getMonth();
                        var fy = fd.getFullYear();
                        var ind = cal_data_first.indexOf(firstdate);
                        if(fm === scope.first_month && fy === scope.first_year){
                            elem.find('.first-calendar .'+ ind).addClass('activeselectfirstcal');
                        }
                        
                    }
                    if(month ===(scope.startdate.getMonth()) && parseInt(year) === scope.startdate.getFullYear()){
                        elem.find('.arrow-left').addClass('hiddenarrow').parent().addClass("disabledarrow");
                    }else{
                        elem.find('.arrow-left').removeClass('hiddenarrow').parent().removeClass("disabledarrow");

                    }

               
                
            };


            scope.gorightwithfirst = function(month, year) { 
                    ////console.log('go right with first');
                    // if((month -1) ===(scope.enddate.getMonth()) && parseInt(year) === scope.enddate.getFullYear()){
                    //     console.log('cant go beyond this date');
                    //     return;
                    // }
                    elem.find('.arrow-left').removeClass('hiddenarrow').parent().removeClass("disabledarrow");

                    var firstday;
                    for (i = 0; i < cal_data_first.length; i++) {
                        elem.find('.first-calendar .' + i).removeClass('activefirstcal');
                        elem.find('.first-calendar .' + i).removeClass('activeselectfirstcal');
                    }
                    if (month === 11) {
                        //////console.log('inside if ');
                        year = parseInt(year) + 1;
                        //console.log('this is changing the year')
                        firstday = new Date(year, month, 1);
                        //console.log(firstday);
                        if(firstday > scope.enddate){
                            //console.log('cant go beyond this date');
                            return;
                        }
                        elem.find('.current-selection').text(year);

                        month = 0;

                    } else {
                        //////console.log('inside else');
                        month = month + 1;
                    }

               
                    
                    firstday = new Date(year, month, 1);
                    firstday = firstday.getDay();

                   

                    var lastday = new Date(year, month + 1, 0);
                    
                    var lastdate = lastday.getDate();
                   


                    var daycount = 1;
                    cal_data_first = [];
                    i = firstday;
                    counter = lastdate;
                    while (counter !== 0) {
                        cal_data_first[i++] = daycount++;

                        counter = counter - 1;
                    }
                   
                    scope.first_cal = cal_data_first;

                    //////console.log(cal_data_first);
                    scope.first_month = month;
                    scope.first_year = year;

                    if(scope.first_selected_date){
                        var fd = new Date(scope.first_selected_date);
                        var firstdate = fd.getDate();
                        var fm = fd.getMonth();
                        var fy = fd.getFullYear();
                        var ind = cal_data_first.indexOf(firstdate);
                        if(fm === scope.first_month && fy === scope.first_year){
                            elem.find('.first-calendar .'+ ind).addClass('activeselectfirstcal');
                        }
                        
                    }

                    if(month ===(scope.enddate.getMonth()) && parseInt(year) === scope.enddate.getFullYear()){
                        elem.find('.arrow-right').addClass('hiddenarrow').parent().addClass("disabledarrow");
                    }else{
                        elem.find('.arrow-right').removeClass('hiddenarrow').parent().removeClass("disabledarrow");

                    }
                    if(month ===(scope.startdate.getMonth()) && parseInt(year) === scope.startdate.getFullYear()){
                        elem.find('.arrow-left').addClass('hiddenarrow').parent().addClass("disabledarrow");


                    }

                    // if (scope.first_year === scope.second_year && (scope.first_month === scope.second_month || (scope.first_month -1) === scope.second_month)) {
                    //     //////console.log('inside if of gorightwithfirst');
                    //     scope.gorightwithsecond(scope.first_month, scope.first_year);
                    // }
                
            };



            // end for first            


            // functions to support left and right arrows of second calendar

           

            

         

            scope.displayCalendar = function() {
                elem.find(".calIcon").addClass("activeCal");
                elem.find('.calendercontainersingle').css("visibility", "visible").addClass('calendercontainerActive');
                elem.find('.first-calendar .month').focus();
                scope.calendar = true;
            };
            scope.hideCalendar = function() {
                elem.find(".calIcon").removeClass("activeCal");
                elem.find('.calendercontainersingle').css("visibility", "hidden").removeClass('calendercontainerActive');
                elem.find('.placeholdersjs').removeClass('placeholdersjs');
                scope.calendar = false;
            };

            scope.convertMonth = function(m_index) {
                var m = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
                return m[m_index];

            };
            scope.month_double = function(m_index) {
                var m = ['00','01', '02', '03', '04', '05', '06', '07', '08', '09', '10', '11', '12'];
                return m[m_index];

            };
            scope.month_double = function(m_index) {
                var m = ['00','01', '02', '03', '04', '05', '06', '07', '08', '09', '10', '11', '12'];
                return m[m_index];

            };
            scope.date_double = function(date){
                if((date < 9)){
                    var d = ['00','01', '02', '03', '04', '05', '06', '07', '08', '09'];
                    return d[date];
                }else{
                    return date;
                }
            };

            scope.selectFirstDate = function(date, month, year) {
                // date = date;
                //////console.log(date);
                //////console.log(month);
                //////console.log(year);
                if (cal_data_first[date]) {
                    for (i = 0; i < cal_data_first.length; i++) {
                        elem.find('.first-calendar .' + i).removeClass('activefirstcal');
                        elem.find('.first-calendar .' + i).removeClass('activeselectfirstcal');
                    }
                    // for (i = date; i < cal_data_first.length; i++) {
                    //     elem.find('.first-calendar .' + i).addClass('activefirstcal');

                    // }

                    elem.find('.first-calendar .' + date).addClass('activeselectfirstcal');
                }
                // var fdate = cal_data_first.indexOf(date);
                fdate = cal_data_first[date];
                scope.first_selected_date = scope.first_year + '/' + (parseInt(scope.first_month) + 1) + '/' + (parseInt(fdate));
                scope.date_range = scope.first_selected_date;
                scope.show_date = scope.month_double((parseInt(scope.first_month) + 1)) + '/' + scope.date_double((parseInt(fdate))) + '/' + scope.first_year;
                ////console.log(scope.date_range);
				elem.find(".error-msg").remove();
				elem.find(".has-error").removeClass("has-error");
                scope.hideCalendar();
                //////console.log(scope.first_selected_date);
            };

            scope.hoverFirstDate = function(date, month, year) {
                    ////console.log('hover first entry');
                    ////console.log(date);
                    ////console.log(month);
                    ////console.log(year);
                
                    if (scope.first_cal[date]) {
                        for (i = 0; i < scope.first_cal.length; i++) {
                            elem.find('.first-calendar .' + i).removeClass('hoverselectfirstcal');

                        }
                        for (i = 0; i < scope.first_cal.length; i++) {
                            elem.find('.first-calendar .' + i).removeClass('activefirstcalhover');

                        }
                        for (i = date; i < scope.first_cal.length; i++) {
                            elem.find('.first-calendar .' + i).addClass('activefirstcalhover');

                        }


                        // elem.find('.first-calendar').removeClass('hoverselectfirstcal');
                        elem.find('.first-calendar .' + date).addClass('hoverselectfirstcal');
                        //////console.log(date);

                    }
             
                
                


            };

    


            scope.leavingfirstcal = function() {
                ////console.log('leaving first cal');
                for (i = 0; i < cal_data_first.length; i++) {
                    elem.find('.first-calendar .' + i).removeClass('hoverselectfirstcal');

                }
                for (i = 0; i < cal_data_first.length; i++) {
                    elem.find('.first-calendar .' + i).removeClass('activefirstcalhover');

                }
            };

           

            

            // keyboard events
            scope.onKeydownfirstcal = function(e,first_month,first_year){
                //////console.log(e.keyCode);
                if(e.keyCode === 39){
                    scope.gorightwithfirst(first_month,first_year);
                }
                if(e.keyCode === 37){
                    scope.goleftwithfirst(first_month,first_year);
                }
            }; 
            scope.keyDateChangeFirst =function(e,x,y,z){
                //////console.log(e.keyCode);
                if(e.keyCode === 13){
                   
                    elem.find('.second-calendar .month').focus();
                    scope.selectFirstDate(x,y,z);

                }

                
            };
            scope.checkEmpty = function(val){
                // //////console.log("checkEmpty");
                // //////console.log(val);
                if(val){
                    return true;
                }else{
                    return false;
                }

            };


            $timeout(function() {
                // elem.find('.current-selection').text(scope.first_year);
                // elem.find('.second-calendar .arrow-left').hide();
                // var ul = elem.find('.secondcaldir ul');
                // var scrollPane = ul.jScrollPane({
                //     showArrows: true,
                //     verticalArrowPositions: 'after'
                // });

                // $(".jspDrag").bind('click',function(event) {
                //         event.stopImmediatePropagation();
                //     }
                // );
            });
            
            elem.bind('click',function(e){
                e.stopPropagation();
            });
            $document.bind('click.calendarDirective',function(){
                scope.hideCalendar();
            });

            scope.$watch("first_year", function(newval, oldval) {
                if (newval) {
                    scope.first_year = parseInt(newval);
                    // scope.secondyearlist = [];
                    var j = 0;
                    // for (i = scope.first_year; i <= (scope.first_year + 5); i++) {
                    //     scope.secondyearlist[j++] = i;
                    // }
                    //////console.log(scope.first_year);
                    // if(scope.first_selected_date){
                    //     scope.clearfirstcal(); 
                    // }
                   
                    scope.gorightwithfirst(scope.first_month - 1, newval);



                }
            });

            scope.$on('resetCalendar', function(){
				scope.clearsecondcal();
				scope.clearfirstcal();
			});

            // end for second

            template = '<div class="vmf-calContainer" ng-click="displayCalendar();" ><input ng-model="show_date"  class="vmf-calInput" type="text" id="coverageDates" placeholder="Select Dates" readonly><span class="calIcon" ></span></div>' +
                '<div class="calendercontainersingle">' +
                '<div class="vmf-dateContainer tableBorder">' +
                '   <div class="calSubHeader">' +
                '       <span class="dateSubHead">Year' +
                '       </span>' +
                '       <div vmf-select-list model="first_year" list="firstyearlist"  pre-select-ind="'+ curIndex +'" class="yearDropDown" show-arrows="false">' +
                '       </div>' +
                '   </div>' +
                '<table class="table-condensed first-calendar">' +
                '   <thead>' +
                '      <tr>' +
                '         <th class="prev available"><a href="javascript:void(0)" ng-click="goleftwithfirst(first_month,first_year);" ><span class="arrow-left"></span></a></th>' +
                '         <th colspan="5" tabindex="0" ng-keyup="onKeydownfirstcal($event,first_month,first_year);" class="month" ng-bind="convertMonth(first_month);"> </th>' +
                '         <th class="next available"><a href="javascript:void(0)" ng-click="gorightwithfirst(first_month,first_year);" ><span class="arrow-right"></span></a></th>' +
                '      </tr>  ' +
                '      <tr>' +
                '         <th>S</th>' +
                '         <th>M</th>' +
                '         <th>T</th>' +
                '         <th>W</th>' +
                '         <th>T</th>' +
                '         <th>F</th>' +
                '         <th>S</th>' +
                '      </tr>' +
                '   </thead>' +
                '   <tbody ng-mouseleave = "leavingfirstcal();" ng-swipe-left="gorightwithfirst(first_month,first_year);" ng-swipe-right="goleftwithfirst(first_month,first_year);"  >' +
                '      <tr>' +
                '         <td ng-mouseover="hoverFirstDate(i,first_month,first_year);" tabindex="0" ng-keyup="keyDateChangeFirst($event,i,first_month,first_year);" ng-click="selectFirstDate(i,first_month,first_year);" ng-repeat="i in [0,1,2,3,4,5,6]" class="{{i}}" data-title="r0c0"><a href="javascript:void(0)" ng-if="checkEmpty(first_cal[i]);">{{first_cal[i]}}</a></td>' +

                '      </tr>' +
                '      <tr>' +
                '         <td ng-mouseover="hoverFirstDate(i,first_month,first_year);" tabindex="0" ng-keyup="keyDateChangeFirst($event,i,first_month,first_year);" ng-click="selectFirstDate(i,first_month,first_year);" ng-repeat="i in [7,8,9,10,11,12,13]" class="{{i}}" data-title="r0c0"><a href="javascript:void(0)" ng-if="checkEmpty(first_cal[i]);">{{first_cal[i]}}</a></td>' +

                '      </tr>' +
                '      <tr>' +
                '         <td ng-mouseover="hoverFirstDate(i,first_month,first_year);" tabindex="0" ng-keyup="keyDateChangeFirst($event,i,first_month,first_year);" ng-click="selectFirstDate(i,first_month,first_year);" ng-repeat="i in [14,15,16,17,18,19,20]" class="{{i}}" data-title="r0c0"><a href="javascript:void(0)" ng-if="checkEmpty(first_cal[i]);">{{first_cal[i]}}</a></td>' +
                '      </tr>' +
                '      <tr>' +
                '         <td ng-mouseover="hoverFirstDate(i,first_month,first_year);" tabindex="0" ng-keyup="keyDateChangeFirst($event,i,first_month,first_year);" ng-click="selectFirstDate(i,first_month,first_year);" ng-repeat="i in [21,22,23,24,25,26,27]" class="{{i}}" data-title="r0c0"><a href="javascript:void(0)" ng-if="checkEmpty(first_cal[i]);">{{first_cal[i]}}</a></td>' +
                '      </tr>' +
                '      <tr ng-if="checkEmpty(first_cal[28]);" >' +
                '         <td ng-mouseover="hoverFirstDate(i,first_month,first_year);" tabindex="0" ng-keyup="keyDateChangeFirst($event,i,first_month,first_year);" ng-click="selectFirstDate(i,first_month,first_year);" ng-repeat="i in [28,29,30,31,32,33,34]" class="{{i}}" data-title="r0c0"><a href="javascript:void(0)" ng-if="checkEmpty(first_cal[i]);">{{first_cal[i]}}</a></td>' +
                '      </tr>' +
                '      <tr ng-if="checkEmpty(first_cal[35]);" >' +
                '         <td ng-mouseover="hoverFirstDate(i,first_month,first_year);" tabindex="0" ng-keyup="keyDateChangeFirst($event,i,first_month,first_year);" ng-click="selectFirstDate(i,first_month,first_year);" ng-repeat="i in [35,36,37,38,39,40,41]" class="{{i}}" data-title="r0c0"><a href="javascript:void(0)" ng-if="checkEmpty(first_cal[i]);">{{first_cal[i]}}</a></td>' +
                '      </tr>' +
                '   </tbody>' +
                '</table>' +
                '</div>' +
                '</div>';




            elem.append(template);
            // if(scope.customClass){
            //     angular.forEach(scope.customClass, function(item) {
            //         elem.find(item.selector).addClass(item.cusclass);


            //     });
            // }
            $compile(elem.contents())(scope);


        }

    };
}]);
/*jslint nomen: true, debug: true,
  evil: false, vars: true */
var folderTreeApp = angular.module('folderTreeApp', []);

folderTreeApp.directive('vmfFolderTree', ['$compile', '$timeout', '$http', 'ModalService', 'folderDataService', 'globalData' ,
    function($compile, $timeout, $http,  ModalService, folderDataService, globalData) {
        return {
            restrict: 'A',
            scope: { 
                tree: '=',
                multipleSelect: '@',
                rootName: '=',
                folderClickCallBack: '&',
                ajax: '='
            },
            link: function(scope, lElement, lAttrs) { 
 
                scope.treeChild = {};
                scope.getSearchData = {};
                scope.selectedFolderIdsArray = [];
                scope.searchedFolderData = [];
                scope.globalVars = globalVariables;

                scope.subscribe('folderTreeChange', function(getObj){
                    if(scope.rootName.instanceId === getObj.instanceId){
                        if(getObj.folderData !== null && getObj.folderData !== undefined)
                            scope.compiler(getObj.folderData);
                    }  
                });

                lElement.find(".folderTreeWrapper").attr("id", scope.rootName.text.split(" ").join(""));
                scope.thisTree = lElement.find("#" + scope.rootName.text.split(" ").join(""));

                scope.foldersArray = [];
                scope.completeFolderStack = [];

                var folderPadding = 28;
                var collapsePadding = 15;

                scope.calculatePadding = function(level) {

                    scope.folderPadding = (level * 28) + folderPadding;
                    scope.collapsePadding = (level * 28) + collapsePadding;
                };

                scope.lowestlevelGetter = function(tree) {
                    scope.levels = [];
                    tree.forEach(function(folder) {
                        scope.levels.push(folder.folderLevel);
                    });

                    return (scope.levels.sort()[0] - 1);
                };

                //console.log(scope.tree);
                scope.subFolderCreator = function(parentFolder) {

                    scope.folderObj = parentFolder;
                    scope.indexHolder = [];

                    if (scope.folderObj.hasSubFolders) {

                        scope.folderObj.subFolders = [];
                        scope.tree.forEach(function(folder, index) {
                            if (folder.parentFolderId === parentFolder.folderId) {

                                scope.folderCount++;
                                scope.folderObj.subFolders.push(folder);

                                scope.indexHolder.push(index);
                            }

                        });

                        scope.indexHolder.reverse().forEach(function(index) {
                            scope.tree.splice(index, 1);
                        });

                    } else {

                        scope.folderObj.subFolders = [];
                    }

                    return scope.folderObj;
                };

                scope.subFolderCreatorChild = function(parentFolder) {

                    scope.folderObj = parentFolder;
                    scope.indexHolder = [];

                    if (scope.folderObj.hasSubFolders) {

                        scope.folderObj.subFolders = [];
                        scope.treeChild.forEach(function(folder, index) {
                            if (folder.parentFolderId === parentFolder.folderId) {

                                scope.folderCount++;
                                scope.folderObj.subFolders.push(folder);

                                scope.indexHolder.push(index);
                            }

                        });

                        scope.indexHolder.reverse().forEach(function(index) {
                            scope.treeChild.splice(index, 1);
                        });

                    } else {

                        scope.folderObj.subFolders = [];
                    }

                    return scope.folderObj;
                };
                /*scope.$watch("tree", function(newVal, OldVal, scope) {

                    if (newVal !== OldVal && newVal.length > 1) {
                        scope.compiler(newVal);
                    }
                }, true);*/

                /* @responseFolders : Pass the entire tree structure as a variable , the html is then constructed by this function
                */

                scope.subscribe('ftLoading',function(data){
                    if(data.instanceId == scope.rootName.instanceId){
                        scope.thisTree.find('.folderTree .foldertreeUl').html('');
                    }
                });

                scope.compiler = function(responseFolders) {

                    folderDataService.allFolders = responseFolders || scope.tree;
                    scope.tree = JSON.parse(JSON.stringify(responseFolders));
                    angular.copy(scope.tree, scope.foldersArray);
                    angular.copy(scope.tree, scope.completeFolderStack);

                    scope.folderString = "<ul class='foldertreeUl'>";
                    scope.lowestlevel = scope.lowestlevelGetter(scope.tree) || 0;
                    scope.recursionCount = 0;
                    scope.folderHierarchyLevel = 1;

                    //Gets the number of recursions to be done.
                    for (var folderIndex in scope.tree) {
                        if (scope.tree[folderIndex].folderLevel > scope.lowestlevel) {
                            scope.recursionCount++;
                            scope.lowestlevel = scope.tree[folderIndex].folderLevel;
                        }

                    }

                    while (scope.recursionCount > scope.folderHierarchyLevel - 1) {
                        scope.lastIndex;
                        if (scope.folderHierarchyLevel === 1) {

                            folderArray = [];

                            scope.tree.forEach(function(folder, index) {
                                if (folder.folderType === "ROOT") {
                                    folderArray.push(folder);
                                }
                            });

                        }

                        scope.nextSet = [];
                        folderArray.forEach(function(folder, index) {

                            if (scope.folderHierarchyLevel === 1) {

                                folderArray[index] = scope.subFolderCreator(folder);
                                if (folderArray[index].subFolders.length) {
                                    /*ignore jslint start*/
                                    folderArray[index].subFolders.forEach(function(elem) {
                                        scope.nextSet.push(elem);
                                    });
                                    /*ignore jslint end*/
                                }

                            } else {

                                folder.subFolders = [];
                                folderArray[index] = scope.subFolderCreator(folder);

                                if (folderArray[index].subFolders.length) {
                                    /*ignore jslint start*/
                                    folderArray[index].subFolders.forEach(function(elem) {
                                        scope.nextSet.push(elem);
                                    });
                                    /*ignore jslint end*/
                                }

                            }

                            scope.lastIndex = index;
                        });

                        folderArray = scope.nextSet;
                        scope.folderHierarchyLevel++;
                    }

                    //console.log(scope.folderHierarchyLevel);
                    scope.firstIteration = true;
                    scope.totalIterations = 0;

                    while (scope.folderHierarchyLevel > 0) {

                        scope.calculatePadding(scope.totalIterations - 1);

                        if (scope.firstIteration) {

                            scope.folderString = scope.folderString + '<li ng-repeat="subfolder in tree" ng-class="{expandButton:subfolder.hasSubFolders, disabled:subfolder.folderAccess == \'NONE\', selected:selectedFolderIdsArray.indexOf(subfolder.folderId) !== -1}" id="{{subfolder.folderId}}" ftPath="{{subfolder.fullFolderPath}}" ftName="{{subfolder.folderName}}" ftLevel="{{subfolder.folderLevel}}" ftType="{{subfolder.folderType}}" ftAccess="{{subfolder.folderAccess}}">';
                            scope.firstIteration = false;
                        } else {

                            scope.folderString = scope.folderString + '<ul class="subfolder">' +
                                 '<li ng-repeat="subfolder in subfolder.subFolders" ng-class="{expandButton:subfolder.hasSubFolders,plus:subfolder.hasSubFolders, disabled:subfolder.folderAccess == \'NONE\', selected:selectedFolderIdsArray.indexOf(subfolder.folderId) !== -1}" id="{{subfolder.folderId}}" ftPath="{{subfolder.fullFolderPath}}" ftName="{{subfolder.folderName}}" ftLevel="{{subfolder.folderLevel}}" ftType="{{subfolder.folderType}}" ftAccess="{{subfolder.folderAccess}}">';
                        }

                        if(scope.rootName.showFolderOptions == true){

                        scope.folderString = scope.folderString + '<a href="javascript:void(0)" ng-class="{disabled:subfolder.folderAccess ==\'NONE\'}"  ng-click="toggleSelectFolder(subfolder.folderId,subfolder.fullFolderPath)"  style="padding-left: ' + scope.folderPadding + 'px" vmf-folder-options data-folder-options=subfolder.folderOptions data-this-tree = "thisTree"  ng-click="folderClickCallBack({$event:$event,this:this})" complete-folder-stack = "completeFolderStack" folder-data-ftype="subfolder.folderType">' +
                            '<span class="expandCollapseIcon" style="left: ' + scope.collapsePadding + 'px" ng-show="subfolder.hasSubFolders" ng-click="expander($event,subfolder.folderAccess); ajaxLoad($event,subfolder)">&nbsp;</span>';

                        } else {

                        scope.folderString = scope.folderString + '<a href="javascript:void(0)" ng-click="toggleSelectFolder(subfolder.folderId,subfolder.fullFolderPath)"  style="padding-left: ' + scope.folderPadding + 'px" data-this-tree = "thisTree"  ng-click="folderClickCallBack({$event:$event,this:this})" complete-folder-stack = "completeFolderStack" folder-data-ftype="subfolder.folderType">' +
                            '<span class="expandCollapseIcon" style="left: ' + scope.collapsePadding + 'px" ng-show="subfolder.hasSubFolders" ng-click="expander($event,subfolder.folderAccess); ajaxLoad($event,subfolder)">&nbsp;</span>';
                        
                        }

                        if (angular.lowercase(scope.multipleSelect) === "off" || angular.lowercase(scope.multipleSelect) === "false") {

                            scope.folderString = scope.folderString + '<div style="margin-left:10px;" class="custom-checkbox">'+
                            '<span class="folderIcon"></span>{{subfolder.folderName}} <span class="badge" ng-if="subfolder.folderType == \'ASP\' || subfolder.folderType == \'VCE\' || subfolder.folderType == \'CPL\'" badgeType="{{subfolder.folderType}}">{{subfolder.folderType}}</span></div>'; //disabledColor to be added.
                        } else {
                            scope.folderString = scope.folderString + '<div class="checkbox"><input id="{{subfolder.folderName}}" class="styled" ng-model="subfolder.checked" type="checkbox" ng-disabled="subfolder.folderAccess == \'NONE\'"><label for="{{subfolder.folderName}}">{{subfolder.folderName}}</label></div>';

                            //scope.folderString = scope.folderString + '<div vmf-checkbox-group class="vmf-checkbox-group" type="1" c-foldertype="subfolder.folderType" model="subfolder.checked" c-label="subfolder.folderName" c-disabled="subfolder.folderAccess == \'NONE\'"></div>';
                        }

                        scope.folderString = scope.folderString + '</a>';
                        scope.folderHierarchyLevel--;
                        scope.totalIterations++;
                    }

                    while (scope.totalIterations > 0) {

                        scope.folderString = scope.folderString + '</li></ul>';
                        scope.totalIterations--;
                    }

                    $timeout(function() {
                        scope.thisTree.find('.folderTree').find("ul").remove();
                        scope.thisTree.find('.folderTree').append($compile(scope.folderString)(scope));
                       
                    });

                    $timeout(function() {

                         $(scope.thisTree).find('.disabled > a')
                            .addClass('vmf-tooltip')
                            .attr('data-toggle','tooltip')
                            .attr('data-placement','bottom')
                            .attr('title',globalVariables.textDisabledFolders);

                        $(scope.thisTree).find('.badge').each(function(){
                            var getType = $(this).attr('badgeType');
                            $(this).attr('title',globalVariables['staticTextfor'+getType]);
                        });

                        scope.thisTree.find('.vmf-tooltip').tooltip();
                        scope.thisTree.find(".custom-checkbox").addClass("folderSelector");
                        scope.thisTree.find(".folderTree").find("input").removeAttr("ng-click");
                        scope.thisTree.find(".subfolder").has("li").parent("li").addClass("expandButton plus");
                        scope.thisTree.find(".subfolder:first").has("li").parent("li").removeClass("plus");
                        scope.thisTree.find(".expandCollapseIcon").eq(0).addClass("ng-hide");
                        if (angular.lowercase(scope.multipleSelect) === "off" || angular.lowercase(scope.multipleSelect) === "false") {
                            scope.thisTree.find(".folderTreeHeader a:first span").remove();
                            scope.thisTree.addClass("withoutCheckBox");
                        }
                    });

                    $timeout(function(){
                         $(".folderSelector").on("mouseover",function(e) {
                            var $this = $(this);
                            var max_width = $this.text().length * 10;
                            if (max_width > $this.innerWidth()) {
                            $this.attr("title", $this.text());
                            }else{
                            $this.removeAttr("title");
                            }
                         });
                    },100); 
                };

                // to remove the selectall checkbox - in the license folders heading above the folder tree
                if (angular.lowercase(scope.multipleSelect) === "off" || angular.lowercase(scope.multipleSelect) === "false") {
                    scope.thisTree.find(".folderTreeHeader a:first span").remove();
                }

                scope.compiler(scope.tree);

                scope.ajaxLoad = function(evt,object){

                    //console.log(evt,object);

                    scope.clickedParent = angular.element(evt.target);

                    //console.log(scope.clickedParent);

                    var isSubfoldersAvailable = $(evt.target).parent().siblings('.subfolder').children().length;

                    if(scope.ajax == true && isSubfoldersAvailable == 0){

                        scope.getTreeChild(evt, object, object['folderId']);

                        //scope.childCompilerArr(evt, object, scope.getChildData.folderContents);
                    }
                }   

                scope.getTreeChild = function(getEvt, getObject, parentFolderId){

                        //var getChildTreeUrlMod = globalVariables.getChildTreeUrl;

                        var getChildTreeUrlMod = globalVariables.getChildTreeUrl+"&iWantToSelection=viewLicense";

                         var postData =  { 
                            'navigatingFolderId' : parentFolderId
                        };

                         var postDataEncoded = $.param(postData);

                         var errorHtml = '<div  class="alert-box starlight-alert"><div class="alert alert-danger alert-dismissable">' 
                                            +'<a class="close icons-alert-close" data-dismiss="alert" type="button"></a>'
                                                +'<div class="row"> '
                                                    +'<span class="icons-alert-danger"></span>'
                                                    +'<div class="alert-text col-sm-10"> '
                                                        +'<span>'+globalVariables.txtFolderContentsNotAvailable+'</span>'
                                                    +'</div> '
                                                +'</div> '
                                           +' </div> '
                                        +'</div>';

                          var getDivHtml = $('#'+getObject.folderId+' a div');

                         if(getDivHtml.length == 0)
                            getDivHtml =  $('#'+getObject.folderId+' a label');

                          getDivHtml.append('<span class="ajaxLoader subFolderLoader"></span>');

                         $('#subfolderDataEmptyErr').html('').addClass('hide');

                        $http({
                            method: 'POST',
                            url: getChildTreeUrlMod,
                            data: postDataEncoded,
                            headers: {'Content-Type': 'application/x-www-form-urlencoded'}
                        }).
                        success(function(data, status, headers, config) {

                            if(data.error == true || data == null || data == undefined || data == ''){

                                $('#subfolderDataEmptyErr')
                                    .html(errorHtml)
                                    .removeClass('hide');

                            } else if(data.emptyTree == true || data.folderContents.length == 0){

                                 $('#subfolderDataEmptyErr')
                                    .html(errorHtml)
                                    .removeClass('hide');

                            } else {                            

                            scope.childCompilerArr(getEvt, getObject, data.folderContents); 

                            }  

                            getDivHtml.find('span.subFolderLoader').remove();                        

                        }).
                        error(function(data, status, headers, config) {

                            getDivHtml.find('span.subFolderLoader').remove(); 
                            // called asynchronously if an error occurs
                            // or server returns response with an error status.
                        });

                }

                scope.moveSearchedFolders = function(){

                    scope.getParentId = scope.clickedParent.parent().parent().attr('id');

                    angular.forEach(scope.searchedFolderData, function(value, key) {
                         angular.forEach(value.folderIdList, function(valueId, keyId) {
                            if(valueId == scope.getParentId){
                                var nextKey = keyId - 1;
                                scope.moveChildAfterFind(value,scope.getParentId,nextKey);
                            }
                        });
                    });
                }

                scope.moveChildAfterFind = function(dataObj, currParentId, nextParentKey){

                    if(nextParentKey !== 0){ // Enter loop if the searched element is not available as part of ajax response on expanding parent .

                        var getPadding = angular.element('#'+dataObj.folderId +' a').css('padding-left').replace("px", "");
                        var newPadding = parseInt(getPadding) + 28;
                        var getChildDom = angular.element('#'+dataObj.folderId);
                        angular.element('#'+dataObj.folderId).remove();

                        angular.element('#'+dataObj.folderIdList[nextParentKey]).after($compile(getChildDom)(scope));

                        angular.element('#'+dataObj.folderId+' a').css('padding-left', newPadding +'px');
                        angular.element('#'+dataObj.folderId).attr('rel',dataObj.folderIdList[nextParentKey]);

                    } else {
                        angular.element('[rel="'+dataObj.folderIdList[1]+'"]').remove();

                    }

                }

                scope.subscribe('findFolderEvt',function(data){

                    var ftOptions = {mode : data.ftInstanceId};

                    if(scope.rootName.instanceId === data.ftInstanceId){
                        scope.addNodeToFolderTree(data.folderObj,ftOptions);
                    }
                });

                scope.addNodeToFolderTree = function(getData,getOptions){

                    // If element already present in the DOM, Select it and show parent li's

                    var getElemObj = angular.element('#'+getData.folderId);

                    if(getElemObj.length >= 1){

                        if(getElemObj.hasClass('selected') == false)
                            scope.toggleSelectFolder(getData.folderId);

                    } else {

                        if(getOptions.mode == 'filterPageFT'){
                            if(scope.searchedFolderData.length >= 1){  // This is only for find functionality
                                angular.element('#'+scope.searchedFolderData[0].folderId).remove();
                                scope.searchedFolderData = [];
                            }
                        }

                        scope.searchedFolderData.push(getData); // If search content already not present, add data

                        var parentFound = false; 

                        angular.forEach(getData.folderIdList, function(value, key) {
                            var getElem = angular.element('#'+value).get(0);                                                   

                            if(getElem !== undefined && parentFound == false){

                                parentFound = true;
                                var randNum = scope.getRandomInt(0,999999);

                                scope.getSearchData[randNum] = JSON.parse(JSON.stringify(getData));

                                //angular.copy(getData, scope.getSearchData[randNum]); // Copying getData to a persistant scope value so that folder selection can be tracked using selectedFolderIdsArray

                                var elemObj = angular.element('#'+value);
                                var elemAnchorPadding = angular.element('#'+value+' a').css('padding-left');

                                if (angular.lowercase(scope.multipleSelect) === "off" || angular.lowercase(scope.multipleSelect) === "false") {

                                var htmlSnipp = '<li class="expandButton plus" ng-class="{selected:selectedFolderIdsArray.indexOf(getSearchData.'+randNum+'.folderId) !== -1}"  ftpath="'+getData.fullFolderPath+'"  id="'+getData.folderId+'" rel="'+value+'"><a href="javascript:void(0)" style="padding-left: '+elemAnchorPadding+'" ng-click="toggleSelectFolder('+getData.folderId+')"><div style="margin-left:10px;" class="custom-checkbox folderSelector" >... '+getData.folderName+'</div></a></li>';

                                } else {

                                scope.getSearchData[randNum].checked = true;
                                var htmlSnipp = '<li class="expandButton plus" ng-class="{selected:selectedFolderIdsArray.indexOf(getSearchData.'+randNum+'.folderId) !== -1}"  ftpath="'+getData.fullFolderPath+'"  id="'+getData.folderId+'" rel="'+value+'"><a href="javascript:void(0)" class="folderFilterChkWrap" style="padding-left: '+elemAnchorPadding+'" ng-click="toggleSelectFolder('+getData.folderId+')"><span class="dotHolder">...</span><div vmf-checkbox-group class="vmf-checkbox-group" type="1" model="getSearchData.'+randNum+'.checked" c-label="subfolder.folderName" c-disabled="false"></div><div style="margin-left:10px;" class="custom-checkbox folderSelector" >'+getData.folderName+'</div></a></li>';

                                }

                                $('#'+value).after($compile(htmlSnipp)(scope));

                                $('#'+getData.folderId).on("mouseenter",  function(event) {                               
                                    $('#'+getData.folderId+' a').addClass("highlightActive highlight");
                                });

                                $('#'+getData.folderId).on("mouseleave", function(event) {                               
                                    $('#'+getData.folderId+' a').removeClass("highlightActive highlight");
                                });

                                scope.toggleSelectFolder(scope.getSearchData[randNum]['folderId']);

                                return false;
                            }

                        });

                    }

                    // Show all parents
                    angular.element('#'+getData.folderId).parents('li.plus').removeClass('plus').addClass('minus');

                    // Fine the top scroll position and scroll to selected node 
                    var topPos = angular.element('#'+getData.folderId).get(0).offsetTop;
                    angular.element('.foldertreeUl').get(0).scrollTop = topPos;

                }

                scope.setFolderPermissions = function(getId){

                    var getPermValFromDom = $('#'+getId).attr('ftPerm');

                    var getElemPath = $('#'+getId).attr('ftPath');

                    if(!getPermValFromDom){

                        var params = { 
                                            'selectedFolderId' : getId
                                     };

                        var paramsEncoded = $.param(params);
                
                        $http({
                            method: 'POST',
                            url: globalVariables.getFolderMinPermUrl,
                            data: paramsEncoded,
                            headers: {'Content-Type': 'application/x-www-form-urlencoded'}
                        }).
                        success(function(data, status, headers, config) { 

                                var  accessPerms = ''; 

                                 if (data.manage) {
                                    accessPerms = "MANAGE";
                                } else if (data.view) {
                                    accessPerms = "VIEW";
                                } else if (!(data.view)) {
                                    accessPerms = "NONE";
                                }

                                 $('#'+getId).attr('ftPerm',accessPerms); 

                                scope.publish('FolderPermissionsSet',data);
                                globalData.permissionObject[getElemPath] = data;

                        }).
                        error(function(data, status, headers, config) {
                            // called asynchronously if an error occurs
                            // or server returns response with an error status.
                        });

                    }

                }

                
                function removeContextMenuBox(){
                  angular.element(".actionEachBox").removeAttr('style').addClass('hidden');
                  scope.thisTree.find(".actionEach").remove();
                  scope.thisTree.find("li.menuOpen").removeClass('menuOpen');
                }

                scope.toggleSelectFolder = function(id,fldrPath){

                    if(angular.element('#'+id).hasClass('disabled')){
                        return false;
                    }

                    if(scope.rootName.instanceId === 'filterPageFT'){

                        scope.selectedFolderIdsArray = [];

                        if(scope.selectedFolderIdsArray.indexOf(id) == -1){
                            scope.selectedFolderIdsArray.push(id.toString());
                        }else{
                          scope.selectedFolderIdsArray.splice(scope.selectedFolderIdsArray.indexOf(id), 1);
                        }
                        
                        scope.setFolderPermissions(id);
                        scope.publish('selectProductsByFolder', scope.selectedFolderIdsArray);

                        if(angular.element(".actionEachBox").is(":visible")){
                          removeContextMenuBox();
                        }

                    } else if (scope.rootName.instanceId === 'moveFolderFT'){

                        scope.selectedFolderIdsArray = [];
                        scope.selectedFolderIdsArray.push(id);

                        scope.publish('publishFolderSelected',{'folderId' : id , 'folderInstance': scope.rootName.instanceId , 'fPath' : fldrPath});

                     } else if(scope.rootName.instanceId === 'filterFolderFT'){

                       /* $('#'+id).find('input[type="checkbox"]').attr('checked',true);
                          $('#'+id).find('label.folderSelector').addClass('selected');
                        */
                    }                   

                }

                scope.getRandomInt = function(min, max) {
                    return Math.floor(Math.random() * (max - min)) + min;
                }

                scope.childCompilerArr = function(objEvent, parentObj, childObject){                    

                    scope.getChildFolders = childObject;
                    var getRandOmInt = scope.getRandomInt(1,99999999999);
                    scope.treeChild[getRandOmInt] = JSON.parse(JSON.stringify(childObject));

                    angular.forEach(childObject,function(val,key){
                        scope.completeFolderStack.push(val);
                    }); 

                    scope.getChildWrap = objEvent.target;

                    //console.log('here parentobj',parentObj);
                    //console.log(scope.getChildWrap);

                   // angular.copy(scope.treeChild, scope.foldersArray);     // Copy the complete stack here
                   // angular.copy(scope.treeChild, scope.completeFolderStack); // Copy the complete stack here

                    scope.folderString = "<ul class='subfolder'>";
                    scope.lowestlevel = scope.lowestlevelGetter(scope.treeChild[getRandOmInt]) || 0;
                    scope.recursionCount = 0;
                    scope.folderHierarchyLevel = 1;

                    //Gets the number of recursions to be done.
                    for (var folderIndex in scope.treeChild[getRandOmInt]) {
                        if (scope.treeChild[getRandOmInt][folderIndex].folderLevel > scope.lowestlevel) {
                            scope.recursionCount++;
                            scope.lowestlevel = scope.treeChild[getRandOmInt][folderIndex].folderLevel;
                        }
                    }

                    while (scope.recursionCount > scope.folderHierarchyLevel - 1) {
                        scope.lastIndex;
                        if (scope.folderHierarchyLevel === 1) {

                            folderArray = [];

                            scope.treeChild[getRandOmInt].forEach(function(folder, index) {
                                if (folder.folderType === "ROOT") {
                                    folderArray.push(folder);
                                }
                            });

                        }

                        scope.nextSet = [];
                        folderArray.forEach(function(folder, index) {

                            if (scope.folderHierarchyLevel === 1) {

                                folderArray[index] = scope.subFolderCreatorChild(folder);
                                if (folderArray[index].subFolders.length) {
                                    /*ignore jslint start*/
                                    folderArray[index].subFolders.forEach(function(elem) {
                                        scope.nextSet.push(elem);
                                    });
                                    /*ignore jslint end*/
                                }

                            } else {

                                folder.subFolders = [];
                                folderArray[index] = scope.subFolderCreatorChild(folder);

                                if (folderArray[index].subFolders.length) {
                                    /*ignore jslint start*/
                                    folderArray[index].subFolders.forEach(function(elem) {
                                        scope.nextSet.push(elem);
                                    });
                                    /*ignore jslint end*/
                                }

                            }

                            scope.lastIndex = index;
                        });

                        folderArray = scope.nextSet;
                        scope.folderHierarchyLevel++;
                    }

                    //console.log(scope.folderHierarchyLevel);
                    scope.firstIteration = true;
                    scope.totalIterations = 0;

                    //scope.tree[0]['subFolders'][0]['subFolders'] =  scope.treeChild;

                    //console.log(scope.treeChild[getRandOmInt]);
                    //console.log(scope.tree);

                    scope.totalIterations = parentObj.folderLevel;
                    scope.childCount = 0;

                     while (scope.folderHierarchyLevel > 0) {

                        scope.calculatePadding(scope.totalIterations - 1);

                        if (scope.firstIteration) {

                            scope.folderString = scope.folderString + '<li ng-repeat="subfolder in treeChild.'+getRandOmInt+'" ng-class="{expandButton:subfolder.hasSubFolders, disabled:subfolder.folderAccess == \'NONE\', plus:subfolder.hasSubFolders, selected:selectedFolderIdsArray.indexOf(subfolder.folderId) !== -1}" id="{{subfolder.folderId}}" ftPath="{{subfolder.fullFolderPath}}" ftName="{{subfolder.folderName}}" ftLevel="{{subfolder.folderLevel}}" ftType="{{subfolder.folderType}}" ftAccess="{{subfolder.folderAccess}}">';
                            scope.firstIteration = false;
                        } else {

                            scope.folderString = scope.folderString + '<ul class="subfolder">' +
                                '<li ng-repeat="subfolder in subfolder.subFolders"  ng-class="{expandButton:subfolder.hasSubFolders,plus:subfolder.hasSubFolders, disabled:subfolder.folderAccess == \'NONE\', selected:selectedFolderIdsArray.indexOf(subfolder.folderId) !== -1}">';
                        }

                         if(scope.rootName.showFolderOptions == true){

                        scope.folderString = scope.folderString + '<a href="javascript:void(0)" ng-class="{disabled:subfolder.folderAccess ==\'NONE\'}" ng-click="toggleSelectFolder(subfolder.folderId,subfolder.fullFolderPath)" style="padding-left: ' + scope.folderPadding + 'px" vmf-folder-options data-folder-options=subfolder.folderOptions data-this-tree = "thisTree"  ng-click="folderClickCallBack({$event:$event,this:this})" complete-folder-stack = "completeFolderStack" folder-data-ftype="subfolder.folderType">' +
                            '<span class="expandCollapseIcon" style="left: ' + scope.collapsePadding + 'px" ng-show="subfolder.hasSubFolders" ng-click="expander($event,subfolder.folderAccess); ajaxLoad($event,subfolder)">&nbsp;</span>';

                        } else {

                        scope.folderString = scope.folderString + '<a href="javascript:void(0)" ng-click="toggleSelectFolder(subfolder.folderId,subfolder.fullFolderPath)" style="padding-left: ' + scope.folderPadding + 'px"  ng-click="folderClickCallBack({$event:$event,this:this})" complete-folder-stack = "completeFolderStack" folder-data-ftype="subfolder.folderType">' +
                            '<span class="expandCollapseIcon" style="left: ' + scope.collapsePadding + 'px" ng-show="subfolder.hasSubFolders" ng-click="expander($event,subfolder.folderAccess); ajaxLoad($event,subfolder)">&nbsp;</span>';

                        }

                        if (angular.lowercase(scope.multipleSelect) === "off" || angular.lowercase(scope.multipleSelect) === "false") {

                            scope.folderString = scope.folderString + '<div style="margin-left:10px;" class="custom-checkbox">' + 
                            '<span class="folderIcon"></span>{{subfolder.folderName}} <span class="badge" ng-if="subfolder.folderType == \'ASP\' || subfolder.folderType == \'VCE\' || subfolder.folderType == \'CPL\'" badgeType="{{subfolder.folderType}}">{{subfolder.folderType}}</span></div>';
                        } else {
                            scope.folderString = scope.folderString + '<div class="checkbox"><input id="{{subfolder.folderName}}" class="styled" ng-model="subfolder.checked" type="checkbox" ng-disabled="subfolder.folderAccess == \'NONE\'"><label for="{{subfolder.folderName}}">{{subfolder.folderName}}</label></div>';

                            //scope.folderString = scope.folderString + '<div vmf-checkbox-group class="vmf-checkbox-group" type="1" c-foldertype="subfolder.folderType" model="subfolder.checked" c-label="subfolder.folderName" c-disabled="subfolder.folderAccess == \'NONE\'"></div>';
                        }

                        scope.folderString = scope.folderString + '</a>';
                        scope.folderHierarchyLevel--;
                        scope.totalIterations++;
                        scope.childCount++;
                    }

                    while (scope.childCount > 0) {

                        scope.folderString = scope.folderString + '</li></ul>';
                        scope.childCount--;
                    }

                    //var getParent = $(scope.getChildWrap).parents('.subfolder:first'); 
                    var getParent = $(scope.getChildWrap).parents('li:first'); 
                    var getParentId =   getParent.prop('id');

                    $timeout(function() {
                        getParent.append($compile(scope.folderString)(scope));
                    });

                    $timeout(function() {

                         getParent.find('.disabled > a')
                            .addClass('vmf-tooltip')
                            .attr('data-toggle','tooltip')
                            .attr('data-placement','bottom')
                            .attr('title',globalVariables.textDisabledFolders);

                        getParent.find('.badge').each(function(){
                            var getType = $(this).attr('badgeType');
                            $(this).attr('title',globalVariables['staticTextfor'+getType]);
                        });

                        getParent.find(".custom-checkbox").addClass("folderSelector");
                        getParent.find(".folderTree").find("input").removeAttr("ng-click");
                        getParent.find(".subfolder:first").has("li").parent("li").removeClass("plus");
                        if (angular.lowercase(scope.multipleSelect) === "off" || angular.lowercase(scope.multipleSelect) === "false") {
                            getParent.find(".folderTreeHeader a:first span").remove();
                            getParent.addClass("withoutCheckBox");
                        }
                        getParent.find('.vmf-tooltip').tooltip();
                        scope.moveSearchedFolders();

                        scope.publish('childFoldersRecieved',{'childObj':childObject, 'parentId':getParentId, 'instanceId':scope.rootName.instanceId});

                    });

                }   
                  

                lElement.find(".folderTreeHeader .customCheckBox").off("click").on("click", function(event) {

                    scope.thisTree.find(".actionEach").remove();
                    scope.thisTree.find(".actionEachBox").remove();
                    scope.availableFolders = scope.thisTree.find(".folderSelector").not(".disabledColor");

                    if (angular.element(this).attr("checked")) {

                        scope.availableFolders.removeClass("selected").find("input").attr("checked", false);
                        scope.availableFolders.parent().removeClass("highlight");
                        angular.element(this).attr("checked", false);
                        return false;
                    } else {

                        scope.availableFolders.addClass("selected").find("input").attr("checked", true);
                        scope.availableFolders.parent().addClass("highlight");
                        angular.element(this).parents("a").removeClass("highlight");
                        angular.element(this).attr("checked", true);
                        return false;
                    }

                    //console.log("select all " +angular.element(this).attr("checked"))
                });

                //Updates
                scope.uniqueIDGenerator = function(currentFolders) {
                    var id;
                    var hitCount;
                    var validID = true;

                    while (validID === true) {

                        id = Math.floor(Math.random() * 10000);
                        hitCount = 0;
                        /*ignore jslint start*/
                        scope.completeFolderStack.forEach(function(folder) {

                            if (folder.folderId === id) {
                                hitCount++;
                            }
                        });
                        /*ignore jslint end*/

                        if (hitCount === 0)
                            validID = false;
                    }

                    return id;
                };

                scope.creatingFolder = function(referenceObj, source) {

                    var respObj = {};
                    var option = [{
                        "text": "Invite New User",
                        "disabledClass": "disabled"
                    }, {
                        "text": "Share Folder",
                        "disabledClass": "enabled"
                    }, {
                        "text": "Create Folder",
                        "disabled": true
                    }, {
                        "text": "Delete Folder",
                        "disabled": true
                    }, {
                        "text": "Rename Folder",
                        "disabled": false
                    }, {
                        "text": "Move Folder",
                        "disabled": false
                    }, {
                        "text": "Request Permission",
                        "disabled": false
                    }, {
                        "text": "Export to csv",
                        "disabled": false
                    }];

                    respObj.status = "ACTIVE";
                    respObj.folderType = "ORDER";
                    respObj.fullFolderPath = source.folderPath + "\\" + source.folderName;
                    respObj.rootFolderId = 0;
                    respObj.folderId = scope.uniqueIDGenerator(scope.completeFolderStack);
                    respObj.folderName = source.folderName;
                    respObj.parentFolderId = referenceObj.folderId;
                    respObj.folderLevel = referenceObj.folderLevel + 1;
                    respObj.folderAccess = "NONE";
                    respObj.isLeaf = true;
                    respObj.hasSubFolders = false;
                    respObj.folderOptions = option;
                    //respObj.accessable = true;
                    respObj.checked = false;

                    return respObj;
                };

                scope.resetFolders = function(change, type) {

                    scope.modifiedFolders = [];
                    scope.type = type || "";
                    scope.parentFolder;
                    scope.searchResult = {};

                    //logic to be changed
                    if (type.search("Create") >= 0) {

                        scope.newFolder = {};
                        scope.referenceObj = {};

                        scope.allFolders.forEach(function(folder, folderIndex) {
                            if (folder.fullFolderPath === change.folderPath) {
                                scope.allFolders[folderIndex].hasSubFolders = true;
                                scope.referenceObj = folder;
                            }
                        });

                        scope.newFolder = scope.creatingFolder(scope.referenceObj, change);

                        scope.allFolders.push(scope.newFolder);
                        scope.modifiedFolders = scope.allFolders;
                        //console.log(currentFolders);
                    } else if (type.search("Delete") >= 0) {

                        scope.delReference = change.ref;
                        scope.deleteIndice = [];
                        scope.deletedFolders = [];
                        scope.completeFolderStack.forEach(function(folder, folderIndex) {
                            if (folder.fullFolderPath.split(delReference).length > 1) {
                                scope.deleteIndice.push(folderIndex);
                            }
                        });

                        scope.deleteIndice.reverse().forEach(function(delFodler, folderIndex) {

                            scope.tempCount = 0;
                            scope.tempParentId = scope.completeFolderStack[folderIndex].parentFolderId;
                            deletedFolders.push(scope.completeFolderStack[folderIndex]);
                            scope.completeFolderStack.splice(folderIndex, 1);

                            scope.completeFolderStack.forEach(function(folder, index) {
                                if (scope.tempParentId === folder.parentFolderId) {
                                    scope.tempCount++;
                                }

                            });
                            if (scope.tempCount === 0) {
                                scope.completeFolderStack.forEach(function(folder, index) {
                                    if (scope.tempParentId === folder.folderId) {
                                        folder.hasSubFolders = false;
                                        return false;
                                    }
                                });
                            }
                        });

                        //scope.folderTreeDataService.previouslyDeletedFolders.push(deletedFolders);
                        scope.modifiedFolders = scope.completeFolderStack;
                    } else if (type.search("Rename") >= 0) {

                        scope.mainPathArray = [];
                        scope.newFullPath = "";
                        scope.bits = [];

                        scope.initialPath = change.currentFolderPath.split("\\");
                        scope.initialPath.pop();


                        scope.completeFolderStack.forEach(function(folder, folderIndex) {

                            scope.mainPathArray = [];
                            scope.mainPathArray = folder.fullFolderPath.split(change.currentFolderPath);
                            if (scope.mainPathArray.length >= 1) {

                                if (scope.mainPathArray[0] === "") {

                                    scope.mainPathArray[0] = change.folderName;
                                    scope.newFullPath = scope.initialPath.join("\\") + "\\" + scope.mainPathArray.join("");
                                    scope.completeFolderStack[folderIndex].fullFolderPath = scope.newFullPath;
                                }
                                if (scope.completeFolderStack[folderIndex].folderName === change.currentFolderPath.split("\\").pop()) {

                                    scope.completeFolderStack[folderIndex].folderName = change.folderName;
                                }
                            }


                        });

                        scope.modifiedFolders = scope.completeFolderStack;
                    } else if (type.search("Move") >= 0) {
                        // console.log("In Move Folder")

                        var tobemoved = [];
                        scope.parentFolder = {};
                        var immediateChildren = {};
                        var childFolder = {};

                        var ref = change.currentFolderPath.split("\\").pop();

                        scope.completeFolderStack.forEach(function(folder, folderIndex) {
                            if (folder.fullFolderPath === change.folderPath) {
                                scope.parentFolder = {
                                    "folder": folder,
                                    index: folderIndex
                                };
                            }
                            if (folder.fullFolderPath.split(change.currentFolderPath).length > 1) {

                                if (folder.fullFolderPath.split(change.currentFolderPath)[folder.fullFolderPath.split(change.currentFolderPath).length - 1] === "") {
                                    immediateChild = {
                                        "folder": folder,
                                        index: folderIndex
                                    };
                                } else {
                                    tobemoved.push({
                                        "folder": folder,
                                        index: folderIndex
                                    });
                                }
                            }
                        });


                        var tempCount = 0;
                        var tempParentId = scope.completeFolderStack[immediateChild.index].parentFolderId;

                        scope.completeFolderStack.forEach(function(folder, index) {
                            if (tempParentId === folder.parentFolderId) {
                                tempCount++;
                            }

                        });
                        if (tempCount <= 1) {
                            scope.completeFolderStack.forEach(function(folder, index) {
                                if (tempParentId === folder.folderId) {
                                    folder.hasSubFolders = false;
                                    return false;
                                }
                            });
                        }

                        scope.completeFolderStack[immediateChild.index].parentFolderId = scope.completeFolderStack[scope.parentFolder.index].folderId;
                        scope.completeFolderStack[immediateChild.index].folderLevel = scope.completeFolderStack[scope.parentFolder.index].folderLevel + 1;
                        scope.completeFolderStack[immediateChild.index].isLeaf = true;
                        scope.completeFolderStack[scope.parentFolder.index].hasSubFolders = true;
                        scope.completeFolderStack[immediateChild.index].fullFolderPath = scope.completeFolderStack[scope.parentFolder.index].fullFolderPath + "\\" + scope.completeFolderStack[immediateChild.index].folderName;



                        var iterate = true;
                        var lowestLevel = 0;
                        var levels = [];
                        if (Object.keys(tobemoved).length > 0) {
                            tobemoved.forEach(function(folder, folderIndex) {
                                // levels.push(folder.folderLevel)
                                if (scope.completeFolderStack[immediateChild.index].folderId === folder.folder.parentFolderId) {
                                    scope.completeFolderStack[folder.index].folderLevel = scope.completeFolderStack[immediateChild.index].folderLevel + 1;
                                    scope.completeFolderStack[folder.index].isLeaf = true;
                                    scope.completeFolderStack[folder.index].fullFolderPath = scope.completeFolderStack[immediateChild.index].fullFolderPath + "\\" + folder.folder.folderName;
                                }
                            });

                            scope.completeFolderStack.forEach(function(folderName, index) {
                                if (folderName.hasSubFolders) {
                                    tobemoved.forEach(function(folder, folderIndex) {
                                        if (folder.folder.folderId === folderName.parentFolderId) {
                                            scope.completeFolderStack[index].folderLevel = scope.completeFolderStack[folder.index].folderLevel + 1;
                                            scope.completeFolderStack[index].fullFolderPath = scope.completeFolderStack[folder.index].fullFolderPath + "\\" + folderName.folderName;
                                            return false;
                                        }
                                    });
                                } else {
                                    tobemoved.forEach(function(folder, folderIndex) {
                                        if (folder.folder.parentFolderId === folderName.folderId) {
                                            scope.completeFolderStack[folder.index].folderLevel = scope.completeFolderStack[index].folderLevel + 1;
                                            scope.completeFolderStack[folder.index].fullFolderPath = scope.completeFolderStack[index].fullFolderPath + "\\" + folder.folder.folderName;
                                            return false;
                                        }
                                    });
                                }
                            });
                        }

                        scope.modifiedFolders = scope.completeFolderStack;
                    } else if (type.search("Find") >= 0) {

                        scope.completeFolderStack.forEach(function(folder) {
                            if (angular.lowercase(folder.folderName).split(angular.lowercase(change.folderName)).length > 1) {
                                scope.searchResult = folder;
                            }
                        });
                        scope.findFolder.folderName = "";
                        //console.log(searchResult);
                        //scope.searchResult = searchResult;
                    }

                    //scope.folderTreeDataService.allFolderPaths = scope.folderTreeDataService.getAllFolderPaths();

                    //console.log(scope.allFolders);
                    if (scope.type.split("Find").length === 1) {

                        scope.folderStackUpdated(scope.modifiedFolders);

                    } else {
                        scope.foundElement(scope.searchResult);
                    }

                    //return modifiedFolders;
                };

                scope.folderStackUpdated = function(update) {
                    scope.tree = update;
                    //console.log(update);
                };

                //Modal Overlay functions

                scope.getAllFolderPaths = function(foldersArray) {

                    scope.foldersArray = foldersArray;
                    scope.pathArray = [];
                    scope.pathPresent = false;

                    if (!angular.isUndefined(scope.foldersArray)) {

                        scope.foldersArray.forEach(function(folder) {

                            scope.pathPresent = false;
                            scope.pathArray.forEach(function(folderPath) {

                                if (folderPath === folder.fullFolderPath) {

                                    scope.pathPresent = true;
                                }
                            });

                            if (!scope.pathPresent) {

                                scope.pathArray.push(folder.fullFolderPath);
                            }
                        });
                    }


                    //console.log(pathArray);
                    return scope.pathArray;
                };

                scope.find = function(folder) {

                    scope.findResult = [];
                    if (folder.folderName === "") {
                        angular.element(".resultPane.notpborder").children().remove();
                    } else {

                        scope.allFolders.forEach(function(folderObj) {
                            if (angular.lowercase(folderObj.folderName).split(angular.lowercase(folder.folderName)).length > 1) {
                                scope.findResult.push(folderObj);
                            }
                        });

                        //console.log(scope.searchResult);
                        scope.createOptions(scope.findResult);
                        scope.optionsString = '<div vmf-radio-group type="1" rtitle="radioTitle" options="radioOptions" name="radioName" model="radioModel" custom-class="customclass" mandatory="true" class="radio-controls"></div>';

                        angular.element(".resultPane.notpborder").children().remove();
                        angular.element(".resultPane.notpborder").append($compile(scope.optionsString)(scope));
                    }
                };

                scope.createOptions = function(optionsCollection) {

                    scope.radioOptions = [];
                    scope.value = 0;
                    optionsCollection.forEach(function(options) {

                        if (options.accessable) {
                            scope.tempOption = {};

                            scope.tempOption.text = options.folderName;
                            scope.tempOption.disabled = false;
                            scope.tempOption.checked = false;
                            scope.tempOption.value = scope.value.toString();
                            scope.value++;

                            scope.radioOptions.push(scope.tempOption);
                        }
                    });
                };

               

            },
            templateUrl: "/vmf/m/components/folderTree/template/folderTreeTemplate.html",
            controller: function($scope, $element, $timeout, $document, ModalService, globalData) {
                _this = this;
                $scope.globalVars = globalVariables;

                this.publishGetFolderPath = function(){
                    $scope.publish('getFolderTreePaths');
                }

                this.publishGetFolderPathCreate = function(){
                    $scope.publish('getFolderTreePathsCreate');
                }

                this.getUsers = function(){
                    $scope.publish('getUserDetails');
                }

                this.publishEditFolderPermissions = function(){
                    $scope.publish('editFolderPermissions');
                }

                this.createModal = function(required, allFolders) {

                    $scope.modalData = required;
                    $scope.allFolders = allFolders;

                    $scope.publish('modalObject',$scope.modalData);                    

                    //console.log($scope.allFolderPaths);

                    $scope.deleteWarning = "When you confirm, the folder and all its subfolders will be deleted.Users who are associated only to the selected folders will no longer be able to access the account.";

                    $scope.newFolder = {};
                    $scope.renewFolder = {};
                    $scope.move = {};
                    $scope.newUser = {};
                    $scope.parentFolderName;

                    $scope.folderPath;
                    $scope.deleteFolderPath;
                    $scope.deleteWarningType = "warning";

                    $scope.htmlString = "";

                    console.log($scope.modalData);

                    $scope.allFolderPaths = $scope.getAllFolderPaths($scope.allFolders);

                    /*
                    if ($scope.modalData.operationScope.text === "Create Folder") {

                        if ($scope.modalData.folders.length > 0) {
                            $scope.parentFolderName = $scope.allFolderPaths.indexOf($scope.modalData.folders[0].fullFolderPath);
                        } else {
                            $scope.parentFolderName = "";
                        }

                        $scope.htmlString = '<p>Type the name of the folder.</p><div class="vmf-create-folder"><div vmf-select-list pre-select-ind="' + $scope.parentFolderName + '" dtitle="Parent Folder" validation=\'[{"name":"selectOne"},{"name":"required"}]\' model="newFolder.folderPath" list="allFolderPaths" mandatory="true" custom-class="customclass"></div>' +
                            '<div vmf-text-input type="normal" class="vmf-text-input clearfix" name="userForm" model="newFolder.folderName" title="Folder Name" validation=\'[{"name":"required"}]\' mandatory="true" custom-class="customclass"></div></div>';
                        $scope.footerBtn = '<input type="submit" class="vmf-btn vmf-primary vmfloginChange" href="javascript:void(0);" value="Save" ng-click="folderActions($event)" /><input type="submit" class="vmf-btn  vmfloginChange" href="javascript:void(0);" value="Cancel" data-dismiss="modal" ng-click="close(\'Cancel\');modalShown=false" />';
                    }

                    if ($scope.modalData.operationScope.text === "Delete Folder") {

                        $scope.deleteFolderPath = $scope.modalData.folders[0].fullFolderPath;

                        $scope.htmlString = '<div class="vmf-delete-folder" ng-if="deleteFolderErrorMsg.length == 0"><p>Confirm that you want to delete the selected folder and its subfolders.</p>' +
                            '<div class="vmf-highlight"><div class="col-md-3 formLabel"> Delete Folder </div> <div class="col-md-4">\\\\{{deleteFolderPath}}</div><div class="clearfix"></div></div>' +
                            '<div information-message info-message="{{deleteWarning}}" is-info-message="true" info-type="{{deleteWarningType}}"></div></div>';

                        $scope.htmlString += '<div ng-if="deleteFolderErrorMsg.length >= 1"></div>'

                        $scope.footerBtn = '<input type="submit" class="vmf-btn vmf-primary vmfloginChange" href="javascript:void(0);" value="Confirm" ng-click="folderActions($event)" /><input type="submit" class="vmf-btn  vmfloginChange" href="javascript:void(0);" value="Cancel" data-dismiss="modal" ng-click="close(\'Cancel\');modalShown=false" />';
                    }

                    if ($scope.modalData.operationScope.text === "Rename Folder") {

                        $scope.renewFolder.currentFolderPath = $scope.modalData.folders[0].fullFolderPath;
                        $scope.htmlString = '<div class="vmf-rename-folder"><p>To rename the folder, type the new folder name and click Confirm. The new folder name must be unique and not already in use for this account.</p>' +
                            '<div class="vmf-highlight"><div class="col-md-3 formLabel">Existing folder name   </div>  <div class="col-md-4">\\\\{{renewFolder.currentFolderPath}}</div>' +
                            '<div vmf-text-input type="normal" class="vmf-text-input clearfix" name="userForm" model="renewFolder.folderName" title="New Folder Name" mandatory="true" validation=\'[{"name":"required"}]\' custom-class="customclass"></div></div></div>';
                        $scope.footerBtn = '<input type="submit" class="vmf-btn vmf-primary vmfloginChange" href="javascript:void(0);" value="Save" ng-click="folderActions($event)" /><input type="submit" class="vmf-btn  vmfloginChange" href="javascript:void(0);" value="Cancel" data-dismiss="modal" ng-click="close(\'Cancel\');modalShown=false" />';
                    }

                    if ($scope.modalData.operationScope.text === "Move Folder") {

                        $scope.move.currentFolderPath = $scope.modalData.folders[0].fullFolderPath;
                        $scope.customFolderPaths = [];

                        // $scope.customFolderPaths.splice($scope.customFolderPaths.indexOf($scope.move.currentFolderPath),1);

                        $scope.allFolderPaths.forEach(function(path) {
                            if (path.split($scope.modalData.folders[0].fullFolderPath).length === 1) {

                                $scope.customFolderPaths.push(path);
                            }
                        });
                        //console.log($scope.customFolderPaths);
                        $scope.htmlString = '<div class="vmf-move-folder"><p>Select the target folder location.</p>' +
                            '<div class="vmf-highlight"><div class="col-md-3 formLabel">Move Folder    </div> <div class="col-md-4">\\\\{{move.currentFolderPath}}</div>' +
                            '<div class="clearfix" vmf-select-list dtitle="To" model="move.folderPath" validation=\'[{"name":"selectOne"},{"name":"required"}]\' list="customFolderPaths" mandatory="true" custom-class="customclass"></div></div></div>';
                        $scope.footerBtn = '<input type="submit" class="vmf-btn vmf-primary vmfloginChange" href="javascript:void(0);" value="Continue" ng-click="folderActions($event)" /><input type="submit" class="vmf-btn  vmfloginChange" href="javascript:void(0);" value="Cancel" data-dismiss="modal" ng-click="close(\'Cancel\');modalShown=false" />';
                    }

                    if ($scope.modalData.operationScope.text === "Find Folder") {

                        console.log('find fodler');

                        $scope.htmlString = '<p class="statictext_p">Find then select a folder.</p><div class="section-wrapper clearfix  bottomarea"><section class="column fiveFifty mtop11"><header><h1>License Key Folders </h1></header><div class="searchArea">' +
                            '<div vmf-text-input type="normal" class="vmf-text-input clearfix" name="userForm" model="findFolder.folderName" validation=\'[{"name":"required"}]\' custom-class="customclass"></div>' +
                            '<input type="submit" ng-click="find(findFolder)" value="Find" class="vmf-btn vmf-primary" /></div><div class="resultPane notpborder">' +
                            '</div></section></div>';

                        $scope.footerBtn = '<input type="submit" class="vmf-btn vmf-primary vmfloginChange" href="javascript:void(0);" value="Select" ng-click="folderActions($event)" /><input type="submit" class="vmf-btn  vmfloginChange" href="javascript:void(0);" value="Cancel" data-dismiss="modal" ng-click="close(\'Cancel\');modalShown=false" />';
                    }

                    if ($scope.modalData.operationScope.text === "Invite New User") {

                        $scope.InviteUserModal = "Invite_New_User";

                        $scope.htmlString = '<div  class="row inviteUser">' + ' <div>' + '  <div class="header-text"><span>Invite New Users</span></div>' + '  <div class="inviteUser-required"> Required*</div>' + '  <div class="left-align"><div>Email address*</div>' + '  <input type="text" id="" name="name" ng-model="newUser.emailAddress" placeholder="" class="ng-pristine ng-valid"></div>' + '  <div class="left-align"><div>First Name*</div>' + '   <input type="text" id="" name="name" ng-model="newUser.firstName" placeholder="" class="ng-pristine ng-valid"></div>' + '   <div class="left-align"><div> Last Name*</div>' + '   <input type="text" id="" name="name" ng-model="newUser.lastName" placeholder="" class="ng-pristine ng-valid"></div>' + '  <div class="left-align"><input type="submit" ng-click="find(findFolder)" value="Add >>" class="vmf-btn vmf-right-button"></div></div>' + ' </div>';
                        +'  <div style="border:1px solid #000000;height:350px;" class="col-md-7 noPadding">'
                        +'  <div class="header-text"><span>Selected Users(0)</span><input type="submit" ng-click="find(findFolder)" value="Add>>"                                  class="vmf-btn vmf-primary" style="float:right;"> </div>'
                        +'   <div class="section-text"><span style="width:170px;float:left;">Name</span><span>E-mail</span>'                                     +'   </div</div></div>';

                        $scope.footerBtn = '<input type="submit" class="vmf-btn vmfloginChange" href="javascript:void(0);" value="Continue" data-dismiss="modal" ng-click="folderActions($event)" /><input type="submit" class="vmf-btn  vmfloginChange vmf-primary" href="javascript:void(0);" data-dismiss="modal" value="Cancel" ng-click="folderActions($event)" />';
                    }

                    $scope.radioName = 'role';
                    $scope.radioModel = "";

                    $timeout(function() {
                        angular.element(".modal-body").append($compile($scope.htmlString)($scope));
                        angular.element(".modal-footer").append($compile($scope.footerBtn)($scope));
                    });*/
                }; 

                $scope.foundElement = function(searchResults) {
                    //console.log(searchResults);
                    $scope.requiredFolder = searchResults;
                    $scope.expanders = angular.element(".folderTree").find(".expandButton").find(".custom-checkbox");

                    $scope.expanders.removeClass("selected").parent().removeClass("highlight").parent().removeClass("minus").addClass("plus");
                    $scope.expanders.eq(0).parent().parent().removeClass("plus").addClass("minus");

                    $scope.folderRoots = $scope.requiredFolder.fullFolderPath.split("\\");
                    $scope.folderRoots.shift();
                    $scope.lastFName = $scope.folderRoots[$scope.folderRoots.length - 1];
                    $scope.lastElement;
                    $scope.expanderIndices = [];
                    $scope.folderRoots.forEach(function(root) {
                        for (var expanderIndex = 0; expanderIndex < $scope.expanders.length; expanderIndex++) {

                            if ($scope.expanders.eq(expanderIndex).text() === root && $scope.expanders.eq(expanderIndex).parent().parent().hasClass("plus")) {

                                $scope.expanders.eq(expanderIndex).parent().parent().removeClass("plus").addClass("minus");
                                if (root === $scope.lastFName) {
                                    $scope.expanderIndices.push(expanderIndex);
                                }
                                $scope.lastElement = $scope.expanders.eq(expanderIndex);

                            }

                        }
                    });

                    angular.element(".foldertreeUl>li").removeClass("plus");
                    $scope.expanderIndices.forEach(function(index) {
                        $scope.expanders.eq(index).addClass("selected").parent().addClass("highlight");
                    });

                    //$scope.lastElement.addClass("selected").parent().addClass("highlight");
                };

                $scope.expander = function(event, folderAccess) {

                    event.stopPropagation();
                    if ($scope.thisTree.find(event.currentTarget).parent().parent().hasClass("plus")) {
                        $scope.thisTree.find(event.currentTarget).parent().parent().removeClass("plus").addClass("minus");
                    } else if ($scope.thisTree.find(event.currentTarget).parent().parent().hasClass("minus")) {
                        $scope.thisTree.find(event.currentTarget).parent().parent().removeClass("minus").addClass("plus");
                    }
                    //$scope.mainOptions[0].disabled = false;
                };

                $scope.getPermissionFpList = []; 

                $scope.subscribe('setEnableMainOptions',function(data){
                    if(data == 'enabled')
                        $scope.mainOptionsEnable = true;
                    else
                        $scope.mainOptionsEnable = false; 
                });

               $scope.checkManagePerms = function(event){                    

                    var getSelectElemLength = $scope.thisTree.find('li.selected').length;

                    var getFtype = '';
                    var getFtAccess = '';

                    if(getSelectElemLength == 1){
                         getFtype = $scope.thisTree.find('li.selected').attr('ftType');
                         getFtAccess = $scope.thisTree.find('li.selected').attr('ftPerm');
                    }

                    var totLength =  $scope.thisTree.find('li').length;

                    $scope.setMainOptions(getSelectElemLength, $scope.mainOptionsEnable, getFtype, getFtAccess, totLength);                  


                }

                $scope.setMainOptions = function(elemLength , fpListAvailable, getFolderType, getFolderAccess, totFldrCount){
                     
                     $scope.mainOptions = [{
                            text: $scope.globalVars.folderOps.invite,
                            disabled: true,
                            id : "inviteNewUserMain"                         
                        }, {
                            text: $scope.globalVars.folderOps.share,
                            disabled: true,
                             id : "shareFolderMain"
                        }, {
                            text: $scope.globalVars.folderOps.create,
                            disabled: true,
                            id : "createFolderMain"
                        }, {
                            text: $scope.globalVars.folderOps.del,
                            id : "deleteFolderMain",
                            disabled: false
                        }, {
                            text: $scope.globalVars.folderOps.rename,
                            id : "renameFolderMain",
                            disabled: false
                        }, {
                            text: $scope.globalVars.folderOps.move,
                            id : "moveFolderMain",
                            disabled: false
                        }, {
                            text: $scope.globalVars.folderOps.find,
                            id : "findFolderMain",
                            disabled: false
                        }, {
                            text: $scope.globalVars.folderOps.exportCsv,
                            id : "exportToCsvMain",
                            disabled: false
                        }];

                        angular.forEach($scope.mainOptions,function(val, key){

                             if(fpListAvailable == true && elemLength == 0){

                                if(val.id == 'createFolderMain' || val.id == 'inviteNewUserMain' || val.id == 'shareFolderMain'){
                                                val.disabledClass = 'enabled';
                                } else {                                    
                                     val.disabledClass = 'disabled';
                                }
                                

                             } else if(elemLength == 1){ 

                                if(getFolderAccess == "MANAGE"){
                                    
                                    if(getFolderType == 'ROOT'){
                                
                                        val.disabledClass = 'disabled';
                                    
                                        if(globalData.tableType == "viewLicense"){
                                            if(val.id == 'createFolderMain' || val.id == 'exportToCsvMain'){
                                                val.disabledClass = 'enabled';
                                            } 
                                        }
                                    
                                    } else if (getFolderType == "ASP" || getFolderType == "CPL" || getFolderType == "VCE") {
                                    
                                            val.disabledClass = 'disabled';
                                        
                                            if(val.id == 'renameFolderMain' || val.id == 'inviteNewUserMain' || val.id == 'shareFolderMain'){
                                                val.disabledClass = 'enabled';
                                            }
                                            
                                            if(globalData.tableType == "viewLicense"){
                                                if(val.id == 'exportToCsvMain'){
                                                    val.disabledClass = 'enabled';
                                                }
                                            }
                                        
                                    } else {
                                    
                                        val.disabledClass = 'enabled';
                                        
                                        if(globalData.tableType == "viewLicense"){
                                                if(val.id == 'exportToCsvMain'){
                                                    val.disabledClass = 'enabled';
                                                }
                                            }
                                    }
                                
                                    if(val.id == 'inviteNewUserMain' || val.id == 'shareFolderMain'){
                                                val.disabledClass = 'enabled';
                                    }
                                } else {

                                    val.disabledClass = 'disabled';

                                }

                            } else if(fpListAvailable == false){
                                val.disabledClass = 'disabled';
                            }

                            if(totFldrCount >= 1 || fpListAvailable == true){
                                if(val.id == 'findFolderMain'){
                                    val.disabledClass = 'enabled';
                                }
                            }

                            if(globalData.tableType == "viewLicense"){
                                if(fpListAvailable === true && elemLength !== 0){
                                    if(val.id == 'exportToCsvMain'){
                                        val.disabledClass = 'enabled';
                                    }
                                }
                            }

                        });

                    // if ($scope.thisTree.find(".folderSelector.selected").length === 0) {
                    //     $scope.mainOptions[3].disabledClass = "disabled";
                    //     $scope.mainOptions[4].disabledClass = "disabled";
                    //     $scope.mainOptions[5].disabledClass = "disabled";
                    //     $scope.mainOptions[7].disabledClass = "disabled";
                    // }

                }

                $scope.openMainOptions = function(event) {
                    // while opening actions-dropdown, close all other dropdowns and close filters dropdown
                    $scope.publish('closeAllDropdowns', event);
                    $scope.publish('closeAllFilters');

                    event.preventDefault();

                    $scope.checkManagePerms(event);

                    if ($scope.thisTree.find(".actionAllBox").hasClass("optionsOpen")) {
                        if(event!=undefined) {
                            angular.element(event.target).parent().find(".ftAjaxLoader").addClass("hidden");
                        }
                        $scope.thisTree.find(".actionAllBox").removeClass("optionsOpen");
                        $scope.thisTree.find(".actionAllBox").find(".innerWrapper").children().remove();

                    } else {
                        // $scope.mainOptions = [{
                        //     text: "Invite New User",
                        //     disabled: true,
                        //     disabledClass : opt                          
                        // }, {
                        //     text: "Share Folder",
                        //     disabled: true,
                        //     disabledClass : opt 
                        // }, {
                        //     text: "Create Folder",
                        //     disabled: true,
                        //     disabledClass : opt 
                        // }, {
                        //     text: "Delete Folder",
                        //     disabled: false
                        // }, {
                        //     text: "Rename Folder",
                        //     disabled: false
                        // }, {
                        //     text: "Move Folder",
                        //     disabled: false
                        // }, {
                        //     text: "Find Folder",
                        //     disabled: false
                        // }, {
                        //     text: "Export to csv",
                        //     disabled: false
                        // }];

                        //console.log($scope.mainOptions);


                       /* if ($scope.thisTree.find(".folderSelector.selected").length === 0) {
                            $scope.mainOptions[3].disabledClass = "disabled";
                            $scope.mainOptions[4].disabledClass = "disabled";
                            $scope.mainOptions[5].disabledClass = "disabled";
                            $scope.mainOptions[7].disabledClass = "disabled";
                        } */

                        $scope.mainOptionsString = '<ul>' +
                            '<li ng-repeat="mainOption in mainOptions" ng-class="{first:$first,last:$last,mainLink:$last}">' +
                            '<a href="javascript:void(0)" class="{{mainOption.disabledClass}}" id="{{mainOption.id}}" ng-click="mainOptionsAction($event,this)">{{mainOption.text}}</a>' +
                            '</li></ul>';

                        $scope.thisTree.find(".actionAllBox").find(".innerWrapper").children().remove();

                        $timeout(function() {
                            $scope.thisTree.find(".actionAllBox").find(".innerWrapper").append($compile($scope.mainOptionsString)($scope));

                            // $timeout(function() {
                            //      var getSelectElemLength = $scope.thisTree.find('li.selected').length;

                            //     if(getSelectElemLength == 1){
                            //       $('#deleteFolderMain , #renameFolderMain,  #moveFolderMain').removeClass('disabled');
                            //     } else {
                            //       $('#deleteFolderMain , #renameFolderMain,  #moveFolderMain').addClass('disabled');
                            //     }

                            // });

                        });

                        $timeout(function() {
                            $scope.thisTree.find(".actionAllBox").addClass("optionsOpen");
                            $scope.thisTree.find(".actionEach").parent().removeClass("highlight");
                            angular.element(".actionEachBox").remove();
                            $scope.thisTree.find(".actionEach").remove();
                        });

                    }
                    event.stopPropagation();
                };

                $scope.mainOptionsAction = function(event, optionScope) {


                    if (optionScope.mainOption.id === "exportToCsvMain") {
                        $scope.publish('sendExportToCsvAPI', {
                            'selectedFolders': globalData.selectedFolder, 
                            'reportFor': 'licenseKeysFromContextMenu'
                        });

                        event.stopPropagation();
                    }else if (optionScope.mainOption.text === "Expand All Folders") {
                        $scope.thisTree.find(".expandButton").removeClass("plus").addClass("minus");
                    } else {
                        if (optionScope.mainOption.disabledClass !== "disabled") {

                            $scope.selectedFolders = $scope.thisTree.find(".selected");
                            $scope.selectedFolderNames = [];

                            $scope.required = {
                                operationScope: {},
                                folders: []
                            };

                            $scope.required.folders = [];                             

                            for (var selectedFolderIndex = 0; selectedFolderIndex < $scope.selectedFolders.length; selectedFolderIndex++) {

                                $scope.selectedFolderNames.push($scope.selectedFolders.eq(selectedFolderIndex).text());

                                var getFldr = $scope.selectedFolders.eq(selectedFolderIndex),

                                getId = getFldr.attr('id'),
                                fLevel = getFldr.attr('ftlevel'),
                                fPath = getFldr.attr('ftpath'),
                                fName = getFldr.attr('ftname'),

                                getFolderArr = {
                                    'folderId' :  getId,
                                    'folderName': fName,
                                    'fullFolderPath': fPath,
                                    'folderLevel': fLevel,
                                };

                                $scope.required.folders.push(getFolderArr);

                            }                         


                            // $scope.selectedFolderNames.forEach(function(name) {

                            //     $scope.foldersArray.forEach(function(folder) {

                            //         if (folder.folderName === name) {
                            //             $scope.required.folders.push(folder);
                            //         }
                            //     });
                            // });

                            $scope.required.operationScope = optionScope.mainOption;

                            if($scope.required.operationScope.id == 'findFolderMain'){
                                $scope.modalInstance = ModalService.showModal({
                                    templateUrl: '/vmf/m/components/folderTree/template/findFolder.tpl.html',
                                    controller: "folderTreeController"
                                }).then(function(modal) {
                                    modal.element.modal({backdrop: 'static'});
                                    _this.createModal($scope.required, $scope.completeFolderStack);                                    
                                });
                                if(typeof riaLinkmy !="undefined") riaLinkmy("my-licenses : find-folder");
                            }

                            if($scope.required.operationScope.id == 'shareFolderMain'){
                                $scope.modalInstance = ModalService.showModal({
                                    templateUrl: '/vmf/m/components/folderTree/template/shareFolder.tpl.html',
                                    controller: "folderTreeController"
                                }).then(function(modal) {
                                    modal.element.modal({backdrop: 'static'});
                                    _this.createModal($scope.required, $scope.completeFolderStack);  
                                    _this.getUsers();                             
                                });
                                if(typeof riaLinkmy !="undefined") riaLinkmy("my-licenses : share-folder");
                            }

                            if($scope.required.operationScope.id == 'inviteNewUserMain'){
                                $scope.modalInstance = ModalService.showModal({
                                    templateUrl: '/vmf/m/components/folderTree/template/inviteUser.tpl.html',
                                    controller: "folderTreeController"
                                }).then(function(modal) {
                                    modal.element.modal({backdrop: 'static'});
                                    _this.createModal($scope.required, $scope.completeFolderStack);                          
                                });
                                if(typeof riaLinkmy !="undefined") riaLinkmy("my-licenses : invite-new-user");
                            }

                             if($scope.required.operationScope.id == "createFolderMain"){
                                 
                                $scope.modalInst = ModalService.showModal({
                                    templateUrl: '/vmf/m/components/folderTree/template/createFolder.tpl.html',
                                    controller: "folderTreeController"
                                }).then(function(modal) {
                                    modal.element.modal({backdrop: 'static'});
                                     _this.createModal($scope.required, $scope.completeFolderStack);
                                     _this.publishGetFolderPathCreate();
                                }); 
                            }

                             if($scope.required.operationScope.id == "deleteFolderMain"){

                                 $scope.modalInst = ModalService.showModal({
                                                        templateUrl: '/vmf/m/components/folderTree/template/deleteFolder.tpl.html',
                                                        controller: "folderTreeController"
                                                    }).then(function(modal) {
                                                        modal.element.modal({backdrop: 'static'});
                                                         _this.createModal($scope.required, $scope.completeFolderStack);
                                                    });
                                                    
                                if(typeof riaLinkmy !="undefined") riaLinkmy("my-licenses : delete-folder");

                            }

                             if($scope.required.operationScope.id == "moveFolderMain"){
                                 
                                 $scope.modalInst = ModalService.showModal({
                                                        templateUrl: '/vmf/m/components/folderTree/template/moveFolder.tpl.html',
                                                        controller: "folderTreeController"
                                                    }).then(function(modal) {
                                                        modal.element.modal({backdrop: 'static'});
                                                         _this.createModal($scope.required, $scope.completeFolderStack);
                                                         _this.publishGetFolderPath();
                                                    }); 
                                if(typeof riaLinkmy !="undefined") riaLinkmy("my-licenses : move-folder");
                            }
                            
                            if($scope.required.operationScope.id == "renameFolderMain"){
                                 
                                 $scope.modalInst = ModalService.showModal({
                                                        templateUrl: '/vmf/m/components/folderTree/template/renameFolder.tpl.html',
                                                        controller: "folderTreeController"
                                                    }).then(function(modal) {
                                                        modal.element.modal({backdrop: 'static'});
                                                         _this.createModal($scope.required, $scope.completeFolderStack);
                                                    }); 
                                if(typeof riaLinkmy !="undefined") riaLinkmy("my-licenses : rename-folder");
                            }

                            /*$scope.modalInstance = ModalService.showModal({
                                templateUrl: '/app/components/FolderTree/template/folderActions.html',
                                controller: "folderTreeController"
                            }).then(function(modal) {
                                modal.element.modal();
                                _this.createModal($scope.required, $scope.completeFolderStack);
                            });*/

                        } else {
                            return false;
                        }
                    }

                    $scope.thisTree.find(".actionAllBox").removeClass("optionsOpen");
                };

                function removeContextMenuBox(){
                  angular.element(".actionEachBox").removeAttr('style').addClass('hidden');
                  $scope.thisTree.find(".actionEach").remove();
                  $scope.thisTree.find("li.menuOpen").removeClass('menuOpen');
                }

                $document.on('click.actionsDropdown', function($event) {
                    if ($($event.target).is("label"))
                        return false;
                    angular.forEach(angular.element(".folderSelector"), function(value, key) {
                        if (!angular.element(angular.element(".folderSelector")[key]).hasClass("selected")) {
                            angular.element(angular.element(".folderSelector")[key]).parent().removeClass("highlight");
                        }
                    });
                    //angular.element(".actionEachBox").prev().not(".selected").parent().removeClass("highlight");
                    if(!$($event.target).parents('.foldertreeUl').length){
                        removeContextMenuBox();
                    }
                    angular.element(".actionAllBox").removeClass("optionsOpen");
                });
            }
        };
    }
]);

folderTreeApp.service('folderDataService', [function() {
    this.allFolders = [];
}]);

folderTreeApp.controller("folderTreeController", ["$scope", "$sce", "$http", "$timeout", "$element", "close", "globalData", "$compile",  "$filter",
    function($scope, $sce, $http, $timeout, $element, close, globalData, $compile, $filter) {

            $scope.globalVars = globalVariables;
            $scope.txtFindFolderSearch = '';
            $scope.localObj = {};
            $scope.folderContent = [];
            $scope.currSelectedFolderInviteShare = {};
            $scope.globalVars.enterRequiredInfoDesc = angular.element('<div />').html($scope.globalVars.enterRequiredInfo).text();
            $scope.editAccessPermissionsMsg = angular.element('<div />').html($scope.globalVars.editAccessPermissions).text();
            $scope.to_trusted = function(html_code) {
                        return $sce.trustAsHtml(html_code);
            }
            $scope.subscribe('modalObject',function(data){
                $scope.modalData = data;

                if( $scope.modalData.operationScope.id == 'inviteNewUserInner' || 
                    $scope.modalData.operationScope.id == 'shareFolderInner' ||
                    $scope.modalData.operationScope.id == 'inviteNewUserMain' || 
                    $scope.modalData.operationScope.id == 'shareFolderMain'){
                    
                    
                   
                        $scope.inviteShareInit = true;
                        $scope.enteredStep2 = false;
                        $scope.currSelectedFolderInviteShare = $scope.modalData.folders[0];

                }

            });

            $scope.renderHTML = function(html_code){
                    var decoded = angular.element('<textarea />').html(html_code).text();
                    return $sce.trustAsHtml(decoded);
            };

            // Start Edit Folder Permissions

            $scope.subscribe('editFolderPermissions',function(){
                $scope.getPermissionsEdit();
            });

            $scope.resetEditPermissions = function(){
                $scope.editPermissionStep1 = false;
                $scope.editPermissionStep2 = false;
                $scope.selectPermWarningEdit = false;
            }

            $scope.goToEditPermStep2 = function(){
                $scope.resetEditPermissions();
                $scope.editPermissionStep2 = true;
                $scope.getPermUserList();                
            }

            $scope.getPermUserList = function(){

                $scope.getPermissionUserErrorMsg = '';
                $scope.ajaxLoader = true;
                $scope.getApprovalList = {};

                var foldersSelectedArray = [];
                var foldersUnselectedArray = [];

                angular.forEach($scope.getFolderPermissions.permissionPaneContents, function(val,key){
                    if(!val.isLoggedInUserCanEdit && !val.isSet){
                        if(val.checked == true){
                            foldersSelectedArray.push(val.permissionCode);
                        }
                    }
                });

                /*angular.forEach($scope.getFolderPermissions.permissionPaneContents, function(val,key){
                    if(!val.isLoggedInUserCanEdit && val.isSet){
                        if(val.checked == false){
                            foldersUnselectedArray.push(val.permissionCode);
                        }
                    }
                });*/

                if($scope.localObj.adminCheckPerm == true){
                    var adminChk = 'Y';
                } else{
                     var adminChk = 'N';
                }

                 var params = { 
                                        "slectedFolderReqIdHide":$scope.modalData.folders[0]['folderId'],
                                        "selectedReqPermissionIds":foldersSelectedArray.join(','),
                                        "unselectedReqPermissionIds": foldersUnselectedArray.join(','),
                                        "selectedReqCustomerId":globalData.loggedUserInfo.customerNumber,
                                        "adminReqRoleSelected": adminChk,
                                        "txtareaRequestNote":$scope.getPermissionNote
                              };

                var paramsEncoded = $.param(params);

                $http({
                    method: 'POST',
                    url: globalVariables.getPermUserListUrl,
                    data: paramsEncoded,
                    headers: {'Content-Type': 'application/x-www-form-urlencoded'}
                }).
                success(function(data, status, headers, config) { 

                    if(data == null || data == undefined || data == ''){

                        $scope.getPermissionUserErrorMsg = globalVariables.emptyDataMessage;
                        
                    } else if(data.error == true){

                         $scope.getPermissionUserErrorMsg = data.message;

                    } else {

                        $scope.getApprovalList = data.approverList;

                    }

                    $scope.ajaxLoader = false;

                }).
                error(function(data, status, headers, config) {
                    // called asynchronously if an error occurs
                    // or server returns response with an error status.
                    $scope.ajaxLoader = false;
                    $scope.getPermissionUserErrorMsg = globalVariables.emptyDataMessage;
                });

            }

            $scope.reqPermSubmit = function(){

                $scope.submitPermissionErrorMsg = '';
                $scope.ajaxLoader = true;


                var foldersSelectedArray = [];
                var foldersUnselectedArray = [];

                angular.forEach($scope.getFolderPermissions.permissionPaneContents, function(val,key){
                    if(!val.isLoggedInUserCanEdit && !val.isSet){
                        if(val.checked == true){
                            foldersSelectedArray.push(val.permissionCode);
                        }
                    }
                });

                /*angular.forEach($scope.getFolderPermissions.permissionPaneContents, function(val,key){
                    if(!val.isLoggedInUserCanEdit && val.isSet){
                        if(val.checked == false){
                            foldersUnselectedArray.push(val.permissionCode);
                        }
                    }
                });*/

                if($scope.localObj.adminCheckPerm == true){
                    var adminChk = 'Y';
                } else{
                     var adminChk = 'N';
                }

                var params = { 
                                "slectedFolderReqIdHide": $scope.modalData.folders[0]['folderId'],
                                "selectedReqPermissionIds": foldersSelectedArray.join(','),
                                "unselectedReqPermissionIds": foldersUnselectedArray.join(','),
                                "selectedReqCustomerId": globalData.loggedUserInfo.customerNumber,
                                "adminReqRoleSelected": adminChk,
                                "txtareaRequestNote": $scope.getPermissionNote
                             };

                var paramsEncoded = $.param(params);

                 $http({
                    method: 'POST',
                    url: globalVariables.requestedPermissionUrl,
                    data: paramsEncoded,
                    headers: {'Content-Type': 'application/x-www-form-urlencoded'}
                }).
                success(function(data, status, headers, config) { 

                    if(data == null || data == undefined || data == ''){

                         $scope.closeModal();
                        //$scope.submitPermissionErrorMsg = globalVariables.emptyDataMessage;
                        
                    } else if(data.error == true){

                         $scope.submitPermissionErrorMsg = data.message;

                    } else {

                        $scope.closeModal();

                    }

                    $scope.ajaxLoader = false;

                }).
                error(function(data, status, headers, config) {
                    // called asynchronously if an error occurs
                    // or server returns response with an error status.
                    $scope.ajaxLoader = false;
                    $scope.submitPermissionErrorMsg = globalVariables.emptyDataMessage;
                });

            }

            $scope.goToEditPermStep1 = function(){
                $scope.resetEditPermissions();
                $scope.editPermissionStep1 = true;                
            }

             $scope.getPermissionsEdit= function(){

                $scope.localObj.adminCheckPerm = false;

                $scope.resetEditPermissions();
                $scope.editPermissionStep1 = true;

                $scope.getPermissionErrorMsg = '';
                $scope.getPermissionNote = '';
                $scope.ajaxLoader = true;

                var params = { 
                    'selectedFolderId': $scope.modalData.folders[0]['folderId'],
                    'selectedCustomerNumber': globalData.loggedUserInfo.customerNumber
                };

                var paramsEncoded = $.param(params);

                $http({
                    method: 'POST',
                    url: globalVariables.getPermissionsEditUrl,
                    data: paramsEncoded,
                    headers: {'Content-Type': 'application/x-www-form-urlencoded'}
                }).
                success(function(data, status, headers, config) { 

                    if(data == null || data == undefined || data == ''){

                        $scope.getPermissionErrorMsg = globalVariables.emptyDataMessage;

                    } else if(data.error == true){

                         $scope.getPermissionErrorMsg = data.message;

                    } else {
                            $scope.ajaxLoader = false;

                            $scope.getFolderPermissions = data;

                            // if permissionpanecontents length is 0, then add default values manually
                            if( data.permissionPaneContents.length === 0 ){
                                $scope.getFolderPermissions = {
                                    "managePermission": null,
                                    "folderAccess": null,
                                    "permissionPaneCacheTimestamp": null,
                                    "permissionPaneContents": [
                                        {
                                            "level": 0,
                                            "category": "GLOBAL",
                                            "permissionCode": "PERMISSION09",
                                            "sortOrder": 10,
                                            "permissionName": globalVariables.manageRolesLbl,
                                            "isSet": false,
                                            "isInherited": false,
                                            "isLoggedInUserCanEdit": false
                                        },
                                        {
                                            "level": 0,
                                            "category": "GLOBAL",
                                            "permissionCode": "PERMISSION08",
                                            "sortOrder": 20,
                                            "permissionName": globalVariables.viewSupportLbl,
                                            "isSet": false,
                                            "isInherited": false,
                                            "isLoggedInUserCanEdit": false
                                        },
                                        {
                                            "level": 0,
                                            "category": "GLOBAL",
                                            "permissionCode": "PERMISSION07",
                                            "sortOrder": 30,
                                            "permissionName": globalVariables.viewOrdersLbl,
                                            "isSet": false,
                                            "isInherited": false,
                                            "isLoggedInUserCanEdit": false
                                        },
                                        {
                                            "level": 0,
                                            "category": "FOLDER",
                                            "permissionCode": "PERMISSION01",
                                            "sortOrder": 40,
                                            "permissionName": globalVariables.viewLicenseLbl,
                                            "isSet": false,
                                            "isInherited": false,
                                            "isLoggedInUserCanEdit": false
                                        },
                                        {
                                            "level": 1,
                                            "category": "FOLDER",
                                            "permissionCode": "PERMISSION02",
                                            "sortOrder": 50,
                                            "permissionName": globalVariables.manageFoldersLbl,
                                            "isSet": false,
                                            "isInherited": false,
                                            "isLoggedInUserCanEdit": false
                                        },
                                        {
                                            "level": 1,
                                            "category": "FOLDER",
                                            "permissionCode": "PERMISSION03",
                                            "sortOrder": 60,
                                            "permissionName": globalVariables.devideCombineLbl,
                                            "isSet": false,
                                            "isInherited": false,
                                            "isLoggedInUserCanEdit": false
                                        },
                                        {
                                            "level": 1,
                                            "category": "FOLDER",
                                            "permissionCode": "PERMISSION04",
                                            "sortOrder": 70,
                                            "permissionName": globalVariables.upgradeDowngradeLbl,
                                            "isSet": false,
                                            "isInherited": false,
                                            "isLoggedInUserCanEdit": false
                                        },
                                        {
                                            "level": 0,
                                            "category": "FOLDER",
                                            "permissionCode": "PERMISSION05",
                                            "sortOrder": 80,
                                            "permissionName": globalVariables.fileTechnicalLbl,
                                            "isSet": false,
                                            "isInherited": false,
                                            "isLoggedInUserCanEdit": false
                                        },
                                        {
                                            "level": 0,
                                            "category": "FOLDER",
                                            "permissionCode": "PERMISSION06",
                                            "sortOrder": 90,
                                            "permissionName": globalVariables.downloadProductsLbl,
                                            "isSet": true,
                                            "isInherited": false,
                                            "isLoggedInUserCanEdit": false
                                        }
                                    ],
                                    "isFolderAdmin": false,
                                    "manageRolesPermission": false
                                }
                            };


                            $scope.editPermCopy = {};                    

                            angular.forEach($scope.getFolderPermissions.permissionPaneContents, function(val, key){
                                val.checked = false;
                                val.disabled = false;
                            });

                            angular.copy($scope.getFolderPermissions, $scope.editPermCopy);

                            $scope.addPermTooltips();                            
                            
                            $scope.hideAdmin = true;
                            for( var i=0; i<$scope.modalData.folders.length; i++ ){
                              if( $scope.modalData.folders[i]['folderLevel'] === 2 ){
                                $scope.hideAdmin = false;
                              }
                            }

                    }                   

                }).
                error(function(data, status, headers, config) {
                    // called asynchronously if an error occurs
                    // or server returns response with an error status.
                    $scope.ajaxLoader = false;
                    $scope.getPermissionErrorMsg = globalVariables.emptyDataMessage;
                });
            }

            $scope.addPermTooltips = function(){
                $timeout(function(){
                      $element.find('.requestPermissionsWrap').find('span.icon_lock_grey')
                            .addClass('vmf-tooltip')
                            .attr('data-toggle','tooltip')
                            .tooltip({container:'body', placement:'right'});

                }, 500);
            }

            // Start - Share foler tree functionalities 

            $scope.popUpFolderRoot = {
                'value': '1',
                'text': 'License Folders',
                'showHeader' : false,
                'disabled': false,
                'showFolderOptions' : false,
                'instanceId' : 'shareFolderFT',
                'checked': true
            };

            $scope.getFolderTree = function(folderInst){

                $scope.ftAjaxLoader = true;
                $scope.ftErrorMsg = '';
                $scope.emptyTree = false;

                $scope.getFolderUrl = globalVariables.folderTreeGetUrl;

                //var params = { 'EA_NUMBER_SELECTED_BY_USER' : folderDetails.eaAccount};

                //var paramsEncoded = $.param(params);

                if(folderInst == 'shareFolderFT'){

                       var params = { 
                                        'selectedUserCustomerNumber':'order',
                                        'folderView':'addUserToFolder'
                                    };

                       var paramsEncoded = $.param(params);

                } else {

                        var paramsEncoded = '';
                }

                $http({
                    method: 'POST',
                    url: $scope.getFolderUrl,
                    data: paramsEncoded,
                    headers: {'Content-Type': 'application/x-www-form-urlencoded'}
                }).
                success(function(data, status, headers, config) {        

                        if(data.error == true){
                            $scope.ftErrorMsg = data.message;
                        } else if(data == null || data == '' || data == undefined ){
                             $scope.ftErrorMsg = globalVariables.emptyDataMessage;
                        } else {

                            $scope.emptyTree = data.emptyTree;
                            $scope.folderContent = data.folderContents;
                            $scope.currEaAccount = data.eaNumber;

                        }  

                        $scope.ftAjaxLoader = false;            

                    //if(eaAccountChanged == true)
                        $scope.publish('folderTreeChange', {folderData : data.folderContents, instanceId : folderInst});
                }).
                error(function(data, status, headers, config) {
                    $scope.ftAjaxLoader = false;
                    $scope.ftErrorMsg = globalVariables.commonAjaxErrorMessage;
                    // called asynchronously if an error occurs
                    // or server returns response with an error status.
                });
            }  

            //$scope.folderContent =             

            $scope.selectedUsersData = [];
            $scope.folderContent = [];
            $scope.getFolderPermissions = [];
            $scope.getSelectedFolders = [];

            $scope.subscribe('getUserDetails', function(){
                $scope.getUserDetails();
            });

            $scope.resetSteps = function(){
                $scope.shareFolderStepOne = false;
                $scope.shareFolderStepTwo = false;
                $scope.shareFolderStepThree = false;
                $scope.shareFolderStepFour = false;
                $scope.selectPermWarning = false;
            }

            $scope.resetSteps(); // Initialize Steps
            $scope.shareFolderStepOne = true;
            $scope.hideAdmin = true;

            $scope.shareFoldersStep1 = function(){
                $scope.resetSteps();
                $scope.shareFolderStepOne = true;
            }

            $scope.shareFoldersStep4 = function(page){

                $scope.resetSteps();
                $scope.shareFolderStepFour = true;
                $scope.userAddedData = {};


                $scope.ajaxLoader = true;
                $scope.shareFolderErrorMsg = '';

                // post parameters on production { EA_NUMBER_SELECTED_BY_USER : folderDetails.eaAccount}

                var emailList = [];
                var fNameList = [];
                var lNameList = [];
                var dataStoreForCompare = [];

                if(page == 'invite'){

                    // If invite Users                    

                    angular.copy($scope.inviteUserArr,dataStoreForCompare);

                    angular.forEach($scope.inviteUserArr, function(val, key){
                        emailList[key] = val.email;
                        fNameList[key] = val.fName;
                        lNameList[key] = val.lName;
                    });

                    var params = {
                        "emailList" : emailList.join(','),
                        "firstNameList" : fNameList.join(','),
                        "lastNameList" : lNameList.join(',')
                    }

                }

                // If Share Users

                if(page == 'share'){ 

                    angular.copy($scope.getUsersData,dataStoreForCompare);

                    angular.forEach($scope.getUsersData, function(val, key){
                        if(val.checked == true){
                            emailList[key] = val.email;
                            fNameList[key] = val.firstName;
                            lNameList[key] = val.lastName;
                        }
                    });

                    var params = {
                        "emailList" : emailList.join(','),
                        "firstNameList" : fNameList.join(','),
                        "lastNameList" : lNameList.join(',')
                    }

                }

                var postDataEncoded = $.param(params);

                $http({
                        method: 'POST',
                        url: globalVariables.processUserList,
                        data: postDataEncoded,
                        headers: {'Content-Type': 'application/x-www-form-urlencoded'}
                }).
                success(function(data, status, headers, config) { 
                        
                    if(data.error == true){
                        $scope.shareFolderErrorMsg = data.message;
                    } else if(data == '' || data == null || data == undefined){
                        $scope.shareFolderErrorMsg = globalVariables.emptyDataMessage;
                    } else {
                        $scope.userAddedData = data;


                        angular.forEach($scope.userAddedData.invitedUserList, function(val,key){
                            angular.forEach(dataStoreForCompare, function(valUser,keyUser){
                                if(valUser.email == val.email){
                                    if(page == 'invite'){
                                        val.firstName = valUser.fName;
                                        val.lastName = valUser.lName;
                                    } else {
                                        val.firstName = valUser.firstName;
                                        val.lastName = valUser.lastName;
                                    }
                                }                                    
                            });
                        });

                    }

                    $scope.ajaxLoader = false;
                    if($scope.modalData.operationScope.id == 'shareFolderInner' || $scope.modalData.operationScope.id == 'shareFolderMain'){
                        if(typeof riaLinkmy !="undefined") riaLinkmy("my-licenses : share-folder-confirmation");
                    } else {
                        if(typeof riaLinkmy !="undefined") riaLinkmy("my-licenses : invite-user-confirmation");
                    }
                    
                }).
                error(function(data, status, headers, config) {
                    $scope.ajaxLoader = false;
                    $scope.shareFolderErrorMsg = globalVariables.commonAjaxErrorMessage;
                    // called asynchronously if an error occurs
                    // or server returns response with an error status.
                });
                
                

            }

            $scope.isSelectedFldrChkd = function(){
                return $('.productsContainerBody .foldertreeUl input[type="checkbox"]:checked').length >= 1;
            }

            $scope.shareFoldersStep3 = function(fromStep2){

                if($scope.isSelectedFldrChkd() || $scope.inviteShareInit == true){

                    $element.find('.infoIcon').popover({ 
                      trigger: "manual", 
                      html: true,
                      animation:false,
                      content: function(){
                        $scope.admin_tooltipedited = $scope.globalVars.administratorRoleTooltip
                         $scope.admin_tooltipedited = $scope.admin_tooltipedited.replace("<a","<a href='http://kb.vmware.com/kb/2035526?plainview=true' target='_blank'");
                         return  $scope.admin_tooltipedited;
                      }
                    }).on("mouseenter", function () {
                            var _this = this;
                            $(this).popover("show");
                            $(".popover").on("mouseleave", function () {
                                $(_this).popover('hide');
                            });
                        }).on("mouseleave", function () {
                            var _this = this;
                            setTimeout(function () {
                                if (!$(".popover:hover").length) {
                                    $(_this).popover("hide");
                                }
                            }, 300);
                    });
                        
                    $scope.resetSteps();
                    $scope.shareFolderStepThree = true;
                    $scope.getSelectedFolderDetails();                

                    $scope.getPermissions();
                    if($scope.modalData.operationScope.id == 'shareFolderInner' || $scope.modalData.operationScope.id == 'shareFolderMain'){
                        if(typeof riaLinkmy !="undefined") riaLinkmy("my-licenses : share-folder-select-permissions");
                    } else {
                        if(typeof riaLinkmy !="undefined") riaLinkmy("my-licenses : invite-user-select-permissions");
                    }
                }
            }

            $scope.permissionChange = function(obj){

                $timeout(function(){
                    if(obj.permissionCode == 'PERMISSION07' && obj.checked == true){
                        $scope.resetSteps();
                        $scope.selectPermWarning = true;
                    }

                    if(obj.checked == true){
                        if(obj.permissionCode == 'PERMISSION02' || obj.permissionCode == 'PERMISSION03' || obj.permissionCode == 'PERMISSION04'){
                            angular.forEach($scope.getFolderPermissions, function(val, key){
                                if(val.permissionCode == 'PERMISSION01'){
                                    val.checked = true;
                                }
                            });
                        }
                    }

                    if(obj.permissionCode == 'PERMISSION01'){
                        angular.forEach($scope.getFolderPermissions, function(val, key){
                            if(val.permissionCode == 'PERMISSION02' || val.permissionCode == 'PERMISSION03' || val.permissionCode == 'PERMISSION04'){
                                if(val.checked == true){
                                    obj.checked = true;
                                }                                 
                            }
                        });
                    }
                    
                });              
            }



            $scope.permissionChangeEdit = function(obj){

                $timeout(function(){
                    if(obj.permissionCode == 'PERMISSION07' && obj.checked == true){
                        $scope.resetEditPermissions();
                        $scope.selectPermWarningEdit = true;
                    }

                    if(obj.checked == true){
                        if(obj.permissionCode == 'PERMISSION02' || obj.permissionCode == 'PERMISSION03' || obj.permissionCode == 'PERMISSION04'){
                            angular.forEach($scope.getFolderPermissions, function(val, key){
                                if(val.permissionCode == 'PERMISSION01'){
                                    val.checked = true;
                                }
                            });
                        }
                    }

                    if(obj.permissionCode == 'PERMISSION01'){
                        angular.forEach($scope.getFolderPermissions, function(val, key){
                            if(val.permissionCode == 'PERMISSION02' || val.permissionCode == 'PERMISSION03' || val.permissionCode == 'PERMISSION04'){
                                if(val.checked == true){
                                    obj.checked = true;
                                }                                 
                            }
                        });
                    }
                    
                }); 

                $timeout(function(){
                    $scope.checkEditPermInputChange();
                },500);    

            }

            $scope.permissionChangeOk = function(){
                 $scope.resetSteps();
                 $scope.resetEditPermissions();
                 $scope.shareFolderStepThree = true;
                 $scope.editPermissionStep1 = true;
            }

            $scope.confirmFolderShare = function(){

                $scope.shareFolderErrorMsg = '';
                $scope.ajaxLoader = true;

                var foldersListCSV = [];
                var selectedPermsCSV = [];

                angular.forEach($scope.getSelectedFolders, function(val, key){
                    if(val.folderId!=""){
                        foldersListCSV.push(val.folderId);
                    }
                });

                 angular.forEach($scope.getFolderPermissions, function(val, key){
                    if(val.checked == true)
                        selectedPermsCSV.push(val.permissionCode);
                });

                 if($scope.localObj.adminCheck == true){
                        selectedPermsCSV.push('ADMIN_PERM');
                 }

                var params = {
                        "totselectedUsersFolderIds" : foldersListCSV.join(','),
                        "SelectedPermissions" : selectedPermsCSV.join(',')
                }

                var postDataEncoded = $.param(params);

                $http({
                    method: 'POST',
                    url: globalVariables.addUsersInEAToFolders,
                    data: postDataEncoded,
                    headers: {'Content-Type': 'application/x-www-form-urlencoded'}
                }).success(function(data, status, headers, config) {   

                        if(data.error == true){
                            $scope.shareFolderErrorMsg = data.message;
                        } else {                              
                            $scope.closeModal(); 
                        }       

                        $scope.ajaxLoader = false;            

                    }).
                    error(function(data, status, headers, config) {
                        // called asynchronously if an error occurs
                        // or server returns response with an error status.
                        $scope.ajaxLoader = false;
                        $scope.shareFolderErrorMsg = globalVariables.permsNotAvailableError;
                });                
            }

            $scope.getSelectedFolderDetails = function(){                

                $scope.getSelectedFolders = [];
                $scope.sltFolderLevels = [];

                if($scope.enteredStep2 == true){

                    angular.forEach(
                        angular.element('.productsContainerBody input[type=checkbox]:checked'),
                        function(val,key){

                            var elem = angular.element(val).parents('li:eq(0)');
                            var getJson = {
                                                'folderId' : elem.attr('id'),
                                                'folderName' : elem.attr('ftName'),
                                                'folderLevel' : elem.attr('ftLevel'),
                                                'fullFolderPath' : elem.attr('ftPath')

                                          };
                            $scope.getSelectedFolders.push(getJson);
                            $scope.sltFolderLevels.push( parseInt(getJson.folderLevel) );
                        }
                    );    

                } else {
                    $scope.getSelectedFolders.push($scope.currSelectedFolderInviteShare);
                    $scope.sltFolderLevels.push( parseInt($scope.currSelectedFolderInviteShare["folderLevel"]) );
                }             
                
            }


            $scope.changeAdminFn = function(){
            
                $timeout(function(){
                
                     if( $scope.localObj.adminCheck ){

                    angular.forEach($scope.getFolderPermissions, function(val,key){
                      if(val.permissionCode !== "PERMISSION06" && val.permissionCode !== "PERMISSION07"){ // neither 6 nor 7
                           val.checked = true;
                           val.disabled = true;
                      }
                    });

                  }else{

                    angular.forEach($scope.getFolderPermissions, function(val,key){
                      if(val.permissionCode !== "PERMISSION06" && val.permissionCode !== "PERMISSION07"){ // neither 6 nor 7
                           val.checked = false;
                           val.disabled = false;
                      }
                    });
                  }
                  
                }, 300);           
              
            }

            function renderRequestPermissionsStep1(){
              $scope.ajaxLoader = false;
              $scope.editPermCopy = {};

              angular.forEach($scope.getFolderPermissions.permissionPaneContents, function(val, key){
                if(val.isLoggedInUserCanEdit && val.isSet){
                    val.checked = true;                  
                 } else {
                    val.checked = false;
                 }
                 val.disabled = false;
              });

              angular.copy($scope.getFolderPermissions, $scope.editPermCopy);

              $scope.addPermTooltips();                            
              
              $scope.hideAdmin = true;
              for( var i=0; i<$scope.modalData.folders.length; i++ ){
                if( $scope.modalData.folders[i]['folderLevel'] === 2 ){
                  $scope.hideAdmin = false;
                }
              }
            }


           $scope.changeAdminFnEdit = function(){                
                $timeout(function(){

                    // if admincheckbox is checked
                    if( $scope.localObj.adminCheckPerm ){
                      //except permission07, check all checboxes and disabled them
                      angular.forEach($scope.getFolderPermissions.permissionPaneContents,function(val,key){
                        if(val.permissionCode !== "PERMISSION06" && val.permissionCode !== "PERMISSION07"){
                           val.checked = true;
                           val.disabled = true;
                        }
                      });
                    }else{ // else (admincheckbox is unchecked)
                      // if NOT isFolderAdmin
                      if( !$scope.getFolderPermissions.isFolderAdmin ){
                        //re-render the entire permission step
                        renderRequestPermissionsStep1();
                      }else{// if isFolderAdmin
                        //show error message - requestRemoveAdminMsg

                        //except permission07 - uncheck all checkboxes and enable
                        angular.forEach($scope.getFolderPermissions.permissionPaneContents, function(val,key){
                          if(val.permissionCode !== "PERMISSION06" && val.permissionCode !== "PERMISSION07"){
                            val.checked = false;
                            val.disabled = false;
                            
                          }
                        });
                      }
                    }

                    $timeout(function(){
                        $scope.checkEditPermInputChange();
                    },500);

                }, 200);
            }

            $scope.checkEditPermInputChange = function(){

                $scope.permEditDataChanged = false;

                 angular.forEach($scope.getFolderPermissions.permissionPaneContents,function(val,key){
                    angular.forEach($scope.editPermCopy.permissionPaneContents,function(valCopy,keyCopy){
                        if(val.permissionCode == valCopy.permissionCode){
                            if(val.checked !== undefined){
                                if(val.checked !== valCopy.checked){
                                    $scope.permEditDataChanged = true;
                                    return;
                                }
                            }
                        }
                    })
                 });

            }

            $scope.setPermissionLayout = function(){ // inviteuser + share folder - permissions related
                $scope.localObj.adminCheck = false; // dummy
                
                if($scope.sltFolderLevels.indexOf(2) === -1){
                    $scope.hideAdmin = true;
                } else {
                    $scope.hideAdmin = false;
                }
                
                var isOnlyLevel3 = true;
                if( $scope.sltFolderLevels.indexOf(1) !== -1 || $scope.sltFolderLevels.indexOf(2) !== -1 ){
                  isOnlyLevel3 = false;
                }
                
                angular.forEach($scope.getFolderPermissions, function(val,key){
                    val.checked = false;
                    if( isOnlyLevel3 && (val.permission === "PERMISSION09" || val.permission === "PERMISSION08" || val.permission === "PERMISSION07") ){
                        val.disabled = true;
                    }
                    if( val.permission === "PERMISSION06" ){
                        val.disabled = true;
                        val.checked = true;
                    }
                })

                

                $timeout(function(){
                    $element.find('.selectPermissionsDatatable').find('span.icon_lock_grey')
                            .addClass('vmf-tooltip')
                            .attr('data-toggle','tooltip')
                            .tooltip({container:'body', placement:'right'});
                },500);                

            }




            $scope.getPermissions= function(){

                $scope.shareFolderErrorMsg = '';
                $scope.ajaxLoader = true;
                $scope.hideAdmin = true;

                $http({
                        method: 'POST',
                        url: globalVariables.getPermissionsUrl,
                        headers: {'Content-Type': 'application/x-www-form-urlencoded'}
                    }).
                    success(function(data, status, headers, config) {                       

                        if(data.error == true) {

                            $scope.shareFolderErrorMsg = data.message;

                        } else if(data == null || data == undefined || data == ''){

                            $scope.shareFolderErrorMsg = globalVariables.emptyDataMessage;

                        } else {
                            $scope.getFolderPermissions = data;                            

                            angular.forEach($scope.getFolderPermissions,function(val,key){
                                if(val.permission == "PERMISSION06"){
                                    val.checked = true;
                                    val.disabled = true; 
                                } else {
                                    val.checked = false;
                                    val.disabled = false;
                                }
                            });

                            $scope.setPermissionLayout();
                        }             

                        $scope.ajaxLoader = false;
                        
                    }).
                    error(function(data, status, headers, config) {
                        // called asynchronously if an error occurs
                        // or server returns response with an error status.
                        $scope.ajaxLoader = false;
                        $scope.shareFolderErrorMsg = globalVariables.permsNotAvailableError;
                });
            }

            // Share / Invite step 2           

            $scope.shareFoldersStep2 = function(fromStep){
                $scope.resetSteps();
                $scope.shareFolderStepTwo = true;
                $scope.folderSelFlag = false;                

                $scope.enteredStep2 = true;

                if($scope.inviteShareInit == undefined)
                    $scope.inviteShareInit = true; // To initialize stuff only once. 

                if($scope.folderContent.length == 0){
                    $scope.getFolderTree('shareFolderFT');                    
                }


                var getCurrElem;

                if($scope.modalData.operationScope.id == 'shareFolderInner' || $scope.modalData.operationScope.id == 'shareFolderMain'){
                    getCurrElem = angular.element('#shareFolderFt');
                } else if ($scope.modalData.operationScope.id == 'inviteNewUserInner' || $scope.modalData.operationScope.id == 'inviteNewUserMain'){
                    getCurrElem = angular.element('#inviteUserFt');
                }

                if($scope.modalData.operationScope.id == 'inviteNewUserMain' || 
                   $scope.modalData.operationScope.id == 'shareFolderMain'){
                   $scope.inviteShareInit = false;
                }

                if($scope.modalData.operationScope.id == 'shareFolderInner' || $scope.modalData.operationScope.id == 'shareFolderMain'){
                    if(typeof riaLinkmy !="undefined") riaLinkmy("my-licenses : share-folder-select-folders");
                } else {
                    if(typeof riaLinkmy !="undefined") riaLinkmy("my-licenses : invite-user-select-folders");
                }

                if(getCurrElem.find('input[type="checkbox"]:checked').length >= 1){
                    $scope.folderSelFlag = true;
                }
                
            }

            $scope.subscribe('folderTreeChange', function(){
              $timeout(function(){
                var getCurrElem;

                if($scope.modalData.operationScope.id == 'shareFolderInner' || $scope.modalData.operationScope.id == 'shareFolderMain'){
                    getCurrElem = angular.element('#shareFolderFt');
                } else if ($scope.modalData.operationScope.id == 'inviteNewUserInner' || $scope.modalData.operationScope.id == 'inviteNewUserMain'){
                    getCurrElem = angular.element('#inviteUserFt');
                }

                if($scope.inviteShareInit == true){
                    getCurrElem.find('#'+$scope.modalData.folders[0]['folderId']).find('input[type=checkbox]').prop('checked',true);

                    $scope.folderSelFlag = true;
                    $scope.inviteShareInit = false;
                }

                getCurrElem.on('change', 'input[type="checkbox"]', function(){
                    if($(this).parents('.foldertreeUl').find('input[type="checkbox"]:checked').length >=1){
                        $scope.$apply(function(){
                          $scope.folderSelFlag = true;
                        });
                    } else {
                        $scope.$apply(function(){
                          $scope.folderSelFlag = false;
                        });
                    }
                    inviteMultipleFoldersChanged = true;
                });
                
              }, 500);
            });
            
            var inviteMultipleFoldersChanged = false; // initlializing this variable as false on popupload; will be updated if any folderselection made in step2

            $scope.inviteUserStep1Continue = function(){

                var getSelectedFolderLength;

                if( inviteMultipleFoldersChanged ){
                
                  $scope.shareFoldersStep2(); // show step2 for sure, when some changes werer there in foldertree
                
                }else{
                  getSelectedFolderLength = $('#inviteUserFt input[type="checkbox"]:checked').length;

                  if(($scope.inviteShareInit == true || getSelectedFolderLength >= 1) && $scope.modalData.operationScope.id == 'inviteNewUserInner'){
                    $scope.shareFoldersStep3();
                  }else{
                    $scope.shareFoldersStep2();
                  }
                }
            }


             $scope.inviteUserStep3Back = function(){

                 var getSelectedFolderLength = $('#inviteUserFt input[type="checkbox"]:checked').length;

                if(($scope.inviteShareInit == true || getSelectedFolderLength >= 1) && $scope.modalData.operationScope.id == 'inviteNewUserInner')
                    $scope.shareFoldersStep1(); 
                else 
                    $scope.shareFoldersStep2('step3');
            }

              $scope.shareFolderStep1Continue = function(){

                 var getSelectedFolderLength = $('#shareFolderFt input[type="checkbox"]:checked').length;

                if(($scope.inviteShareInit == true || getSelectedFolderLength >= 1) && $scope.modalData.operationScope.id == 'shareFolderInner')
                    $scope.shareFoldersStep3(); 
                else 
                    $scope.shareFoldersStep2();
            }


             $scope.shareFolderStep3Back = function(){

                 var getSelectedFolderLength = $('#shareFolderFt input[type="checkbox"]:checked').length;

                if(($scope.inviteShareInit == true || getSelectedFolderLength >= 1) && $scope.modalData.operationScope.id == 'shareFolderInner')
                    $scope.shareFoldersStep1(); 
                else 
                    $scope.shareFoldersStep2('step3');
            }


            $scope.getUserDetails = function(){

                $scope.shareFolderErrorMsg = '';
                $scope.ajaxLoader = true;

                $http({
                        method: 'POST',
                        url: globalVariables.getUsersUrl,
                        headers: {'Content-Type': 'application/x-www-form-urlencoded'}
                    }).
                    success(function(data, status, headers, config) {                       

                        if(data.error == true){

                            $scope.shareFolderErrorMsg = data.message;

                        } else if(data == null || data == undefined || data == ''){

                            $scope.shareFolderErrorMsg = globalVariables.emptyDataMessage;

                        } else {

                             $scope.getUsersData = data.userPaneContents;

                            angular.forEach($scope.getUsersData, function(value, key) {
                                  value.checked = false;
                                  value.selected = false;
                            });

                        }                    

                        $scope.ajaxLoader = false;
                    }).
                    error(function(data, status, headers, config) {
                        // called asynchronously if an error occurs
                        // or server returns response with an error status.
                        $scope.ajaxLoader = false;
                        $scope.shareFolderErrorMsg = globalVariables.commonAjaxErrorMessage;
                });

            }


            // Invite Users Loop

            $scope.localObj.txtEmail = '';
            $scope.localObj.txtFName = '';
            $scope.localObj.txtLName = '';
            $scope.localObj.filterTextInput = '';
            $scope.emailValid = true;
            $scope.inviteUserArr = [];
            $scope.dupEmailValid = true;

            $scope.InviteUsersAdd = function(){

                if($scope.localObj.txtEmail.length !== 0){
                    if( /^([\w-]+(?:\.[\w-]+)*)@((?:[\w-]+\.)*\w[\w-]{0,66})\.([a-z]{2,6}(?:\.[a-z]{2})?)$/i.test($scope.localObj.txtEmail) ){
                        $scope.emailValid = true;                        
                    } else {
                        $scope.emailValid = false;
                    }
                }
                
                $scope.dupEmailValid = true;
            
                angular.forEach($scope.inviteUserArr,function(val, key){
                    if($scope.localObj.txtEmail == val.email){
                        $scope.dupEmailValid = false;
                        return false;
                    }
                }); 
                
                $timeout(function(){                
                    if($scope.dupEmailValid == true &&  $scope.emailValid == true){
                        $scope.addIviteUserToArr();
                    }                   
                },400);
                
            }

            $scope.addIviteUserToArr = function(){

                var inviteObj = { 
                                    fName : $scope.localObj.txtFName,
                                    lName : $scope.localObj.txtLName,
                                    email : $scope.localObj.txtEmail
                                }

                $scope.inviteUserArr.push(inviteObj);

                $scope.localObj.txtEmail = '';
                $scope.localObj.txtFName = '';
                $scope.localObj.txtLName = '';
            }

            $scope.removeInviteUser = function(getObj){
                var getIndex = $scope.inviteUserArr.indexOf(getObj);
                $scope.inviteUserArr.splice(getIndex, 1);    
            }

            $scope.AddUser = function(){
                angular.forEach($scope.getUsersData,function(val, key){
                    if(val.selected == true)
                        if(val.checked == false)
                            val.checked = true;

                    val.selected = false;
                });

                $scope.localObj.selectAll = false;
                $scope.checkUsersShare();
            }

            $scope.removeUser = function(){
                 angular.forEach($scope.getUsersData,function(val, key){
                    if(val.selected == true)
                        if(val.checked == true)
                            val.checked = false;

                    val.selected = false;
                });

                $scope.checkUsersShare();
            } 

            $scope.filterAllUsers = function(obj){
                return obj.checked == false;
            }

            $scope.shareFldrAddBtnDisabled = true;
            $scope.shareFldrRemoveBtnDisabled = true;

            $scope.checkUsersShare = function(){

                $timeout(function(){

                    var selectedCount = 0;
                    var checkedCount = 0;
                    var selectedAndChecked = 0;

                    angular.forEach($scope.getUsersData,function(val, key){

                        if(val.selected == true && val.checked == false){
                             selectedCount++;
                        }
                         if(val.checked == true){
                            checkedCount++;
                         }

                         if(val.checked == true && val.selected == true){
                            selectedAndChecked++;
                         }

                    });


                    if(selectedCount >= 1){
                        $scope.shareFldrAddBtnDisabled = false;
                    } else {
                        $scope.shareFldrAddBtnDisabled = true;
                    }

                    if(selectedAndChecked >= 1){
                        $scope.shareFldrRemoveBtnDisabled = false;
                    } else {
                        $scope.shareFldrRemoveBtnDisabled = true;
                    }



                },200);
                
            }

            $scope.filterSelectedUsers = function(obj){
                return obj.checked == true;
            }            

            $scope.filterUser = function(){
                $scope.localObj.filterText = $scope.localObj.filterTextInput;
            }
            $scope.keyPress = function(e){
        	if(e == 13){
					$scope.filterUser();
        	  }
           }

           
             $scope.checkSltAll = function(){
              //  $scope.localObj.selectAll = !$scope.localObj.selectAll;
                
                $scope.filteredResults = $filter('filter')($scope.getUsersData,$scope.localObj.filterText);             
                
                angular.forEach($scope.getUsersData,function(val, key){ 
                    angular.forEach($scope.filteredResults,function(valFiltered, keyFiltered){
                        if(valFiltered.email == val.email){
                            if($scope.localObj.selectAll == true && val.checked !== true){
                                val.selected = true;
                            } else {
                                val.selected = false;
                            }
                        }
                    }); 
                }); 
                $scope.checkUsersShare();
            }


            // End - Share foler tree functionalities 


            // Start - move folder tree functionalities

            $scope.subscribe('getFolderTreePaths',function(data){
                     $scope.getFolderPaths();
            });

             $scope.subscribe('getFolderTreePathsCreate',function(data){
                     $scope.getFolderPathsCreate();
            });

            // Find Folder Initialization Start

            $scope.changeRadio = function(selectedFldrObj){
               $scope.findFolderGetSltRadio = selectedFldrObj.fullFolderPath;
               $scope.selectedFolderObj = selectedFldrObj;

            }

            $scope.ftFindFolder = function(getFtInstanceId){

                var pubData = {
                                'folderObj' :  $scope.selectedFolderObj,
                                'ftInstanceId' : getFtInstanceId
                              }

                $scope.publish('findFolderEvt', pubData);
                $scope.closeModal();
            }

            $scope.findFolderSearch = function(){

                $scope.findFolderErrorMsg = '';
                $scope.ajaxLoader = true;
                $scope.txtFolderName = '';
                $scope.findFolderGetSltRadio;
                $scope.findFolderGetSltRadio = null;
                $scope.findFolderData = null;

                var postData = { 'folderName' : $scope.txtFindFolderSearch };

                var postDataEncoded = $.param(postData);

                $http({
                        method: 'POST',
                        url: globalVariables.findFolderSearchUrl,
                        data: postDataEncoded,
                        headers: {'Content-Type': 'application/x-www-form-urlencoded'}
                    }).
                    success(function(data, status, headers, config) {

                        if(data == '' || data === null || data === undefined){
                            $scope.findFolderErrorMsg = globalVariables.findFolderEmptyMessage;
                            if(typeof riaLinkmy !="undefined") riaLinkmy("my-licenses : find-folder : no-results");
                        } else if(data.error === true){
                            $scope.findFolderErrorMsg = data.message;
                        } else if(data.findFolderWithPathList == null){
                            $scope.findFolderErrorMsg = globalVariables.findFolderEmptyMessage;
                            if(typeof riaLinkmy !="undefined") riaLinkmy("my-licenses : find-folder : no-results");
                        }
                        else{
                            $scope.findFolderData = data.findFolderWithPathList;                            
                        }

                        $scope.ajaxLoader = false;
                    }).
                    error(function(data, status, headers, config) {
                        // called asynchronously if an error occurs
                        // or server returns response with an error status.
                        $scope.ajaxLoader = false;
                        $scope.findFolderErrorMsg = globalVariables.commonAjaxErrorMessage;
                });


            }

            // Find Folder Initialization End


            $scope.getFolderPathsCreate = function(){

                $scope.createFolderErrorMsg = '';
                $scope.ajaxLoader = true;
                $scope.txtFolderName = '';

                $scope.folderPathsUrl = globalVariables.folderPathsUrl;

                 $http({
                        method: 'POST',
                        url: $scope.folderPathsUrl,
                        headers: {'Content-Type': 'application/x-www-form-urlencoded'}
                    }).
                    success(function(data, status, headers, config) {
                            $scope.createfldrPathsData = data.folderPathList;

                            angular.forEach($scope.createfldrPathsData,function(val,key){
                                $scope.createfldrPathsData[key]["value"] = $scope.createfldrPathsData[key]["folderId"];
                                $scope.createfldrPathsData[key]["text"] = $scope.createfldrPathsData[key]["fullFolderPath"];
                            });

                            var preSelectIndex = "";
                            if($scope.modalData.folders.length >= 1){

                                angular.forEach($scope.createfldrPathsData,function(val,key){
                                    if(val.fullFolderPath == $scope.modalData.folders[0]['fullFolderPath']) {
                                        $scope.createfldrPathsOption = $scope.createfldrPathsData[key];
                                        preSelectIndex = key;
                                      }
                                });  

                            }                   
                            $element.find('.folderPathsDropdown').append( $compile('<div vmf-select-list dtitle="" list="createfldrPathsData" model="createfldrPathsOption" sortby="false" showtitle="true" pre-select-ind="' + preSelectIndex + '"></div>')($scope) );
                            $scope.ajaxLoader = false;
                        }).
                        error(function(data, status, headers, config) {
                            // called asynchronously if an error occurs
                            // or server returns response with an error status.
                            $scope.ajaxLoader = false;
                            $scope.createFolderErrorMsg = globalVariables.commonAjaxErrorMessage;
                     }); 
                    
                if(typeof riaLinkmy !="undefined") riaLinkmy("my-licenses : create-folder");
            }

            $scope.moveFolderParentId = '';            

            $scope.getFolderPaths = function(){

                $scope.moveFolderErrorMsg = '';
                $scope.moveFolderstep1 = true;
                $scope.moveFolderstep2 = false;
                $scope.ajaxLoader = true;
                $scope.folderPathsOption = null;
                $scope.folderPathsUrl = globalVariables.folderPathsUrl;

                var currId = $scope.modalData.folders[0]['folderId'];
                $scope.moveFolderParentId = $('#'+currId).parents('li:eq(0)').attr('id');

                 $http({
                        method: 'POST',
                        url: $scope.folderPathsUrl,
                        headers: {'Content-Type': 'application/x-www-form-urlencoded'}
                    }).
                        success(function(data, status, headers, config) {
                            $scope.folderPathsData = data.folderPathList;
                            $scope.finalFolderPathsData = [];
                            angular.forEach($scope.folderPathsData,function(val,key){
                                $scope.folderPathsData[key]["value"] = $scope.folderPathsData[key]["folderId"];
                                $scope.folderPathsData[key]["text"] = $scope.folderPathsData[key]["fullFolderPath"];
                                if($scope.folderPathsData[key].fullFolderPath !== $scope.modalData.folders[0]['fullFolderPath'] && $scope.folderPathsData[key].folderId !== $scope.moveFolderParentId && $scope.folderPathsData[key].fullFolderPath.indexOf($scope.modalData.folders[0]['fullFolderPath']) == -1) {
                                    $scope.finalFolderPathsData.push($scope.folderPathsData[key]);
                                }
                            });
                            $element.find('.folderPathsDropdown').append( $compile('<div vmf-select-list dtitle="" list="finalFolderPathsData" model="folderPathsOption" sortby="false" showtitle="true"></div>')($scope) );
                            $scope.ajaxLoader = false;
                        }).
                        error(function(data, status, headers, config) {
                            // called asynchronously if an error occurs
                            // or server returns response with an error status.
                            $scope.ajaxLoader = false;
                            $scope.moveFolderErrorMsg = globalVariables.commonAjaxErrorMessage;
                     });   

            }

            $scope.filterMoveFldrPaths = function(obj){
                if(obj.fullFolderPath !== $scope.modalData.folders[0]['fullFolderPath'] 
                    && obj.folderId !== $scope.moveFolderParentId
                    && obj.fullFolderPath.indexOf($scope.modalData.folders[0]['fullFolderPath']) == -1){

                    return true;

                } else {

                    return false;
                    
                }
            }

            $scope.moveFolderContinue = function(){
                $scope.moveFolderstep1 = false;
                $scope.moveFolderstep2 = true;
                angular.forEach($scope.finalFolderPathsData,function(val,key){
                    if($scope.finalFolderPathsData[key]["folderId"] === $scope.folderPathsOption) {
                        $scope.targetFullFolderPath = $scope.finalFolderPathsData[key]["fullFolderPath"];
                    }
                });
                if(typeof riaLinkmy !="undefined") riaLinkmy("my-licenses : move-folder : step-2");
            }

            $scope.moveFolderGoBack = function(){
                $scope.moveFolderstep1 = true;
                $scope.moveFolderstep2 = false;
                $scope.folderPathsOption = null;
                $scope.targetFullFolderPath = null;
            }

            $scope.createFolderConfirm = function(){  

                $scope.createFolderErrorMsg = '';
                $scope.createFolderConfirmUrl = globalVariables.createFolderConfirmUrl;
                $scope.ajaxLoader = true;

                // $scope.createFolderConfirmPostData = {
                //     'selectedFolderId' :  $scope.modalData.folders[0]['folderId'],
                //     'newFolderName' : $scope.txtFolderName
                // }

                $scope.createFolderConfirmPostData = {
                    'selectedFolderId' :  $scope.createfldrPathsOption,
                    'newFolderName' : $scope.txtFolderName
                }

                var postDataEncoded = $.param($scope.createFolderConfirmPostData);

                $http({
                        method: 'POST',
                        url: $scope.createFolderConfirmUrl,
                        data: postDataEncoded,
                        headers: {'Content-Type': 'application/x-www-form-urlencoded'}
                    }).
                    success(function(data, status, headers, config) {        

                        if(data !== null && data.error === true){
                            $scope.createFolderErrorMsg = $scope.moveFolderErrorMsg = angular.element('<span />').html(data.message).text().replace(/\\/gi, '');
                        } else {
                            $scope.publish('refreshFolderTree',{fromAction : 'moveFolder'}); 
                            $scope.closeModal(); 
                        }
                        $scope.ajaxLoader = false;
                    }).
                    error(function(data, status, headers, config) {
                        // called asynchronously if an error occurs
                        // or server returns response with an error status.
                        $scope.ajaxLoader = false;
                        $scope.createFolderErrorMsg = globalVariables.commonAjaxErrorMessage;
                 });          
 
            }

            $scope.renameFolderConfirm = function(){

                $scope.renameFolderErrorMsg = '';
                $scope.renameFolderConfirmUrl = globalVariables.renameFolderConfirmUrl;
                $scope.ajaxLoader = true;

                var renameFolderConfirmPostData = {
                    'selectedFolderId' :  $scope.modalData.folders[0]['folderId'],
                    'newFolderName' : $scope.renameTxtFolderName
                }

                var postDataEncoded = $.param(renameFolderConfirmPostData);

                $http({
                        method: 'POST',
                        url: $scope.renameFolderConfirmUrl,
                        data: postDataEncoded,
                        headers: {'Content-Type': 'application/x-www-form-urlencoded'}
                    }).
                    success(function(data, status, headers, config) {        

                        if(data !== null && data.error === true){
                            $scope.renameFolderErrorMsg = angular.element('<span />').html(data.message).text().replace(/\\/gi, '');
                        } else {
                            $scope.publish('refreshFolderTree',{fromAction : 'moveFolder'}); 
                            $scope.closeModal(); 
                        }
                        $scope.ajaxLoader = false;
                    }).
                    error(function(data, status, headers, config) {
                        // called asynchronously if an error occurs
                        // or server returns response with an error status.
                        $scope.ajaxLoader = false;
                        $scope.renameFolderErrorMsg = globalVariables.commonAjaxErrorMessage;
                 });    

            }

            $scope.moveFolderConfirm = function(){

                $scope.moveFolderErrorMsg = '';
                $scope.moveFolderConfirmUrl = globalVariables.moveFolderConfirmUrl;
                $scope.ajaxLoader = true;

                var moveFolderConfirmPostData = {

                    'selectedFolderId' :  $scope.modalData.folders[0]['folderId'],
                    'targetFullFolderPath' : $scope.targetFullFolderPath

                }

                var postDataEncoded = $.param(moveFolderConfirmPostData);

                $http({
                        method: 'POST',
                        url: $scope.moveFolderConfirmUrl,
                        data: postDataEncoded,
                        headers: {'Content-Type': 'application/x-www-form-urlencoded'}
                    }).
                    success(function(data, status, headers, config) {        

                        if(data !== null && data.error === true){
                            $scope.moveFolderErrorMsg = $scope.moveFolderErrorMsg = angular.element('<span />').html(data.message).text().replace(/\\/gi, '');
                        } else {
                            $scope.publish('refreshFolderTree',{fromAction : 'moveFolder'}); 
                            $scope.closeModal(); 
                        }
                        $scope.ajaxLoader = false;
                    }).
                    error(function(data, status, headers, config) {
                        // called asynchronously if an error occurs
                        // or server returns response with an error status.
                        $scope.ajaxLoader = false;
                        $scope.moveFolderErrorMsg = globalVariables.commonAjaxErrorMessage;
                 });          
 
            }

            // End - Move folder tree functionalities

            $scope.DeleteFolderConfirm = function() {

                $scope.deleteFolderErrorMsg = '';
                $scope.deleteFolderUrl = globalVariables.deleteFolderUrl+ '&selectedFolderId=' + $scope.modalData.folders[0]['folderId'];
                $scope.ajaxLoader = true;

                $http({
                        method: 'POST',
                        url: $scope.deleteFolderUrl,
                        headers: {'Content-Type': 'application/x-www-form-urlencoded'}
                    }).
                    success(function(data, status, headers, config) {        

                        if(data !== null && data.error === true){
                            $scope.deleteFolderErrorMsg = data.message;
                        } else {
                            $scope.publish('refreshFolderTree',{fromAction : 'deleteFolder'}); 
                            $scope.closeModal(); 
                        }
                        $scope.ajaxLoader = false;
                    }).
                    error(function(data, status, headers, config) {
                        // called asynchronously if an error occurs
                        // or server returns response with an error status.
                        $scope.ajaxLoader = false;
                        $scope.deleteFolderErrorMsg = globalVariables.commonAjaxErrorMessage;
                });                   
            };

            $scope.closeModal = function(){
                 //  Manually hide the modal.
                $element.modal('hide');
                close(null, 500);
            }

    }
]);

folderTreeApp.directive("vmfFolderOptions", ['$compile', '$timeout', '$document', '$rootScope', "ModalService",  "$http", "globalData",
    function($compile, $timeout, $document, $rootScope, ModalService, $http, globalData) {
        return {
            restrict: "A",
            scope: {
                thisTree: "=",
                folderLevelOptions: "=folderOptions",
                completeFolderStack: "=",
                folderDataFtype: "="
            },
            require: '?vmfFolderTree',
            link: function(scope, lElement, lAttrs, TreeCtrl) {

                scope.getTableType = globalData.tableType;
                scope.globalVars = globalVariables;
                //console.log("parentIndex" + scope.parentIndex);
                //TreeCtrl.testFn(lElement);

                scope.folderLevelOptions = [{
                        "text": scope.globalVars.folderOps.invite,
                        "disabledClass": "enabled",
                        "id" : "inviteNewUserInner"
                    }, {
                        "text": scope.globalVars.folderOps.share,
                        "disabledClass": "enabled",
                        "id" : "shareFolderInner"
                    }, {
                        "text": scope.globalVars.folderOps.create,
                        "disabledClass": "enabled",
                        "id" : "createFolderInner"
                    }, {
                        "text": scope.globalVars.folderOps.del,
                        "disabledClass": "enabled",
                        "id" : "deleteFolderInner"
                    }, {
                        "text": scope.globalVars.folderOps.rename,
                        "disabledClass": "enabled",
                        "id" : "renameFolderInner"
                    }, {
                        "text": scope.globalVars.folderOps.move,
                        "disabledClass": "enabled",
                        "id" : "moveFolderInner"
                    }, {
                        "text": scope.globalVars.folderOps.request,
                        "disabledClass": "enabled",
                        "id" : "requestPermissionInner"
                    }, {
                        "text": scope.globalVars.folderOps.exportCsv,
                        "disabledClass": "disabled",
                        "id" : "exportToCsvInner"
                    }];

                scope.dropDownString = '<span class="actionEach" ng-click="showOptions($event,folderDataFtype)">&nbsp;</span>';
                scope.dropDownOptionsString = '<div class="actionEachBox">' +
                    '<div class="midWrapper">' +
                    '<div class="innerWrapper">' +
                    '<ul>' +
                    '<li ng-repeat="option in folderLevelOptions" ng-class="{first:$first,last:$last}" ng-click="optionsAction($event,this)">' +
                    '<a class="{{option.disabledClass}} {{option.id}}" href="javascript:void(0);">{{option.text}}</a>' +
                    '</li>' +
                    '</ul>' +
                    '</div>' +
                    '</div>' +
                    '</div>';

                lElement.on("mouseenter", function(event) {
                    if($(this).hasClass("disabled")){
                        $(this).css("cursor","default");
                    }

                    if (!lElement.find(".actionEach").length) {
                        lElement.append($compile(scope.dropDownString)(scope));
                        lElement.addClass("highlight");
                        lElement.addClass("highlightActive");
                    }else{
                      lElement.find(".actionEach").removeClass('hidden');
                    }

                    if (!angular.element(".actionEachBox").length) {
                        //lElement.append($compile(scope.dropDownOptionsString)(scope));
                        $(document.body).append($compile(scope.dropDownOptionsString)(scope)); /* adding options-menu to the body- to come out of folder tree box */
                        lElement.addClass("highlight");
                        lElement.addClass("highlightActive");
                    }

                    lElement.not(".disabled").addClass("highlightActive");
                });

                lElement.on("mouseleave", function(event) { /*suryapavan*/

                    //checked folder's options should be removed
                    if (lElement.find(".folderSelector").hasClass("selected") || lElement.hasClass("nonCheckBox") || angular.element(".actionEachBox").hasClass("folderSelected")) {
                        lElement.addClass("highlight");
                        lElement.find(".actionEach").remove();
                    } else if ( !lElement.closest('li').hasClass("menuOpen") ) {
                        lElement.find(".actionEach").remove();
                        lElement.removeClass("highlight");
                    } else if (angular.element(".actionEachBox").hasClass("rightClicked")) {
                        lElement.find(".actionEach").remove();
                    }

                    lElement.removeClass("highlightActive");
                });

                lElement.on("mousedown", function(event) {
                    event.stopPropagation();
                    //scope.thisTree.find(".actionAllBox").removeClass("optionsOpen");
                    
                    //scope.selectedFolderLi = $(event.target).closest('li');
                    angular.element(".actionEachBox").data('folder-id', $(event.target).closest('li').attr('id'));

                    scope.rightClickFlag = false;
                    if (event.which === 3) {

                        $(document).off("contextmenu").on("contextmenu", lElement, function() {
                            event.stopPropagation();
                            return false;
                        });

                        scope.rightClickFlag = true;
                        scope.rightClickXPos = event.pageX;
                        scope.rightClickYPos = event.pageY;

                        lElement.find(".actionEach").trigger('click').addClass('hidden');
                    }

                });

                scope.showOptions = function(getEvent, getFType){
                    
                    // while opening folder-actions-dropdown, close all other dropdowns and close filters dropdown
                    scope.publish('closeAllDropdowns', getEvent);
                    scope.publish('closeAllFilters');

                    getEvent.stopPropagation();

                    var getPermValFromDom = $(lElement).parent().attr('ftPerm');
                    var getElemPath = $(lElement).parent().attr('ftPath');

                    // closing the existing optionsmenu, before opening/sending-api-call to the new options
                    angular.element(".actionEachBox").removeAttr('style').addClass('hidden');

                    if(!getPermValFromDom){

                        var getFolderId = $(lElement).parent().attr('id');

                        var params = { 
                           'selectedFolderId' : getFolderId
                        };

                        var paramsEncoded = $.param(params);
                
                        $http({
                            method: 'POST',
                            url: globalVariables.getFolderMinPermUrl,
                            data: paramsEncoded,
                            headers: {'Content-Type': 'application/x-www-form-urlencoded'}
                        }).
                        success(function(data, status, headers, config) { 
                            var  accessPerms = ''; 

                            if (data.manage) {
                                accessPerms = "MANAGE";
                            } else if (data.view) {
                                accessPerms = "VIEW";
                            } else if (!(data.view)) {
                                accessPerms = "NONE";
                            }

                            $(lElement).parent().attr('ftPerm',accessPerms);
                            scope.publish('FolderPermissionsSet',data);
                            globalData.permissionObject[getElemPath] = data;

                            scope.showOptionsRender(getEvent , getFType , accessPerms);   

                        }).
                        error(function(data, status, headers, config) {
                            // called asynchronously if an error occurs
                            // or server returns response with an error status.
                        });

                    } else {
                        scope.showOptionsRender(getEvent , getFType , getPermValFromDom);
                    }

                }

                scope.showOptionsRender = function(event, fType, permVal) {

                    var $actionEachBox = angular.element(".actionEachBox"),
                        $targetEl = $(event.target);

                    // remove actionEach for all other rows
                    scope.thisTree.find(".actionEach").not(event.target).remove();

                    // remove hightlight class for all other rows
                    /* TODO ... */

                    // remove menuOpen for all other LIs
                    scope.thisTree.find("li.menuOpen").removeClass('menuOpen').not(".selected").find(".highlight").removeClass("highlight");

                    // actionEachBox - add-optionsopen
                    $actionEachBox.addClass("optionsOpen flagClass");

                    // add menuOpen for current LI
                    $targetEl.closest('li').addClass('menuOpen');

                    /* permissions related stuff - START */
                    $timeout(function(){
                      if(permVal == 'MANAGE'){
                  
                        if(fType == 'ROOT'){                        
                            $actionEachBox.find('a').removeClass('enabled').addClass('disabled');
                        
                            if(globalData.tableType == "viewLicense"){
                                $actionEachBox.find('.createFolderInner , .exportToCsvInner').removeClass('disabled').addClass('enabled');
                            } else {
                                $actionEachBox.find('.createFolderInner , .exportToCsvInner').removeClass('enabled').addClass('disabled');
                            }
                            
                        } else if (fType == "ASP" || fType == "CPL" || fType == "VCE") {
                            
                            $actionEachBox.find('a').removeClass('enabled').addClass('disabled');
                            
                            $actionEachBox.find('.renameFolderInner , .inviteNewUserInner, .shareFolderInner').removeClass('disabled').addClass('enabled');
                            
                            if(globalData.tableType == "viewLicense"){
                                $actionEachBox.find('.exportToCsvInner').removeClass('disabled').addClass('enabled');
                            } else {
                                $actionEachBox.find('.exportToCsvInner').removeClass('enabled').addClass('disabled');
                            }
                            
                        } else {
                        
                            $actionEachBox.find('a').removeClass('disabled').addClass('enabled');
                            
                            if(globalData.tableType == "viewLicense"){
                                $actionEachBox.find('.exportToCsvInner').removeClass('disabled').addClass('enabled');
                            } else {
                                $actionEachBox.find('.exportToCsvInner').removeClass('enabled').addClass('disabled');
                            }
                            
                        }
                        
                        $actionEachBox.find('.inviteNewUserInner, .shareFolderInner').removeClass('disabled').addClass('enabled');
                  
                      } else {
                          $actionEachBox.find('a').removeClass('enabled').addClass('disabled');
                      }

                      if(globalData.tableType == "viewLicense"){
                          $actionEachBox.find('.exportToCsvInner').removeClass('disabled').addClass('enabled');
                      }

                      $actionEachBox.find('.requestPermissionInner').removeClass('disabled').addClass('enabled');
                    }, 10)
                    /* permissions related stuff - END */

                    var position = {};

                    // get top/left positions - based on the $targetEl's position

                    var tempflag = false; // temp flag to make element available before we take the positions
                    if( $targetEl.hasClass('hidden') ){
                      $targetEl.removeClass('hidden');
                      tempflag = true;
                    }
                    position = {
                      top: $targetEl.offset().top + $targetEl.height() - 7,
                      left: $targetEl.offset().left + $targetEl.outerWidth() - $actionEachBox.outerWidth(true) + 12
                    };

                    if( tempflag ){
                      $targetEl.addClass('hidden');
                    }

                    /*check the condition to verify if the context menu will fit downwards - ottherwise, show it upwards*/

                    // get contextMenu height
                    var cmenuHeight = $actionEachBox.outerHeight();

                    // topPosition = position.top
                    var getTopPos = position.top;

                    // get windowHeight
                    var winHeight = $(window).height();

                    // get element's offset - top 
                    var getInvTopPos = $targetEl.offset().top;

                    var rtClickedClass = ""; // variable that holds the class to be given for actionEachBox - which specifies whether it is opened via rt-click or normal-click

                    if(scope.rightClickFlag == true){
                      rtClickedClass = "rightClicked";
                      position = {
                          top: scope.rightClickYPos,
                          left: scope.rightClickXPos
                      };
                        getInvTopPos = false; // this variable to be used only in normal click; hence updating with false
                    }

                    if (getTopPos + cmenuHeight > winHeight + $(window).scrollTop() > 0) {
                        position.top = (getInvTopPos)? (getInvTopPos - cmenuHeight) : (getTopPos - cmenuHeight);
                    }

                    $actionEachBox.css(position).addClass(rtClickedClass).removeClass('hidden');
                    event.stopPropagation();

                };

                 scope.getClickPosition = function(event) {

                    var parentPosition = scope.getPosition(event.currentTarget);
                    var windowWidth = angular.element(window).width();
                    var windowHeight = angular.element(window).height();
                    //var xPosition = event.clientX - parentPosition.x;
                    //var xPosition = (windowWidth - event.clientX) > (angular.element(".actionEachBox").width()) ? event.clientX - parentPosition.x : 330;
                    //var xPosition = (lElement.width() - (scope.rightClickXPos - parentPosition.x)) > (angular.element(".actionEachBox").width()) ? scope.rightClickXPos - parentPosition.x : 210;
                    //var yPosition = (windowHeight - parentPosition.y) > (angular.element(".actionEachBox").height()) ? "0" : -(angular.element(".actionEachBox").height()) + 20;
                    //var yPosition = event.clientY - parentPosition.y - ) ;

                    var getScrollOffsetPos = event.currentTarget.offsetTop - $('.foldertreeUl ').scrollTop();


                    var getWrapWidth = $('.foldertreeUl').width();

                    if(scope.rightClickXPos >= getWrapWidth - 200){

                        return false;

                    } else {
                        xPosition = scope.rightClickXPos - 80;
                    }

                    var yPosition = "25"; // keep y consistent for now

                    scope.position.left = xPosition + "px";
                    scope.position.top = yPosition + "px";
                    return true;

                };

                scope.getPosition = function(element) {

                    var xPosition = 0;
                    var yPosition = 0;

                    while (element) {
                        xPosition += (element.offsetLeft - element.scrollLeft + element.clientLeft);
                        yPosition += (element.offsetTop - element.scrollTop + element.clientTop);
                        element = element.offsetParent;
                    }
                    return {
                        x: xPosition,
                        y: yPosition
                    };

                };

                lElement.bind("click", function(event) {
                    var $actionEachBox = angular.element(".actionEachBox");
                    if (lElement.parents(".folderTreeWrapper").hasClass("withoutCheckBox")) {


                        if (!lElement.find(".folderSelector").hasClass("disabledColor")) {
                            if (lElement.hasClass("nonCheckBox")) {
                                lElement.removeClass("nonCheckBox");
                            } else {

                                lElement.addClass("tempClass");
                                scope.anchors = lElement.parents(".withoutCheckBox").find(".folderSelector").not(".disabledColor").parents("a");
                                scope.anchors.removeClass("highlight highlightActive nonCheckBox");

                                for (var anchorIndex = 0; anchorIndex < scope.anchors.length; anchorIndex++) {

                                    if (scope.anchors.eq(anchorIndex).hasClass("tempClass")) {
                                        scope.anchors.eq(anchorIndex).addClass("highlight nonCheckBox");
                                        lElement.removeClass("tempClass");
                                        event.stopPropagation();
                                    }
                                }
                            }
                        }else{
                            return false;
                        }

                        // $scope.anchors.not(".tempClass").removeClass("highlight").find("actionEach").remove();

                    } else {
                        if ($actionEachBox.hasClass("optionsOpen")) {
                            angular.element(".actionEachBox.optionsOpen").parent().removeClass("highlight").find(".actionEach").remove();
                            $actionEachBox.removeClass("optionsOpen flagClass rightClicked");
                        }
                        scope.availableFolders = scope.thisTree.find(".folderSelector").not(".disabledColor");

                        scope.allow = false;

                        if (scope.thisTree.find(event.target).hasClass("highlight") && !scope.thisTree.find(event.target).find(".folderSelector").hasClass("disabledColor")) {
                            scope.allow = true;
                        }

                        if (!scope.thisTree.find(event.target).hasClass("highlight") && !scope.thisTree.find(event.target).parents("a").find(".folderSelector").hasClass("disabledColor")) {
                            scope.allow = true;
                        }


                        if (scope.allow) {

                            if (!scope.thisTree.find(".innerWrapper").find(event.target).length) {

                                if (lElement.find("input").attr("checked")) {

                                    $actionEachBox.removeClass("folderSelected");
                                    lElement.find(".folderSelector").removeClass("selected");
                                    lElement.find("input").attr("checked", false);
                                    scope.thisTree.find("input").eq(0).attr("checked", false).parents("label").removeClass("selected");
                                } else {

                                    $actionEachBox.removeClass("optionsOpen flagClass rightClicked");
                                    lElement.addClass("highlight").find(".folderSelector").addClass("selected");
                                    lElement.find("input").attr("checked", true);

                                    scope.allSelected = 0;
                                    angular.forEach(scope.availableFolders, function(value, index) {
                                        if (index !== 0 && !angular.element(value).hasClass("selected")) {
                                            scope.allSelected++;
                                        }
                                    });

                                    if (!scope.allSelected) {
                                        angular.element(scope.availableFolders[0]).addClass("selected").find("input").attr("checked", true);
                                    }

                                    //scope.setCurrentFolder(lElement);
                                }

                                //scope.folderSelectdCallBack(scope.thisTree.find(".folderSelector.selected"));
                            }
                            //console.log("folder level check box "+lElement.find("input").attr("checked"));

                            return false;
                        } else {
                            event.stopPropagation();
                        }
                    }
                });

                scope.optionsAction = function(event, optionScope) {

                    var actionBoxFolderId = angular.element(".actionEachBox").data('folder-id');
                    
                    if($(event.target).hasClass('disabled')){
                        event.stopPropagation();
                        return false;
                    }

                    if (optionScope.option.id === "exportToCsvInner") {
                        
                        scope.publish('sendExportToCsvAPI', {
                            'selectedFolders': actionBoxFolderId, 
                            'reportFor': 'licenseKeysFromContextMenu'
                        });

                        event.stopPropagation();
                    } else {

                        if (optionScope.option.disabledClass !== "disabled") {

                            scope.required = {
                                operationScope: {},
                                folders: []
                            };

                            scope.completeFolderStack.forEach(function(folder) {
                                if (folder.folderId === actionBoxFolderId) {
                                    scope.required.folders.push(folder);
                                }
                            });

                            scope.required.operationScope = optionScope.option;

                           if(optionScope.option.id == "deleteFolderInner"){

                                 scope.modalInst = ModalService.showModal({
                                                        templateUrl: '/vmf/m/components/folderTree/template/deleteFolder.tpl.html',
                                                        controller: "folderTreeController"
                                                    }).then(function(modal) {
                                                        modal.element.modal({backdrop: 'static'});
                                                         _this.createModal(scope.required, scope.completeFolderStack);
                                                    });
                                                    
                                if(typeof riaLinkmy !="undefined") riaLinkmy("my-licenses : delete-folder");

                            }

                            if(optionScope.option.id == "moveFolderInner"){
                                 
                                 scope.modalInst = ModalService.showModal({
                                                        templateUrl: '/vmf/m/components/folderTree/template/moveFolder.tpl.html',
                                                        controller: "folderTreeController"
                                                    }).then(function(modal) {
                                                        modal.element.modal({backdrop: 'static'});
                                                         _this.createModal(scope.required, scope.completeFolderStack);
                                                         _this.publishGetFolderPath();
                                                    }); 
                                if(typeof riaLinkmy !="undefined") riaLinkmy("my-licenses : move-folder");
                            }

                            if(optionScope.option.id == "createFolderInner"){
                                 
                                 scope.modalInst = ModalService.showModal({
                                                        templateUrl: '/vmf/m/components/folderTree/template/createFolder.tpl.html',
                                                        controller: "folderTreeController"
                                                    }).then(function(modal) {
                                                        modal.element.modal({backdrop: 'static'});
                                                         _this.createModal(scope.required, scope.completeFolderStack);
                                                         _this.publishGetFolderPathCreate();
                                                    }); 
                            }

                            if(optionScope.option.id == "renameFolderInner"){
                                 
                                 scope.modalInst = ModalService.showModal({
                                                        templateUrl: '/vmf/m/components/folderTree/template/renameFolder.tpl.html',
                                                        controller: "folderTreeController"
                                                    }).then(function(modal) {
                                                        modal.element.modal({backdrop: 'static'});
                                                         _this.createModal(scope.required, scope.completeFolderStack);
                                                    }); 
                                if(typeof riaLinkmy !="undefined") riaLinkmy("my-licenses : rename-folder");
                            }

                            if(optionScope.option.id == "inviteNewUserInner"){

                                scope.modalInstance = ModalService.showModal({
                                    templateUrl: '/vmf/m/components/folderTree/template/inviteUser.tpl.html',
                                    controller: "folderTreeController"
                                }).then(function(modal) {
                                    modal.element.modal({backdrop: 'static'});
                                    _this.createModal(scope.required, scope.completeFolderStack);                             
                                });

                            }

                            if(optionScope.option.id == 'shareFolderInner'){
                                scope.modalInstance = ModalService.showModal({
                                    templateUrl: '/vmf/m/components/folderTree/template/shareFolder.tpl.html',
                                    controller: "folderTreeController"
                                }).then(function(modal) {
                                    modal.element.modal({backdrop: 'static'});
                                    _this.createModal(scope.required, scope.completeFolderStack);  
                                    _this.getUsers();                             
                                });
                                if(typeof riaLinkmy !="undefined") riaLinkmy("my-licenses : share-folder");
                            }

                             if(optionScope.option.id == 'requestPermissionInner'){
                                scope.modalInstance = ModalService.showModal({
                                    templateUrl: '/vmf/m/components/folderTree/template/requestPermission.tpl.html',
                                    controller: "folderTreeController"
                                }).then(function(modal) {
                                    modal.element.modal({backdrop: 'static'});
                                    _this.createModal(scope.required, scope.completeFolderStack);  
                                    _this.publishEditFolderPermissions();                          
                                });
                            }

                        } else {
                            return false;
                        }
                    }

                    angular.element(".actionEachBox").removeClass("optionsOpen");

                    event.stopPropagation();

                };

            }
        };
    }
]);

(function() {

  'use strict';

  folderTreeApp.factory('ModalService', ['$document', '$compile', '$controller', '$http', '$rootScope', '$q', '$timeout', '$templateCache',
    function($document, $compile, $controller, $http, $rootScope, $q, $timeout, $templateCache) {

    //  Get the body of the document, we'll add the modal to this.
    var body = $document.find('body');

    function ModalService() {

      var self = this;

      //  Returns a promise which gets the template, either
      //  from the template parameter or via a request to the
      //  template url parameter.
      var getTemplate = function(template, templateUrl) {
        var deferred = $q.defer();
        if(template) {
          deferred.resolve(template);
        } else if(templateUrl) {
          // check to see if the template has already been loaded
          var cachedTemplate = $templateCache.get(templateUrl);
          if(cachedTemplate !== undefined) {
            deferred.resolve(cachedTemplate);
          }
          // if not, let's grab the template for the first time
          else {
            $http({method: 'GET', url: templateUrl, cache: true})
              .then(function(result) {
                // save template into the cache and return the template
                $templateCache.put(templateUrl, result.data);
                deferred.resolve(result.data); 
              });/*
              .catch(function(error) {
                deferred.reject(error);
              });*/
          }
        } else {
          deferred.reject("No template or templateUrl has been specified.");
        }
        return deferred.promise;
      };

      self.showModal = function(options) {

        //  Create a deferred we'll resolve when the modal is ready.
        var deferred = $q.defer();

        //  Validate the input parameters.
        var controllerName = options.controller;
        if(!controllerName) {
          deferred.reject("No controller has been specified.");
          return deferred.promise;
        }

        //  If a 'controllerAs' option has been provided, we change the controller
        //  name to use 'as' syntax. $controller will automatically handle this.
        if(options.controllerAs) {
          controllerName = controllerName + " as " + options.controllerAs;
        }

        //  Get the actual html of the template.
        getTemplate(options.template, options.templateUrl)
          .then(function(template) {

            //  Create a new scope for the modal.
            var modalScope = $rootScope.$new();

            //  Create the inputs object to the controller - this will include
            //  the scope, as well as all inputs provided.
            //  We will also create a deferred that is resolved with a provided
            //  close function. The controller can then call 'close(result)'.
            //  The controller can also provide a delay for closing - this is
            //  helpful if there are closing animations which must finish first.
            var closeDeferred = $q.defer();
            var inputs = {
              $scope: modalScope,
              close: function(result, delay) {
                if(delay === undefined || delay === null) delay = 0;
                $timeout(function () {
                  closeDeferred.resolve(result);
                }, delay);
              }
            };

            //  If we have provided any inputs, pass them to the controller.
            if(options.inputs) {
              for(var inputName in options.inputs) {
                inputs[inputName] = options.inputs[inputName];
              }
            }

            //  Parse the modal HTML into a DOM element (in template form).
            var modalElementTemplate = angular.element(template);

            //  Compile then link the template element, building the actual element.
            //  Set the $element on the inputs so that it can be injected if required.
            var linkFn = $compile(modalElementTemplate);
            var modalElement = linkFn(modalScope);
            inputs.$element = modalElement;

            //  Create the controller, explicitly specifying the scope to use.
            var modalController = $controller(controllerName, inputs);


            //  Finally, append the modal to the dom.
            if (options.appendElement) {
              // append to custom append element
              options.appendElement.append(modalElement);
            } else {
              // append to body when no custom append element is specified
              body.append(modalElement);
            }

            //  We now have a modal object.
            var modal = {
              controller: modalController,
              scope: modalScope,
              element: modalElement,
              close: closeDeferred.promise
            };

            //  When close is resolved, we'll clean up the scope and element.
            modal.close.then(function(result) {
              //  Clean up the scope
              modalScope.$destroy();
              //  Remove the element from the dom.
              modalElement.remove();
            });

            deferred.resolve(modal);

          });

        return deferred.promise;
      };

      self.createModal = function(required,allfolders){
        
      };

    }

    return new ModalService();
  }]);

}());

angular.module('vmfCheckboxGroupMod', [])
.directive('vmfCheckboxGroup', ['$compile', '$timeout', function($compile, $timeout) {
    return {
        restrict: 'EA',
        priority:1,
        replace: true,
        scope: {
            ctitle: '=',
            options: '=',
            name: '=',
            model: '=',
            mandatory: '@',
            customClass: '=',
            type: '@',
            cLabel: '=',
            cDisabled: '=',
            cFoldertype: '=',
            clickCallback: '&',
            changeCallback: '&',
            append:'@'
        },
        link: function(scope, elem, attrs) {
            
            scope.invoke=function(method,evt) {
                scope.$emit('invoke',{method:method,evt:evt});
            };
            
            var template;
            if(scope.type === '1') {
                if(scope.mandatory === 'true') {
                    template = '<span class="mandatory">*</span>';
                }
                else {
                    template = '';
                }
                if(!scope.cLabel) {                    
                    template += '<label class="custom-checkbox"><span class="customCheckBox icn" ng-disabled="cDisabled"><input type="checkbox" ng-model="model" ng-click="clickCallback({$event:$event})" ng-change="changeCallback({$event:$event})" ng-disabled="cDisabled" /></span></label>';       
                }
                else {
                    template += '<label class="custom-checkbox"><span class="customCheckBox icn" ng-disabled="cDisabled"><input type="checkbox" ng-model="model" ng-click="clickCallback({$event:$event})" ng-change="changeCallback({$event:$event})" ng-disabled="cDisabled" /></span>' + scope.cLabel + '<span class="badge" ng-if="cFoldertype == \'ASP\' || cFoldertype == \'VCE\' || cFoldertype == \'CPL\'" badgeType="{{cFoldertype}}">{{cFoldertype}}</span></label>';    
                }
                
                var repl = $compile(template)(scope);
                if(scope.append === "true")
                    elem.append(repl);
                else
                elem.replaceWith(repl);
                
                scope.$watch('model', function(n, o) {
                    if(n) {
                        $timeout(function() { 
                            repl.addClass('selected');
                        });    
                    }
                    else {
                        $timeout(function() {
                            repl.removeClass('selected');
                        });    
                    }
                });


                scope.$watch('cDisabled', function(n, o) {
                    if(n) {
                            $timeout(function() {
                                repl.addClass('disabledColor'); 
                                repl.find('span.customCheckBox').addClass('disabled'); 
                                
                            });        
                        }
                        else {
                            $timeout(function() {
                                repl.removeClass('disabledColor'); 
                                repl.find('span.customCheckBox').removeClass('disabled'); 
                                
                            });           
                        }
                });
            }
            else if(scope.type === '2') {
                if(scope.mandatory === 'true') {
                    if(scope.ctitle) {
                        template = '<div class=" formSection clearfix">  <div class="labelHeader col-md-3"><span class="mandatory">*</span> '
                                    + scope.ctitle 
                                    + '</div><div class="col-md-9"><fieldset>';
                    }   
                    else {
                        template = '<div class=" formSection clearfix no-title">  <div class="mandatoryCB"><span class="mandatory">*</span></div><div class="col-md-9"><fieldset>';
                        //console.log('no title');
                    }         
                }
                else {
                    if(scope.ctitle) {
                        template = '<div class=" formSection clearfix">  <div class="labelHeader col-md-3">'
                                    + scope.ctitle 
                                    + '</div><div class="col-md-8"><fieldset>';
                    }                
                    else {
                        template = '<div class=" formSection clearfix no-title"> <div class="col-md-12"><fieldset>';
                        
                    }         

                }                

                angular.forEach(scope.options, function(item, index) {
                      
                    template += '<label class="custom-checkbox"><span class="customCheckBox icn" ng-disabled="options['+ index +'].disabled"><input type="checkbox" ng-model="options[' + index + '].checked" ng-disabled="options['+ index +'].disabled" name="'
                                + scope.name 
                                + '" value="'
                                + item.value
                                + '"></span>'
                                + item.text 
                                + '</label>';                
                    
                });

                template += '</fieldset></div> </div>';

                elem.append($compile(template)(scope));

                if(scope.customClass){
                    angular.forEach(scope.customClass, function(item) {
                        elem.find(item.selector).addClass(item.cusclass);
                        
                        
                    });
                }

                $timeout(function(){
                    elem.find('.badge').each(function(){
                            var getType = $(this).attr('badgeType');
                            $(this).attr('title',globalVariables['staticTextfor'+getType]);
                        });
                },100);

                scope.$watch('options', function(n, o) {
                    // console.log(n);console.log(o);
                    angular.forEach(n, function(option, index) {
                        if(option.checked) {
                            $timeout(function() {
                                angular.element(elem.find('label.custom-checkbox')[index]).addClass('selected'); 
                            });     
                        }
                        else {
                            $timeout(function() {
                                angular.element(elem.find('label.custom-checkbox')[index]).removeClass('selected');
                            }); 
                            
                        }

                        if(option.disabled) {
                            $timeout(function() {
                                angular.element(elem.find('label.custom-checkbox')[index]).addClass('disabledColor'); 
                                angular.element(elem.find('span.customCheckBox')[index]).addClass('disabled'); 
                                
                            });        
                        }
                        else {
                            $timeout(function() {
                                angular.element(elem.find('label.custom-checkbox')[index]).removeClass('disabledColor'); 
                                angular.element(elem.find('span.customCheckBox')[index]).removeClass('disabled'); 
                                
                            });           
                        }
                    });
                }, true);
            }

        }

    };
}]);
/*!

Split Pane v0.4.0

Copyright (c) 2014 Simon HagstrÃ¶m

Released under the MIT license
https://raw.github.com/shagstrom/split-pane/master/LICENSE

*/
(function($) {
	
	$.fn.splitPane = function() {
		var $splitPanes = this;
		$splitPanes.each(setMinHeightAndMinWidth);
		$splitPanes.append('<div class="split-pane-resize-shim">');
		
		//$splitPanes.children('.split-pane-divider').bind('dblclick', fullOpen);
		//$splitPanes.children('.split-pane-divider').bind('mousedown', mousedownHandler);
		//$splitPanes.children('.split-pane-divider').bind('dblclick', fullOpen);

		/*$splitPanes.children('.split-pane-divider').on('click', function(event){
			clicks++;
			var _self = this, e = event;
	      	if (clicks == 1) {
		        setTimeout(function(){
			          if(clicks == 1) {
			            mousedownHandler(e, _self);
			          } else {
			            fullOpen(_self);
			          }
			          clicks = 0;
		        }, 300);
		    }
		});*/

		setTimeout(function() {
			// Doing this later because of an issue with Chrome (v23.0.1271.64) returning split-pane width = 0
			// and triggering multiple resize events when page is being opened from an <a target="_blank"> .
			$splitPanes.each(function() {
				$(this).bind('_splitpaneparentresize', createParentresizeHandler($(this)));
			});
			$(window).trigger('resize');
		}, 100);
	};

	var SPLITPANERESIZE_HANDLER = '_splitpaneparentresizeHandler';

	/**
	 * A special event that will "capture" a resize event from the parent split-pane or window.
	 * The event will NOT propagate to grandchildren.
	 */
	jQuery.event.special._splitpaneparentresize = {
		setup: function(data, namespaces) {
			var element = this,
				parent = $(this).parent().closest('.split-pane')[0] || window;
			$(this).data(SPLITPANERESIZE_HANDLER, function(event) {
				var target = event.target === document ? window : event.target;
				if (target === parent) {
					event.type = "_splitpaneparentresize";
					jQuery.event.dispatch.apply(element, arguments);
				} else {
					event.stopPropagation();
				}
			});
			$(parent).bind('resize', $(this).data(SPLITPANERESIZE_HANDLER));
		},
		teardown: function(namespaces) {
			var parent = $(this).parent().closest('.split-pane')[0] || window;
			$(parent).unbind('resize', $(this).data(SPLITPANERESIZE_HANDLER));
			$(this).removeData(SPLITPANERESIZE_HANDLER);
		}
	};

	function setMinHeightAndMinWidth() {
		var $splitPane = $(this),
			$firstComponent = $splitPane.children('.split-pane-component:first'),
			$divider = $splitPane.children('.split-pane-divider'),
			$lastComponent = $splitPane.children('.split-pane-component:last');
		if ($splitPane.is('.fixed-top, .fixed-bottom, .horizontal-percent')) {
			$splitPane.css('min-height', (minHeight($firstComponent) + minHeight($lastComponent) + $divider.height()) + 'px');
		} else {
			$splitPane.css('min-width', (minWidth($firstComponent) + minWidth($lastComponent) + $divider.width()) + 'px');
		}
	}

	/*function fullOpen(elem) {
		var $firstComponent = $(elem).parent().children('.split-pane-component:first'),
		    $divider = $(elem).parent().children('.split-pane-divider'),
		    $lastComponent = $(elem).parent().children('.split-pane-component:last');

		    if($firstComponent.css('right') === '0px') {
			    $firstComponent.css('right', 80 + '%');
			    $divider.css('right', 80 + '%');
			    $lastComponent.css('width', 80 + '%');
		    }
		    else {
			    $firstComponent.css('right', 0 + '%');
			    $divider.css('right', 0 + '%');
			    $lastComponent.css('width', 0 + '%');
		    }    
	}*/

	/*function mousedownHandler(event) {
		event.preventDefault();
		var isTouchEvent = event.type.match(/^touch/),
			moveEvent = isTouchEvent ? 'touchmove' : 'mousemove',
			endEvent = isTouchEvent? 'touchend' : 'mouseup',
			$divider = $(this),
			$splitPane = $divider.parent(),
			$resizeShim = $divider.siblings('.split-pane-resize-shim');
		$resizeShim.show();
		$divider.addClass('dragged');
		if (isTouchEvent) {
			$divider.addClass('touch');
		}
		$(document).on(moveEvent, createMousemove($splitPane, pageXof(event), pageYof(event)));
		$(document).one(endEvent, function(event) {
			$(document).unbind(moveEvent);
			$divider.removeClass('dragged touch');
			$resizeShim.hide();
		});
	}*/

	function createParentresizeHandler($splitPane) {
		var splitPane = $splitPane[0],
			firstComponent = $splitPane.children('.split-pane-component:first')[0],
			divider = $splitPane.children('.split-pane-divider')[0],
			lastComponent = $splitPane.children('.split-pane-component:last')[0];
		if ($splitPane.is('.fixed-top')) {
			var lastComponentMinHeight = minHeight(lastComponent);
			return function(event) {
				var maxfirstComponentHeight = splitPane.offsetHeight - lastComponentMinHeight - divider.offsetHeight;
				if (firstComponent.offsetHeight > maxfirstComponentHeight) {
					setTop(firstComponent, divider, lastComponent, maxfirstComponentHeight + 'px');
				}
				$splitPane.resize();
			};
		} else if ($splitPane.is('.fixed-bottom')) {
			var firstComponentMinHeight = minHeight(firstComponent);
			return function(event) {
				var maxLastComponentHeight = splitPane.offsetHeight - firstComponentMinHeight - divider.offsetHeight;
				if (lastComponent.offsetHeight > maxLastComponentHeight) {
					setBottom(firstComponent, divider, lastComponent, maxLastComponentHeight + 'px')
				}
				$splitPane.resize();
			};
		} else if ($splitPane.is('.horizontal-percent')) {
			var lastComponentMinHeight = minHeight(lastComponent),
				firstComponentMinHeight = minHeight(firstComponent);
			return function(event) {
				var maxLastComponentHeight = splitPane.offsetHeight - firstComponentMinHeight - divider.offsetHeight;
				if (lastComponent.offsetHeight > maxLastComponentHeight) {
					setBottom(firstComponent, divider, lastComponent, (maxLastComponentHeight / splitPane.offsetHeight * 100) + '%');
				} else {
					if (splitPane.offsetHeight - firstComponent.offsetHeight - divider.offsetHeight < lastComponentMinHeight) {
						setBottom(firstComponent, divider, lastComponent, (lastComponentMinHeight / splitPane.offsetHeight * 100) + '%');
					}
				}
				$splitPane.resize();
			};
		} else if ($splitPane.is('.fixed-left')) {
			var lastComponentMinWidth = minWidth(lastComponent);
			return function(event) {
				var maxFirstComponentWidth = splitPane.offsetWidth - lastComponentMinWidth - divider.offsetWidth;
				if (firstComponent.offsetWidth > maxFirstComponentWidth) {
					setLeft(firstComponent, divider, lastComponent, maxFirstComponentWidth + 'px');
				}
				$splitPane.resize();
			};
		} else if ($splitPane.is('.fixed-right')) {
			var firstComponentMinWidth = minWidth(firstComponent);
			return function(event) {
				var maxLastComponentWidth = splitPane.offsetWidth - firstComponentMinWidth - divider.offsetWidth;
				if (lastComponent.offsetWidth > maxLastComponentWidth) {
					setRight(firstComponent, divider, lastComponent, maxLastComponentWidth + 'px');
				}
				$splitPane.resize();
			};
		} else if ($splitPane.is('.vertical-percent')) {
			var lastComponentMinWidth = minWidth(lastComponent),
				firstComponentMinWidth = minWidth(firstComponent);
			return function(event) {
				var maxLastComponentWidth = splitPane.offsetWidth - firstComponentMinWidth - divider.offsetWidth;
				if (lastComponent.offsetWidth > maxLastComponentWidth) {
					setRight(firstComponent, divider, lastComponent, (maxLastComponentWidth / splitPane.offsetWidth * 100) + '%');
				} else {
					if (splitPane.offsetWidth - firstComponent.offsetWidth - divider.offsetWidth < lastComponentMinWidth) {
						setRight(firstComponent, divider, lastComponent, (lastComponentMinWidth / splitPane.offsetWidth * 100) + '%');
					}
				}
				$splitPane.resize();
			};
		}
	}

	/*function createMousemove($splitPane, pageX, pageY) {
		var splitPane = $splitPane[0],
			firstComponent = $splitPane.children('.split-pane-component:first')[0],
			divider = $splitPane.children('.split-pane-divider')[0],
			lastComponent = $splitPane.children('.split-pane-component:last')[0];
		if ($splitPane.is('.fixed-top')) {
			var firstComponentMinHeight =  minHeight(firstComponent),
				maxFirstComponentHeight = splitPane.offsetHeight - minHeight(lastComponent) - divider.offsetHeight,
				topOffset = divider.offsetTop - pageY;
			return function(event) {
				event.preventDefault();
				var top = Math.min(Math.max(firstComponentMinHeight, topOffset + pageYof(event)), maxFirstComponentHeight);
				setTop(firstComponent, divider, lastComponent, top + 'px');
				$splitPane.resize();
			};
		} else if ($splitPane.is('.fixed-bottom')) {
			var lastComponentMinHeight = minHeight(lastComponent),
				maxLastComponentHeight = splitPane.offsetHeight - minHeight(firstComponent) - divider.offsetHeight,
				bottomOffset = lastComponent.offsetHeight + pageY;
			return function(event) {
				event.preventDefault();
				var bottom = Math.min(Math.max(lastComponentMinHeight, bottomOffset - pageYof(event)), maxLastComponentHeight);
				setBottom(firstComponent, divider, lastComponent, bottom + 'px');
				$splitPane.resize();
			};
		} else if ($splitPane.is('.horizontal-percent')) {
			var splitPaneHeight = splitPane.offsetHeight,
				lastComponentMinHeight = minHeight(lastComponent),
				maxLastComponentHeight = splitPaneHeight - minHeight(firstComponent) - divider.offsetHeight,
				bottomOffset = lastComponent.offsetHeight + pageY;
			return function(event) {
				event.preventDefault();
				var bottom = Math.min(Math.max(lastComponentMinHeight, bottomOffset - pageYof(event)), maxLastComponentHeight);
				setBottom(firstComponent, divider, lastComponent, (bottom / splitPaneHeight * 100) + '%');
				$splitPane.resize();
			};
		} else if ($splitPane.is('.fixed-left')) {
			var firstComponentMinWidth = minWidth(firstComponent),
				maxFirstComponentWidth = splitPane.offsetWidth - minWidth(lastComponent) - divider.offsetWidth,
				leftOffset = divider.offsetLeft - pageX;
			return function(event) {
				event.preventDefault();
				var left = Math.min(Math.max(firstComponentMinWidth, leftOffset + pageXof(event)), maxFirstComponentWidth);
				setLeft(firstComponent, divider, lastComponent, left + 'px')
				$splitPane.resize();
			};
		} else if ($splitPane.is('.fixed-right')) {
			var lastComponentMinWidth = minWidth(lastComponent),
				maxLastComponentWidth = splitPane.offsetWidth - minWidth(firstComponent) - divider.offsetWidth,
				rightOffset = lastComponent.offsetWidth + pageX;
			return function(event) {
				event.preventDefault();
				var right = Math.min(Math.max(lastComponentMinWidth, rightOffset - pageXof(event)), maxLastComponentWidth);
				setRight(firstComponent, divider, lastComponent, right + 'px');
				$splitPane.resize();
			};
		} else if ($splitPane.is('.vertical-percent')) {
			var splitPaneWidth = splitPane.offsetWidth,
				lastComponentMinWidth = minWidth(lastComponent),
				maxLastComponentWidth = splitPaneWidth - minWidth(firstComponent) - divider.offsetWidth,
				rightOffset = lastComponent.offsetWidth + pageX;
			return function(event) {
				event.preventDefault();
				var right = Math.min(Math.max(lastComponentMinWidth, rightOffset - pageXof(event)), maxLastComponentWidth);
				setRight(firstComponent, divider, lastComponent, (right / splitPaneWidth * 100) + '%');
				$splitPane.resize();
			};
		}
	}*/

	function pageXof(event) {
		return event.pageX || event.originalEvent.pageX;
	}

	function pageYof(event) {
		return event.pageY || event.originalEvent.pageY;
	}

	function minHeight(element) {
		return parseInt($(element).css('min-height')) || 0;
	}

	function minWidth(element) {
		return parseInt($(element).css('min-width')) || 0;
	}

	function setTop(firstComponent, divider, lastComponent, top) {
		firstComponent.style.height = top;
		divider.style.top = top;
		lastComponent.style.top = top;
	}

	function setBottom(firstComponent, divider, lastComponent, bottom) {
		firstComponent.style.bottom = bottom;
		divider.style.bottom = bottom;
		lastComponent.style.height = bottom;
	}

	function setLeft(firstComponent, divider, lastComponent, left) {
		firstComponent.style.width = left;
		divider.style.left = left;
		lastComponent.style.left = left;
	}

	function setRight(firstComponent, divider, lastComponent, right) {
		firstComponent.style.right = right;
		divider.style.right = right;
		lastComponent.style.width = right;
	}

})(jQuery);


angular.module('vmfSplitContainerMod', [])
	.directive('vmfSplitContainer', function() {
		return {
			restrict: 'EA',
			replace: true,
			transclude: true,
			controller: function ($scope) {
				$scope.splitContainerTitle = "Split Container";
				$scope.components = [];
				$scope.values = [];
				this.addComponent = function(attributes) {
					$scope.components.push(attributes);
				};
				this.addDivider = function(attributes) {
					$scope.divider = attributes;
				};
			},
			link: function($scope, element, attrs) {
				var $firstComponent = element.children('.split-pane-component:first'),
					$divider = element.children('.split-pane-divider'),
					$lastComponent = element.children('.split-pane-component:last');
					for(var i=0; i<$scope.components.length; i++) {				
						if ($scope.components[i].width && $scope.components[i].width.match(/%$/)) {
							element.addClass('vertical-percent');
							var rightPercent = (100 - parseFloat($scope.components[i].width.match(/(\d+)%$/)[1])) + "%" ;
							$firstComponent.css({ right: rightPercent, marginRight: $scope.divider.width });
							$divider.css({ right: rightPercent, width: $scope.divider.width });
							$lastComponent.css({ width: rightPercent });
						} else if ($scope.components[i].width) {
							element.addClass('fixed-left');
							$firstComponent.css({ width: $scope.components[i].width });
							$divider.css({ left: $scope.components[i].width, width: $scope.divider.width });
							$lastComponent.css({ left: $scope.components[i].width, marginLeft: $scope.divider.width });				
						} else if ($scope.components[i].height && $scope.components[i].height.match(/%$/)) {
							element.addClass('horizontal-percent');
							var bottomPercent = (100 - parseFloat($scope.components[i].height.match(/(\d+)%$/)[1])) + "%" ;
							$firstComponent.css({ bottom: bottomPercent, marginBottom: $scope.divider.height });
							$divider.css({ bottom: bottomPercent, height: $scope.divider.height });
							$lastComponent.css({ height: bottomPercent });
						} else if ($scope.components[i].height) {
							element.addClass('fixed-top');
							$firstComponent.css({ height: $scope.components[i].height });
							$divider.css({ top: $scope.components[i].height, height: $scope.divider.height });
							$lastComponent.css({ top: $scope.components[i].height, marginLeft: $scope.divider.height });
						}
					}
				element.splitPane();
			},
			template: '<div class="vmf-split-container" ng-transclude></div>'
		};
	})

	.directive('vmfSplitPaneComponent', function($compile) {
		return {
			restrict: 'EA',
			replace: true,
			transclude: true,
			require: '^vmfSplitContainer',
			scope: {
				panewidth: '@',
				paneheight: '@',
				maxwidth: '@',
				minwidth: '@'
			},
			link: function($scope, element, attrs, paneCtrl) {
				if($scope.panewidth) {
					paneCtrl.width = $scope.panewidth;
				}
				if($scope.paneheight) {
					paneCtrl.height = $scope.paneheight;
				}
				if($scope.maxwidth) {
					paneCtrl.maxwidth = $scope.maxwidth;
				}
				if($scope.minwidth) {
					paneCtrl.minwidth = $scope.minwidth;
				}
				paneCtrl.addComponent({ width: $scope.panewidth, height: $scope.paneheight });
			},
			template: '<div class="split-pane-component" ng-transclude></div>'
		};
	})

	.directive('vmfSplitPaneDivider', function() {
		return {
			restrict: 'EA',
			replace: true,
			transclude: true,
			require: '^vmfSplitContainer',
			scope: {
				panewidth: '@',
				paneheight: '@',
				clicks: '@',
				close: '@'
			},
			controller: function ($scope) {
				$scope.mousedownHandler = function (event, element, minwidth, maxwidth, panewidth, paneheight) {
					var isTouchEvent = event.type.match(/^touch/),
						moveEvent = isTouchEvent ? 'touchmove' : 'mousemove',
						endEvent = isTouchEvent? 'touchend' : 'mouseup',
						$divider = element,
						$splitPane = $divider.parent(),
						$resizeShim = $divider.siblings('.split-pane-resize-shim');
					if(navigator.appVersion.indexOf("MSIE 7.") !== -1 || navigator.appVersion.indexOf("MSIE 8.") !== -1) {
						setTimeout(function(){
							$resizeShim.show();
						}, 500);
					} else {
						$resizeShim.show();
					}
					$divider.addClass('dragged');
					if (isTouchEvent) {
						$divider.addClass('touch');
					}
					
					var $clone = $divider.clone();
					$divider.after($clone);
						
					$(document).on(moveEvent, $scope.createMousemove($splitPane, $scope.pageXof(event), $scope.pageYof(event), minwidth, maxwidth, panewidth, paneheight));
					
					$(document).one(endEvent, function(event) {
						$(document).unbind(moveEvent);
						$clone.remove();
						$divider.removeClass('dragged touch');
						if(navigator.appVersion.indexOf("MSIE 7.") !== -1 || navigator.appVersion.indexOf("MSIE 8.") !== -1) {
							setTimeout(function(){
								$resizeShim.hide();
							},0);
						} else {
							$resizeShim.hide();
						}
					});
				};
				$scope.createMousemove = function($splitPane, pageX, pageY, minwidth, maxwidth, panewidth, paneheight) {
					var splitPane = $splitPane[0],
						firstComponent = $splitPane.children('.split-pane-component:first')[0],
						divider = $splitPane.children('.split-pane-divider')[0],
						divider2 = $splitPane.children('.split-pane-divider')[1],
						lastComponent = $splitPane.children('.split-pane-component:last')[0],
						lastComponentMinHeight,
						maxLastComponentHeight,
						bottomOffset,
						lastComponentMinWidth,
						maxLastComponentWidth,
						rightOffset;
						$(divider2).remove();
					if ($splitPane.is('.fixed-top')) {
						var firstComponentMinHeight =  $scope.minHeight(firstComponent),
							maxFirstComponentHeight = splitPane.offsetHeight - $scope.minHeight(lastComponent) - divider.offsetHeight,
							topOffset = divider.offsetTop - pageY;
						return function(event) {
							event.preventDefault();
							var top = Math.min(Math.max(firstComponentMinHeight, topOffset + $scope.pageYof(event)), maxFirstComponentHeight);
							$scope.setTop(firstComponent, divider, lastComponent, top + 'px');
							$splitPane.resize();
						};
					} else if ($splitPane.is('.fixed-bottom')) {
						lastComponentMinHeight = $scope.minHeight(lastComponent),
						maxLastComponentHeight = splitPane.offsetHeight - $scope.minHeight(firstComponent) - divider.offsetHeight,
						bottomOffset = lastComponent.offsetHeight + pageY;
						return function(event) {
							event.preventDefault();
							var bottom = Math.min(Math.max(lastComponentMinHeight, bottomOffset - $scope.pageYof(event)), maxLastComponentHeight);
							$scope.setBottom(firstComponent, divider, lastComponent, bottom + 'px');
							$splitPane.resize();
						};
					} else if ($splitPane.is('.horizontal-percent')) {
						var splitPaneHeight;
						if(splitPane.offsetHeight === 0) {
							splitPaneHeight = $splitPane[0].scrollHeight;
						} else {
							splitPaneHeight = $splitPane[0].offsetHeight;
						}					
						lastComponentMinHeight = splitPaneHeight - (splitPaneHeight*(parseInt(maxwidth)/100));//$scope.minHeight(lastComponent),
						maxLastComponentHeight = splitPaneHeight - $scope.minHeight(firstComponent) - divider.offsetHeight;
						bottomOffset = lastComponent.offsetHeight + pageY;
						return function(event) {
							event.preventDefault();
							$(lastComponent).css('display', 'block');
							var bottom = Math.min(Math.max(lastComponentMinHeight, bottomOffset - $scope.pageYof(event)), maxLastComponentHeight);
							if((bottom / splitPaneHeight * 100) < (100-minwidth)) {
								$scope.setBottom(firstComponent, divider, lastComponent, (bottom / splitPaneHeight * 100) + '%');
								$(document).one('mouseup', function () {
									$scope.setHorizontalDivider(divider, (bottom / splitPaneHeight * 100) + '%');
									//$(divider2).remove();
								});		
								$splitPane.resize();
							}
						};
					} else if ($splitPane.is('.fixed-left')) {
						var firstComponentMinWidth = $scope.minWidth(firstComponent),
							maxFirstComponentWidth = splitPane.offsetWidth - $scope.minWidth(lastComponent) - divider.offsetWidth,
							leftOffset = divider.offsetLeft - pageX;
						return function(event) {
							event.preventDefault();
							var left = Math.min(Math.max(firstComponentMinWidth, leftOffset + $scope.pageXof(event)), maxFirstComponentWidth);
							$scope.setLeft(firstComponent, divider, lastComponent, left + 'px');
							$splitPane.resize();
						};
					} else if ($splitPane.is('.fixed-right')) {
						lastComponentMinWidth = $scope.minWidth(lastComponent);
						maxLastComponentWidth = splitPane.offsetWidth - $scope.minWidth(firstComponent) - divider.offsetWidth;
						rightOffset = lastComponent.offsetWidth + pageX;
						return function(event) {
							event.preventDefault();
							var right = Math.min(Math.max(lastComponentMinWidth, rightOffset - $scope.pageXof(event)), maxLastComponentWidth);
							$scope.setRight(firstComponent, divider, lastComponent, right + 'px');
							$splitPane.resize();
						};
					} else if ($splitPane.is('.vertical-percent')) {
						var splitPaneWidth;
						if(splitPane.offsetWidth === 0) {
							splitPaneWidth = $splitPane[0].scrollWidth;
						} else {
							splitPaneWidth = $splitPane[0].offsetWidth;
						}
						lastComponentMinWidth = splitPaneWidth - (splitPaneWidth*(parseInt(maxwidth)/100)); //$scope.minWidth(lastComponent),
						maxLastComponentWidth = splitPaneWidth - $scope.minWidth(firstComponent) - divider.offsetWidth;
						rightOffset = lastComponent.offsetWidth + pageX;
						var	leftContainerWidth = splitPane.offsetWidth*(panewidth/100),
							leftContainerWidthMin = leftContainerWidth*(30/100),
							minDraggableWidth = (leftContainerWidthMin + 10)/(splitPane.offsetWidth)*100; // 10 is the margin for the component
						return function(event) {
							event.preventDefault();
							var right = Math.min(Math.max(lastComponentMinWidth, rightOffset - $scope.pageXof(event)), maxLastComponentWidth);
							if((right / splitPaneWidth * 100) < (100-minDraggableWidth)){
								$scope.setRight(firstComponent, divider, lastComponent, (right / splitPaneWidth * 100) + '%');
								$(document).one('mouseup', function () {
									$scope.setVerticalDivider(divider, (right / splitPaneWidth * 100) + '%');
									//$(divider2).remove();
								});
								$splitPane.resize();
							}	
						};
					}
				};

				$scope.pageXof = function(event) {
					return event.pageX || event.originalEvent.pageX;
				};

				$scope.pageYof = function(event) {
					return event.pageY || event.originalEvent.pageY;
				};

				$scope.minHeight = function(element) {
					return parseInt($(element).css('min-height')) || 0;
				};

				$scope.minWidth = function(element) {
					return parseInt($(element).css('min-width')) || 0;
				};

				$scope.setTop = function(firstComponent, divider, lastComponent, top) {
					firstComponent.style.height = top;
					divider.style.top = top;
					lastComponent.style.top = top;
				};

				$scope.setBottom = function(firstComponent, divider, lastComponent, bottom) {
					firstComponent.style.bottom = bottom;
					divider.style.bottom = bottom;
					lastComponent.style.height = bottom;
				};

				$scope.setLeft = function(firstComponent, divider, lastComponent, left) {
					firstComponent.style.width = left;
					divider.style.left = left;
					lastComponent.style.left = left;
				};

				$scope.setRight = function(firstComponent, divider, lastComponent, right) {
					firstComponent.style.right = right;
					divider.style.right = right;
					lastComponent.style.width = right;
				};
				
				$scope.setVerticalDivider = function(divider, right) {
					divider.style.right = right;
				};
				
				
				$scope.setHorizontalDivider = function(divider, bottom) {
					divider.style.bottom = bottom;
				};
			
			},
			link: function($scope, element, attrs, paneCtrl) {
				var minwidth;
				paneCtrl.addDivider({ width: $scope.panewidth, height: $scope.paneheight });
				if(parseInt(paneCtrl.minwidth)) {
					minwidth = paneCtrl.minwidth;
				} else {
					minwidth = paneCtrl.width;
				}
				$scope.doubleClickResizePane = function(element) {
					var $firstComponent = element.parent().children('.split-pane-component:first'),
					    $divider = element,
					    $lastComponent = element.parent().children('.split-pane-component:last'),
					    $remWidth = (100 - parseInt(paneCtrl.width)),
					    $remHeight = (100 - parseInt(paneCtrl.height));
					    $remWidth = $remWidth +'%';
					    $remHeight = $remHeight + '%';

					    if($scope.close === 'right') {
					    	if($firstComponent.prop('style').right === '0%') {
							    $firstComponent.css('right', (100 - parseInt(paneCtrl.width)) + '%');
							    $divider.css('right', (100 - parseInt(paneCtrl.width)) + '%');
							    $lastComponent.css('width', (100 - parseInt(paneCtrl.width)) + '%');
						    }
						    else {
							    $firstComponent.css('right', 0 + '%');
							    $divider.css('right', 0 + '%');
							    $lastComponent.css('width', 0 + '%');
						    }
					    } else if($scope.close === 'left') {
					    	if($firstComponent.prop('style').right < '99%') {
							    $firstComponent.css('right', 99 + '%');
							    $divider.css('right', 99 + '%');
							    $lastComponent.css('width', 99 + '%');
						    }
						    else {
							    $firstComponent.css('right', (100 - parseInt(paneCtrl.width)) + '%');
							    $divider.css('right', (100 - parseInt(paneCtrl.width)) + '%');
							    $lastComponent.css('width', (100 - parseInt(paneCtrl.width)) + '%');
						    }
					    } else if($scope.close === 'bottom') {
					    	if($firstComponent.prop('style').bottom === '0%') {
					    		$firstComponent.css('bottom', (100 - parseInt(paneCtrl.height)) + '%');
					    		$divider.css('bottom', (100 - parseInt(paneCtrl.height)) + '%');
								$lastComponent.css('display', 'block');
					    		$lastComponent.css('height', (100 - parseInt(paneCtrl.height)) + '%');
					    	} else {
					    		$firstComponent.css('bottom', 0 + '%');
					    		$divider.css('bottom', 0 + '%');
								//$lastComponent.css('height', 0 + '%');
					    		$lastComponent.css('display', 'none');
					    	}
					    } else if($scope.close === 'top') {
					    	if($firstComponent.prop('style').bottom < '98%') {
					    		$firstComponent.css('bottom', 98 + '%');
							    $divider.css('bottom', 98 + '%');
							    $lastComponent.css('height', 98 + '%');
					    	} else {
					    		$firstComponent.css('bottom', (100 - parseInt(paneCtrl.height)) + '%');
							    $divider.css('bottom', (100 - parseInt(paneCtrl.height)) + '%');
							    $lastComponent.css('height', (100 - parseInt(paneCtrl.height)) + '%');
					    	}
					    }				
				}	
			if(navigator.appVersion.indexOf("MSIE 7.") !== -1 || navigator.appVersion.indexOf("MSIE 8.") !== -1) {
				element.on('mousedown', function (event) {
					var _self = element, e = event;
					$scope.mousedownHandler(e, _self, parseInt(minwidth), parseInt(paneCtrl.maxwidth), parseInt(paneCtrl.width), parseInt(paneCtrl.height));
				});
				element.on('dblclick', function (event) {
					$scope.doubleClickResizePane(element);
				});
			}
			else {
				element.on('mousedown', function (event){
					$scope.clicks++;
					var _self = element, e = event;
			      	if ($scope.clicks === 1) {
			      		event.preventDefault();
				        setTimeout(function(){
					          if($scope.clicks === 1) {
					          	$scope.mousedownHandler(e, _self, parseInt(minwidth), parseInt(paneCtrl.maxwidth), parseInt(paneCtrl.width), parseInt(paneCtrl.height));
					          } else {
					          	$scope.doubleClickResizePane(_self);				          	
					          }
					          $scope.clicks = 0;
				        },0);
				    }				
				});
			}
			},
			template: '<div class="split-pane-divider"><div class="threedots" ng-transclude></div></div>'
		};
	});
angular.module('vmfRadioGroupMod', [])
.directive('vmfRadioGroup', ['$compile', '$timeout', function($compile, $timeout) {
    return {
        restrict: 'EA',
        priority:1,
        replace: true,
        scope: {
            rtitle: '=',
            options: '=',
            name: '=',
            model: '=',
            mandatory: '@',
            customClass:'=',
            titleColMod:'@',
            type: '@',
            rLabel: '=',
            rChecked: '=',
            rDisabled: '=',
            rValue: '=',
            clickCallback: '&'
        },
        link: function(scope, elem, attrs) {
            var template;
            
            if(scope.type === "1") {
                if(scope.mandatory === 'true') {
                    if(typeof scope.titleColMod !== "undefined")
                        template = '<div class="formSection clearfix">  <div class="labelHeader {{titleColMod}}"><span class="mandatory">* </span> ';
                    else
                        template = '<div class="formSection clearfix">  <div class="labelHeader col-md-2"><span class="mandatory">* </span> ';
                                
                    if(scope.rtitle) {
                        template += scope.rtitle; 
                    }
                                
                    template += '</div><div class="col-md-8 radioContainer"><fieldset>';
                }
                else {
                    template = '<div class="formSection clearfix">  <div class="labelHeader col-md-2">';
                    if(scope.rtitle) {
                        template += scope.rtitle; 
                    }
                                
                    template += '</div><div class="col-md-8 radioContainer"><fieldset>';
                }                

                angular.forEach(scope.options, function(item, index) {
                    
                    template += '<label class="custom-radio" ng-click="optionClicked(\'' + item.value + '\', ' + index + ')"><span class="customRadioBox icn" ng-disabled="options['+ index +'].disabled"><input type="radio" ng-model="model" vmf-radio-value="'+ item.value +'" ng-disabled="options['+ index +'].disabled" name="'
                        + scope.name 
                        + '" value="'
                        + item.value
                        + '"></span>'
                        + item.text 
                        + '</label>';    
                      
                });

                template += '</fieldset></div> </div>';
                
                elem.append(template);

                if(scope.customClass){
                    angular.forEach(scope.customClass, function(item) {
                        elem.find(item.selector).addClass(item.cusclass);
                        
                        
                    });
                }


                $compile(elem.contents())(scope);

                /*
                * label click for IE7
                */

                scope.optionClicked = function(value, index) {
                   
                    if(!scope.options[index].disabled && scope.model !== value) {
                        scope.model = value;
                    }
                    
                };
                
                scope.$watch('model', function(n, o) {
                    if(n === null) {
                        $timeout(function() {
                            elem.find('label.custom-radio').removeClass('selected');
                            elem.find('span.customRadioBox').removeClass('selected'); 
                            angular.forEach(scope.options, function(item) {
                                item.checked = false;
                            });
                        });    
                    }
                    else {
                        
                        angular.forEach(scope.options, function(item) {
                            item.checked = false;
                        });
                        
                        angular.forEach(scope.options, function(item, index) {
                           
                            if(item.value === scope.model) {
                                item.checked = true;
                                $timeout(function() {
                                    
                                    angular.element(elem.find('label.custom-radio')[index]).addClass('selected'); 
                                    angular.element(elem.find('span.customRadioBox')[index]).addClass('selected'); 
                                    
                                });        
                            }
                            else {
                                $timeout(function() {
                                    
                                    angular.element(elem.find('label.custom-radio')[index]).removeClass('selected'); 
                                    angular.element(elem.find('span.customRadioBox')[index]).removeClass('selected'); 
                                    
                                });           
                            }

                        });
                        
                    }
                  
                });

                scope.$watch('options', function(n, o) {
                                       
                    angular.forEach(n, function(option, index) {
                        if(option.disabled) {
                            if(option.checked) {
                                disableAll = true;
                            }

                            $timeout(function() {
                                angular.element(elem.find('label.custom-radio')[index]).addClass('disabledColor'); 
                                angular.element(elem.find('span.customRadioBox')[index]).addClass('disabled'); 
                                
                            });    
                            
                        }
                        else {
                            $timeout(function() {
                                angular.element(elem.find('label.custom-radio')[index]).removeClass('disabledColor'); 
                                angular.element(elem.find('span.customRadioBox')[index]).removeClass('disabled'); 
                                
                            });           
                        }


                    });

                    

                }, true);            

            }
            else if(scope.type === '2') {
                template = '';
                if(scope.rLabel) {
                    template += '<label class="custom-radio" ng-click="optionClicked(\'' + scope.rValue + '\')"><span class="customRadioBox icn" ng-disabled="rDisabled"><input type="radio" ng-model="model" vmf-radio-value="' + scope.rValue + '" ng-disabled="rDisabled" name="' + scope.name + '" value="' + scope.rValue + '" ng-checked="rChecked" ng-click="clickCallback({$event:$event})" ></span>' + scope.rLabel + '</label>'; 
                }
                else {
                    template += '<label class="custom-radio" ng-click="optionClicked(\'' + scope.rValue + '\')"><span class="customRadioBox icn" ng-disabled="rDisabled"><input type="radio" ng-model="model" vmf-radio-value="' + scope.rValue + '" ng-disabled="rDisabled" name="' + scope.name + '" value="' + scope.rValue + '" ng-checked="rChecked" ng-click="clickCallback({$event:$event})" ></span></label>';     
                }    

                var repl = $compile(template)(scope);
                elem.replaceWith(repl);

                
                /*
                * label click for IE7
                */

                scope.optionClicked = function(value) {
                   
                    if(!scope.rDisabled && scope.model !== value) {
                        scope.model = value;
                    }
                    
                };

                scope.$watch('model', function(n, o) {
                    
                    if(n === null) {
                        $timeout(function() {
                            repl.removeClass('selected');
                            repl.find('span.customRadioBox').removeClass('selected'); 
                            scope.rChecked = false;
                        });    
                    }
                    else {
                        if(scope.rValue === n) {
                    
                            $timeout(function() {
                                repl.addClass('selected');
                                repl.find('span.customRadioBox').addClass('selected'); 
                                scope.rChecked = true;
                            });     
                        }
                        else {
                    
                            $timeout(function() {
                                repl.removeClass('selected');
                                repl.find('span.customRadioBox').removeClass('selected'); 
                                scope.rChecked = false;
                            });     
                        }
                    }
                    
                });

                scope.$watch('rDisabled', function(n, o) {
                    if(scope.rDisabled) {
                        $timeout(function() {
                            repl.addClass('disabledColor'); 
                            repl.find('span.customRadioBox').addClass('disabled'); 
                            
                        });  
                    }
                    else {
                        $timeout(function() {
                            repl.removeClass('disabledColor'); 
                            repl.find('span.customRadioBox').removeClass('disabled'); 
                            
                        });     
                    }
                });
            }

        }
        
    };
}])

/*
* vmfRadioValue directive for programmatic value binding in IE7
*/

.directive('vmfRadioValue', [function() {
    return {
        require: "ngModel",
        restrict: "A",
        link: function(scope, elem, attrs, controller) {

            while (attrs.value !== attrs.vmfRadioValue) {

                attrs.value = attrs.vmfRadioValue;
                controller.$render();
    
            }

        }        
    };
}]);

angular.module('vmfTooltipMod', [])
.directive("vmfTooltip", ['$compile', function($compile) {
    return{
        restrict: "EA",
        priority:2,      
        scope: true,
        link: function (scope, element, attrs) {
            scope.userOptions = scope.$eval(attrs.tooltipOptions);
            scope.options = angular.extend({}, {
                skin: 'dark',
                position: "right",
                radius: true,
                size: 'large',
                hideDelay: 500,
                showOn: 'mouseover',
                hideOn: 'mouseleave',
                maxWidth: "180",
                close: false,
                customClass: "tempClass",
                offsetX: 0,
                offsetY: 0
            }, scope.userOptions);
            scope.showTipOn = scope.options.showOn;
            scope.hideTipOn = scope.options.hideOn;
            var targetElement = typeof attrs.targetEle === "undefined" ? element : element.find("."+attrs.targetEle);
            var ele = Tipped.create(targetElement, scope.options.text, {
                skin: scope.options.skin,
                inline: true,
                position: scope.options.position,
                radius: scope.options.radius,
                hideDelay: scope.options.hideDelay,
                size: scope.options.size,
                hideOthers: false,
                hideOn: scope.hideTipOn,
                showOn: scope.showTipOn,
                maxWidth: scope.options.maxWidth,
                close: scope.options.close,
                offset: { x: scope.options.offsetX, y: scope.options.offsetY },
                onShow: function(content, element) {
                    $(element).addClass('highlight');
                    $(content).addClass(scope.options.customClass);
                    $(content).parents(".tpd-tooltip").removeClass("tpd-skin-dark").addClass("tpd-skin-"+scope.options.skin);
                    if($(element).hasClass("disableTooltip")){
                        $(content).parents(".tpd-tooltip").remove();
                    }
                },
                afterHide: function(content, element) {
                    $(element).removeClass('highlight');
                    $(content).removeClass(scope.options.customClass);
                    $(content).parents(".tpd-tooltip").removeClass("tpd-skin-dark").removeClass("tpd-skin-"+scope.options.skin);
                }
            });
            Tipped.hideTooltip = function(element){
                var tempEle = Tipped.get(element);
                var tempEleItems = tempEle.items();
                $(tempEleItems[0]._tooltip).hide();
            };
            Tipped.showTooltip = function(element){
                var tempEle = Tipped.get(element);
                var tempEleItems = tempEle.items();
                $(tempEleItems[0]._tooltip).show();
            };
            Tipped.removeTooltip = function(element){
                Tipped.remove(element);
            };
            Tipped.enableTooltip = function(element){
                $(element).removeClass("disableTooltip");
            };
            Tipped.disableTooltip = function(element){
                $(element).addClass("disableTooltip");
            };
            Tipped.updatePosition = function(element,value) {
                var tempEle = Tipped.get(element);
                var tempEleItems = tempEle.items();
                
                $(tempEleItems[0]._tooltip).find(".tpd-content").text(value);
                Tipped.refresh(element);

                // Tipped.remove(element);
                // Tipped.create(element,value);
                // Tipped.showTooltip(element);

                //$(tempEleItems[0]._tooltip).css({"left":(element.offset().left - ($(tempEleItems[0]._tooltip).width()/2)) + 5,"top":element.offset().top - ($(tempEleItems[0]._tooltip).height())});
                //$(tempEleItems[0]._tooltip).find(".tpd-content").text(value);
            };

        }
    };
}]);
angular.module('vmfTableFilterMod', [])
.service("vmfUtils", function($filter){
            this.getGroupingCollection = function (array, f) {

                var groups = {};

                array = array || [];

                array.forEach(function (o) {
                    var group = f(o), parentObj;

                    if (!groups[group]) {
                        parentObj = {};
                        //var parentObj = angular.extend({}, o);
                        parentObj.type = group; //TODO
                        parentObj.isParent = true;
                    }

                    groups[group] = groups[group] || [];

                    if (parentObj) {
                        groups[group].push(parentObj);
                    }

                    groups[group].push(o);
                });

                var groupData = Object.keys(groups).map(function (group) {
                    return groups[group];
                });

                groupData = groupData || [];

                return groupData.reduce(function (a, b) {
                        return a.concat(b);
                });
            };

            this.toggleTriStateCheckbox = function (data, input, column, item, bulkActionCallback) {
                var isAllSelected = false,
                    isSelectedAll = true,
                    checked = input.checked,                
                    checkboxField = column.checkboxField,
                    isAnySelected = false;

                item[checkboxField] = checked;

                if (checked) {
                    $.each(data, function (idx, row) {
                        if (!row[checkboxField]) {
                            isSelectedAll = false;
                            return false;
                        } 
                    });                        
                } else {
                    isSelectedAll = false;
                }                                     

                column[checkboxField] = isSelectedAll;

                $.each(data, function (idx, row) {
                    if (row[checkboxField]) {
                        isAnySelected = true;
                    } 
                });
                if(isAnySelected) {
                    bulkActionCallback(true);
                } else {
                    bulkActionCallback(false);
                }
            };    

            this.toggleAllCheckboxState = function(data, column, checked, bulkActionCallback){
                column[column.checkboxField] = checked;

                if (column) {
                    angular.forEach(data, function (row) {
                        row[column.checkboxField] = checked;
                    });
                }
                bulkActionCallback(checked);
            };  

            this.sortByColumn = function(data, column, columns, sortingParams){

                var params = sortingParams;
                
                if (params.field === column.field) {
                    params.reverse = !params.reverse;
                }

                params.field = column.field;

                angular.forEach(columns, function (col) {
                    col.sorted = '';
                });

                column.sorted = (params.reverse) ? 'sort-desc' : 'sort-asc';

                return $filter('orderBy')(data, column.field, params.reverse);             
            };

            this.getUnique = function (arr, field, value) {
                var result = [];
                for (var i = 0; i < arr.length; i++) {
                    var item = arr[i];
                    if(item[field] === value){
                        result.push(item);
                    }
                }

                return result;
            };
            this.filterByColumn = function(data, text, column){
                return $filter('vmfTableSearch')(data, text, column || 'product'); 
            };
        this.getSelectedItems = function(data) {
                var selectedItems = [];
                angular.forEach(data, function(itemObj) {
                    if(itemObj.isCheckboxSelected) {
                        selectedItems.push(angular.copy(itemObj));
                    }
                });
                return selectedItems;
            };

        })
.directive('vmfTableAutoComplete', ['$timeout','$parse','$http', function($timeout, $parse, $http) {
    return {
        restrict: 'A',
        scope: {
          url:"@",
          filterBy:"@",
          data:"=",          
          onSelect:"&"
        },         
        link: function(scope, elem, attrs) {
          //scope.url = "../data/countries.json";

            scope.$watch("data", function(newValue){
                // if(newValue && newValue.length == 0) return;

                var sourceArray = scope.data;

                $timeout(function(){
                      elem.autocomplete().autocomplete("destroy").autocomplete({            
                        source: function(request, response){

                          var term = request.term;
                          var searchRegex= "^"+term;

                          var regex = new RegExp(searchRegex,'i');
                          //var regex = new RegExp("^"+term,"gi");
                          var result =[];

                         angular.forEach(sourceArray, function(item){
                             if(item && regex.test(item.name)){
                                  result.push(item);
                              }
                          });

                          //console.log("result",result);

                          response(result);
                        },
                        minLength: 1,
                        select: function( event, ui ) {                          
                          event.stopImmediatePropagation();                   
                          scope.onSelect({item:ui.item});
                          //scope.onSelect(ui.item);
                        }
                      })
                      .autocomplete( "instance" )._renderItem = function( ul, item ) {
                          return $( "<li>" )
                            .append( "<a>" + item.name + "</a>" )
                            .appendTo( ul );
                      };
              },0);              
            });            
        }           
    };
}])

.directive('vmfTableFilterButton', ['$compile','$templateCache','$timeout','$document', function( $compile, $templateCache,$timeout,$document) {
    return {
        restrict: 'A',
        scope: {
            title: '@',
            name: '@',            
            data: '=',
            url: '@',
            mandatoryDate:'@',
            onChange :'&'
        },
        controller: function($scope, $http) {

           $scope.$on('vmfTable.event.resetfilter', function (event, data) {
              //console.log("vmfTable.event.resetfilter data, data"); // 'Data to send'
              $scope.selectedItems = [];
              $scope.selectedDate=null;
              $scope.clearAll();
           });
            
            $scope.clearAll = function(target){
              if(target){
            $(target.currentTarget).closest('.dropdown').removeClass('open'); 
                 }
            $scope.selectedItems = [];             
              angular.forEach($scope.parsedData, function(item){
                item.selected = false;
              });
            };

            $scope.applyFilter = function(event){
              $(event.currentTarget).closest('.dropdown').removeClass('open');
              $scope.selectedItems = [];
              angular.forEach($scope.parsedData, function(item){
                if(item.selected){
                    $scope.selectedItems.push(item);
                }
              });

              var params = {event:event, target: $scope.name, items : $scope.selectedItems};              
              $scope.onChange({params:params});
            };
             
             $scope.onDateSelect =function(item, $event){               
                item.label = $($event.target).closest(".checkbox").find("input.vmf-calInput").val();
               //$scope.apply();                   
             };

            $scope.deleteItem = function (item, index, event) {
              $scope.selectedItems.splice(index, 1);                
                item.selected = false;

                if(item.isDateField){
                  $(event.target).closest(".selected-item-container")                                 
                                 .siblings(".table-filter").find("input.vmf-calInput").val("");   
                }

               // $scope.tempParsedData = angular.copy($scope.parsedData);
              };
            
            $scope.liClickHandler = function($event){
              $event.stopPropagation();
            };
                  
            $scope.loadData = function(){
                if($scope.url){                   
                    $http.get($scope.url).success(function (result) {
                        $scope.data = result.data;
                    })
                    .error(function (data, status, headers, config) {
                        //console.log("TABLE FILTER SERVICE FOR "+ $scope.name + " NOT ABLE");                       
                    });
                }
            };

            $scope.init = function(){
                $scope.loadData();
            };

            $scope.init();
                   

        }, 
        
        link: function(scope, elem, attrs) {
            scope.selectedItems=[];
            scope.parsedData = [];
            scope.selectedDate = '';            
          
            scope.$watch("data", function(newValue){
                scope.parsedData = scope.data;
            });
             
            var hideDropdownFlag = false;
            elem.find('.btn-group.dropdown.table-filter').on('hide.bs.dropdown', function (e) {
              if( hideDropdownFlag ){
                hideDropdownFlag = false;
                return false;
              }
            });
           
            elem.find('.dropdown-menu').off('click').on('click', function(e){
              if( $(e.target).hasClass('.dropdown-menu') || $(e.target).closest('.dropdown-menu').length ){
                hideDropdownFlag = true;
              }
            });

            scope.subscribe('closeAllFilters', function(){
                elem.find('.btn-group.dropdown.table-filter').removeClass('open');
            });

            $document.on("click", function(e){  
                var found = false;                      

              if (!elem.find('.btn-group.dropdown.table-filter').is(e.target) 
                  && elem.find('.btn-group.dropdown.table-filter').has(e.target).length === 0 
                  && elem.find('.open').has(e.target).length === 0
              ) {
                  elem.find('.btn-group.dropdown.table-filter').removeClass('open');
              }
              
              if($(e.target).closest(".btn-group.dropdown").length === 0){                        
                    //scope.parsedData = angular.copy(scope.tempParsedData);    
                    if(scope.selectedItems && scope.selectedItems.length === 0){
                        scope.clearAll();
                    }else{

                      angular.forEach(scope.parsedData, function(item){     
                          found = false;                     
                          angular.forEach(scope.selectedItems, function(selItems){
                              if(item === selItems){
                                item.selected = true;
                                found = true;
                              }
                          });

                          if(!found){
                            item.selected = false;
                          }
                      });   
                  }

                }

                scope.$apply();
            });

            $timeout(function(){
                $('.dropdown-menu li').click(function(e) {
                    e.stopPropagation();
                });

                if(scope.mandatoryDate===true){
                    var tableFilterDateContainer = $(elem).find('.table-filter-date-container');
                    $(tableFilterDateContainer).datepicker({
                        format: "dd/mm/yyyy"
                    });  
                }
            }, 1000);
        },
         templateUrl: '/vmf/m/components/tableFilter/filterDropDown.html' 
        
    };
}])


.directive('vmfTableFilter', ['$timeout', function($timeout) {
    return {
        restrict: 'EA',
        scope: {
            title: '=',
            filterData: '=', 
            name:"=",
            onItemSelected:'&',
            autoCompleteData:"="
        },
       controller:function($scope) {
          var filterItems = {};
          
          $scope.onChange = function(params){    
            if(params){
                filterItems[params.target] = params.items;
                $scope.onItemSelected({event: params.event, target:params.target, itemSelected: params.items, allSelectedItems: filterItems});
            }
          };

          $scope.isLocation = function(item){
              return item && item.type === "location";
          };  

          $scope.filterReset = function(){
            //console.log("filterReset trigger");
            $scope.$broadcast("vmfTable.event.resetfilter",{}); 
          };     
         
          angular.forEach($scope.filterData, function(item){
                //console.log(item.tableFilterTitle, item.data, item.url);            
                filterItems[item.name] = [];
          });

        },
       template : '<div id="dropdown-holder">'+
                    '<div class="dropdowns-container">'+
                        '<div ng-repeat="item in filterData" class="each-dropdown">'+
                            '<div vmf-table-filter-button  ng-if="!isLocation(item)" name="{{item.name}}" mandatory-date="{{item.mandatoryDate}}" data="item.data" url="{{item.url}}" on-change="onChange(params)"></div>'+
                            '<div vmf-table-filter-button-location auto-complete-data="autoCompleteData" ng-if="isLocation(item)" name="{{item.name}}" mandatory-date="{{item.mandatoryDate}}" data="item.data" url="{{item.url}}" on-change="onChange(params)"></div>'+                            
                        '</div>'+
                    '</div>' +
                  '</div>'
    };
}]);
/*!
 * ZeroClipboard
 * The ZeroClipboard library provides an easy way to copy text to the clipboard using an invisible Adobe Flash movie and a JavaScript interface.
 * Copyright (c) 2014 Jon Rohan, James M. Greene
 * Licensed MIT
 * http://zeroclipboard.org/
 * v2.1.6
 */
(function(window, undefined) {
  "use strict";
  /**
 * Store references to critically important global functions that may be
 * overridden on certain web pages.
 */
  var _window = window, _document = _window.document, _navigator = _window.navigator, _setTimeout = _window.setTimeout, _encodeURIComponent = _window.encodeURIComponent, _ActiveXObject = _window.ActiveXObject, _Error = _window.Error, _parseInt = _window.Number.parseInt || _window.parseInt, _parseFloat = _window.Number.parseFloat || _window.parseFloat, _isNaN = _window.Number.isNaN || _window.isNaN, _round = _window.Math.round, _now = _window.Date.now, _keys = _window.Object.keys, _defineProperty = _window.Object.defineProperty, _hasOwn = _window.Object.prototype.hasOwnProperty, _slice = _window.Array.prototype.slice, _unwrap = function() {
    var unwrapper = function(el) {
      return el;
    };
    if (typeof _window.wrap === "function" && typeof _window.unwrap === "function") {
      try {
        var div = _document.createElement("div");
        var unwrappedDiv = _window.unwrap(div);
        if (div.nodeType === 1 && unwrappedDiv && unwrappedDiv.nodeType === 1) {
          unwrapper = _window.unwrap;
        }
      } catch (e) {}
    }
    return unwrapper;
  }();
  /**
 * Convert an `arguments` object into an Array.
 *
 * @returns The arguments as an Array
 * @private
 */
  var _args = function(argumentsObj) {
    return _slice.call(argumentsObj, 0);
  };
  /**
 * Shallow-copy the owned, enumerable properties of one object over to another, similar to jQuery's `$.extend`.
 *
 * @returns The target object, augmented
 * @private
 */
  var _extend = function() {
    var i, len, arg, prop, src, copy, args = _args(arguments), target = args[0] || {};
    for (i = 1, len = args.length; i < len; i++) {
      if ((arg = args[i]) != null) {
        for (prop in arg) {
          if (_hasOwn.call(arg, prop)) {
            src = target[prop];
            copy = arg[prop];
            if (target !== copy && copy !== undefined) {
              target[prop] = copy;
            }
          }
        }
      }
    }
    return target;
  };
  /**
 * Return a deep copy of the source object or array.
 *
 * @returns Object or Array
 * @private
 */
  var _deepCopy = function(source) {
    var copy, i, len, prop;
    if (typeof source !== "object" || source == null) {
      copy = source;
    } else if (typeof source.length === "number") {
      copy = [];
      for (i = 0, len = source.length; i < len; i++) {
        if (_hasOwn.call(source, i)) {
          copy[i] = _deepCopy(source[i]);
        }
      }
    } else {
      copy = {};
      for (prop in source) {
        if (_hasOwn.call(source, prop)) {
          copy[prop] = _deepCopy(source[prop]);
        }
      }
    }
    return copy;
  };
  /**
 * Makes a shallow copy of `obj` (like `_extend`) but filters its properties based on a list of `keys` to keep.
 * The inverse of `_omit`, mostly. The big difference is that these properties do NOT need to be enumerable to
 * be kept.
 *
 * @returns A new filtered object.
 * @private
 */
  var _pick = function(obj, keys) {
    var newObj = {};
    for (var i = 0, len = keys.length; i < len; i++) {
      if (keys[i] in obj) {
        newObj[keys[i]] = obj[keys[i]];
      }
    }
    return newObj;
  };
  /**
 * Makes a shallow copy of `obj` (like `_extend`) but filters its properties based on a list of `keys` to omit.
 * The inverse of `_pick`.
 *
 * @returns A new filtered object.
 * @private
 */
  var _omit = function(obj, keys) {
    var newObj = {};
    for (var prop in obj) {
      if (keys.indexOf(prop) === -1) {
        newObj[prop] = obj[prop];
      }
    }
    return newObj;
  };
  /**
 * Remove all owned, enumerable properties from an object.
 *
 * @returns The original object without its owned, enumerable properties.
 * @private
 */
  var _deleteOwnProperties = function(obj) {
    if (obj) {
      for (var prop in obj) {
        if (_hasOwn.call(obj, prop)) {
          delete obj[prop];
        }
      }
    }
    return obj;
  };
  /**
 * Determine if an element is contained within another element.
 *
 * @returns Boolean
 * @private
 */
  var _containedBy = function(el, ancestorEl) {
    if (el && el.nodeType === 1 && el.ownerDocument && ancestorEl && (ancestorEl.nodeType === 1 && ancestorEl.ownerDocument && ancestorEl.ownerDocument === el.ownerDocument || ancestorEl.nodeType === 9 && !ancestorEl.ownerDocument && ancestorEl === el.ownerDocument)) {
      do {
        if (el === ancestorEl) {
          return true;
        }
        el = el.parentNode;
      } while (el);
    }
    return false;
  };
  /**
 * Get the URL path's parent directory.
 *
 * @returns String or `undefined`
 * @private
 */
  var _getDirPathOfUrl = function(url) {
    var dir;
    if (typeof url === "string" && url) {
      dir = url.split("#")[0].split("?")[0];
      dir = url.slice(0, url.lastIndexOf("/") + 1);
    }
    return dir;
  };
  /**
 * Get the current script's URL by throwing an `Error` and analyzing it.
 *
 * @returns String or `undefined`
 * @private
 */
  var _getCurrentScriptUrlFromErrorStack = function(stack) {
    var url, matches;
    if (typeof stack === "string" && stack) {
      matches = stack.match(/^(?:|[^:@]*@|.+\)@(?=http[s]?|file)|.+?\s+(?: at |@)(?:[^:\(]+ )*[\(]?)((?:http[s]?|file):\/\/[\/]?.+?\/[^:\)]*?)(?::\d+)(?::\d+)?/);
      if (matches && matches[1]) {
        url = matches[1];
      } else {
        matches = stack.match(/\)@((?:http[s]?|file):\/\/[\/]?.+?\/[^:\)]*?)(?::\d+)(?::\d+)?/);
        if (matches && matches[1]) {
          url = matches[1];
        }
      }
    }
    return url;
  };
  /**
 * Get the current script's URL by throwing an `Error` and analyzing it.
 *
 * @returns String or `undefined`
 * @private
 */
  var _getCurrentScriptUrlFromError = function() {
    var url, err;
    try {
      throw new _Error();
    } catch (e) {
      err = e;
    }
    if (err) {
      url = err.sourceURL || err.fileName || _getCurrentScriptUrlFromErrorStack(err.stack);
    }
    return url;
  };
  /**
 * Get the current script's URL.
 *
 * @returns String or `undefined`
 * @private
 */
  var _getCurrentScriptUrl = function() {
    var jsPath, scripts, i;
    if (_document.currentScript && (jsPath = _document.currentScript.src)) {
      return jsPath;
    }
    scripts = _document.getElementsByTagName("script");
    if (scripts.length === 1) {
      return scripts[0].src || undefined;
    }
    if ("readyState" in scripts[0]) {
      for (i = scripts.length; i--; ) {
        if (scripts[i].readyState === "interactive" && (jsPath = scripts[i].src)) {
          return jsPath;
        }
      }
    }
    if (_document.readyState === "loading" && (jsPath = scripts[scripts.length - 1].src)) {
      return jsPath;
    }
    if (jsPath = _getCurrentScriptUrlFromError()) {
      return jsPath;
    }
    return undefined;
  };
  /**
 * Get the unanimous parent directory of ALL script tags.
 * If any script tags are either (a) inline or (b) from differing parent
 * directories, this method must return `undefined`.
 *
 * @returns String or `undefined`
 * @private
 */
  var _getUnanimousScriptParentDir = function() {
    var i, jsDir, jsPath, scripts = _document.getElementsByTagName("script");
    for (i = scripts.length; i--; ) {
      if (!(jsPath = scripts[i].src)) {
        jsDir = null;
        break;
      }
      jsPath = _getDirPathOfUrl(jsPath);
      if (jsDir == null) {
        jsDir = jsPath;
      } else if (jsDir !== jsPath) {
        jsDir = null;
        break;
      }
    }
    return jsDir || undefined;
  };
  /**
 * Get the presumed location of the "ZeroClipboard.swf" file, based on the location
 * of the executing JavaScript file (e.g. "ZeroClipboard.js", etc.).
 *
 * @returns String
 * @private
 */
  var _getDefaultSwfPath = function() {
    var jsDir = _getDirPathOfUrl(_getCurrentScriptUrl()) || _getUnanimousScriptParentDir() || "";
    return jsDir + "ZeroClipboard.swf";
  };
  /**
 * Keep track of the state of the Flash object.
 * @private
 */
  var _flashState = {
    bridge: null,
    version: "0.0.0",
    pluginType: "unknown",
    disabled: null,
    outdated: null,
    unavailable: null,
    deactivated: null,
    overdue: null,
    ready: null
  };
  /**
 * The minimum Flash Player version required to use ZeroClipboard completely.
 * @readonly
 * @private
 */
  var _minimumFlashVersion = "11.0.0";
  /**
 * Keep track of all event listener registrations.
 * @private
 */
  var _handlers = {};
  /**
 * Keep track of the currently activated element.
 * @private
 */
  var _currentElement;
  /**
 * Keep track of the element that was activated when a `copy` process started.
 * @private
 */
  var _copyTarget;
  /**
 * Keep track of data for the pending clipboard transaction.
 * @private
 */
  var _clipData = {};
  /**
 * Keep track of data formats for the pending clipboard transaction.
 * @private
 */
  var _clipDataFormatMap = null;
  /**
 * The `message` store for events
 * @private
 */
  var _eventMessages = {
    ready: "Flash communication is established",
    error: {
      "flash-disabled": "Flash is disabled or not installed",
      "flash-outdated": "Flash is too outdated to support ZeroClipboard",
      "flash-unavailable": "Flash is unable to communicate bidirectionally with JavaScript",
      "flash-deactivated": "Flash is too outdated for your browser and/or is configured as click-to-activate",
      "flash-overdue": "Flash communication was established but NOT within the acceptable time limit"
    }
  };
  /**
 * ZeroClipboard configuration defaults for the Core module.
 * @private
 */
  var _globalConfig = {
    swfPath: _getDefaultSwfPath(),
    trustedDomains: window.location.host ? [ window.location.host ] : [],
    cacheBust: true,
    forceEnhancedClipboard: false,
    flashLoadTimeout: 3e4,
    autoActivate: true,
    bubbleEvents: true,
    containerId: "global-zeroclipboard-html-bridge",
    containerClass: "global-zeroclipboard-container",
    swfObjectId: "global-zeroclipboard-flash-bridge",
    hoverClass: "zeroclipboard-is-hover",
    activeClass: "zeroclipboard-is-active",
    forceHandCursor: false,
    title: null,
    zIndex: 999999999
  };
  /**
 * The underlying implementation of `ZeroClipboard.config`.
 * @private
 */
  var _config = function(options) {
    if (typeof options === "object" && options !== null) {
      for (var prop in options) {
        if (_hasOwn.call(options, prop)) {
          if (/^(?:forceHandCursor|title|zIndex|bubbleEvents)$/.test(prop)) {
            _globalConfig[prop] = options[prop];
          } else if (_flashState.bridge == null) {
            if (prop === "containerId" || prop === "swfObjectId") {
              if (_isValidHtml4Id(options[prop])) {
                _globalConfig[prop] = options[prop];
              } else {
                throw new Error("The specified `" + prop + "` value is not valid as an HTML4 Element ID");
              }
            } else {
              _globalConfig[prop] = options[prop];
            }
          }
        }
      }
    }
    if (typeof options === "string" && options) {
      if (_hasOwn.call(_globalConfig, options)) {
        return _globalConfig[options];
      }
      return;
    }
    return _deepCopy(_globalConfig);
  };
  /**
 * The underlying implementation of `ZeroClipboard.state`.
 * @private
 */
  var _state = function() {
    return {
      browser: _pick(_navigator, [ "userAgent", "platform", "appName" ]),
      flash: _omit(_flashState, [ "bridge" ]),
      zeroclipboard: {
        version: ZeroClipboard.version,
        config: ZeroClipboard.config()
      }
    };
  };
  /**
 * The underlying implementation of `ZeroClipboard.isFlashUnusable`.
 * @private
 */
  var _isFlashUnusable = function() {
    return !!(_flashState.disabled || _flashState.outdated || _flashState.unavailable || _flashState.deactivated);
  };
  /**
 * The underlying implementation of `ZeroClipboard.on`.
 * @private
 */
  var _on = function(eventType, listener) {
    var i, len, events, added = {};
    if (typeof eventType === "string" && eventType) {
      events = eventType.toLowerCase().split(/\s+/);
    } else if (typeof eventType === "object" && eventType && typeof listener === "undefined") {
      for (i in eventType) {
        if (_hasOwn.call(eventType, i) && typeof i === "string" && i && typeof eventType[i] === "function") {
          ZeroClipboard.on(i, eventType[i]);
        }
      }
    }
    if (events && events.length) {
      for (i = 0, len = events.length; i < len; i++) {
        eventType = events[i].replace(/^on/, "");
        added[eventType] = true;
        if (!_handlers[eventType]) {
          _handlers[eventType] = [];
        }
        _handlers[eventType].push(listener);
      }
      if (added.ready && _flashState.ready) {
        ZeroClipboard.emit({
          type: "ready"
        });
      }
      if (added.error) {
        var errorTypes = [ "disabled", "outdated", "unavailable", "deactivated", "overdue" ];
        for (i = 0, len = errorTypes.length; i < len; i++) {
          if (_flashState[errorTypes[i]] === true) {
            ZeroClipboard.emit({
              type: "error",
              name: "flash-" + errorTypes[i]
            });
            break;
          }
        }
      }
    }
    return ZeroClipboard;
  };
  /**
 * The underlying implementation of `ZeroClipboard.off`.
 * @private
 */
  var _off = function(eventType, listener) {
    var i, len, foundIndex, events, perEventHandlers;
    if (arguments.length === 0) {
      events = _keys(_handlers);
    } else if (typeof eventType === "string" && eventType) {
      events = eventType.split(/\s+/);
    } else if (typeof eventType === "object" && eventType && typeof listener === "undefined") {
      for (i in eventType) {
        if (_hasOwn.call(eventType, i) && typeof i === "string" && i && typeof eventType[i] === "function") {
          ZeroClipboard.off(i, eventType[i]);
        }
      }
    }
    if (events && events.length) {
      for (i = 0, len = events.length; i < len; i++) {
        eventType = events[i].toLowerCase().replace(/^on/, "");
        perEventHandlers = _handlers[eventType];
        if (perEventHandlers && perEventHandlers.length) {
          if (listener) {
            foundIndex = perEventHandlers.indexOf(listener);
            while (foundIndex !== -1) {
              perEventHandlers.splice(foundIndex, 1);
              foundIndex = perEventHandlers.indexOf(listener, foundIndex);
            }
          } else {
            perEventHandlers.length = 0;
          }
        }
      }
    }
    return ZeroClipboard;
  };
  /**
 * The underlying implementation of `ZeroClipboard.handlers`.
 * @private
 */
  var _listeners = function(eventType) {
    var copy;
    if (typeof eventType === "string" && eventType) {
      copy = _deepCopy(_handlers[eventType]) || null;
    } else {
      copy = _deepCopy(_handlers);
    }
    return copy;
  };
  /**
 * The underlying implementation of `ZeroClipboard.emit`.
 * @private
 */
  var _emit = function(event) {
    var eventCopy, returnVal, tmp;
    event = _createEvent(event);
    if (!event) {
      return;
    }
    if (_preprocessEvent(event)) {
      return;
    }
    if (event.type === "ready" && _flashState.overdue === true) {
      return ZeroClipboard.emit({
        type: "error",
        name: "flash-overdue"
      });
    }
    eventCopy = _extend({}, event);
    _dispatchCallbacks.call(this, eventCopy);
    if (event.type === "copy") {
      tmp = _mapClipDataToFlash(_clipData);
      returnVal = tmp.data;
      _clipDataFormatMap = tmp.formatMap;
    }
    return returnVal;
  };
  /**
 * The underlying implementation of `ZeroClipboard.create`.
 * @private
 */
  var _create = function() {
    if (typeof _flashState.ready !== "boolean") {
      _flashState.ready = false;
    }
    if (!ZeroClipboard.isFlashUnusable() && _flashState.bridge === null) {
      var maxWait = _globalConfig.flashLoadTimeout;
      if (typeof maxWait === "number" && maxWait >= 0) {
        _setTimeout(function() {
          if (typeof _flashState.deactivated !== "boolean") {
            _flashState.deactivated = true;
          }
          if (_flashState.deactivated === true) {
            ZeroClipboard.emit({
              type: "error",
              name: "flash-deactivated"
            });
          }
        }, maxWait);
      }
      _flashState.overdue = false;
      _embedSwf();
    }
  };
  /**
 * The underlying implementation of `ZeroClipboard.destroy`.
 * @private
 */
  var _destroy = function() {
    ZeroClipboard.clearData();
    ZeroClipboard.blur();
    ZeroClipboard.emit("destroy");
    _unembedSwf();
    ZeroClipboard.off();
  };
  /**
 * The underlying implementation of `ZeroClipboard.setData`.
 * @private
 */
  var _setData = function(format, data) {
    var dataObj;
    if (typeof format === "object" && format && typeof data === "undefined") {
      dataObj = format;
      ZeroClipboard.clearData();
    } else if (typeof format === "string" && format) {
      dataObj = {};
      dataObj[format] = data;
    } else {
      return;
    }
    for (var dataFormat in dataObj) {
      if (typeof dataFormat === "string" && dataFormat && _hasOwn.call(dataObj, dataFormat) && typeof dataObj[dataFormat] === "string" && dataObj[dataFormat]) {
        _clipData[dataFormat] = dataObj[dataFormat];
      }
    }
  };
  /**
 * The underlying implementation of `ZeroClipboard.clearData`.
 * @private
 */
  var _clearData = function(format) {
    if (typeof format === "undefined") {
      _deleteOwnProperties(_clipData);
      _clipDataFormatMap = null;
    } else if (typeof format === "string" && _hasOwn.call(_clipData, format)) {
      delete _clipData[format];
    }
  };
  /**
 * The underlying implementation of `ZeroClipboard.getData`.
 * @private
 */
  var _getData = function(format) {
    if (typeof format === "undefined") {
      return _deepCopy(_clipData);
    } else if (typeof format === "string" && _hasOwn.call(_clipData, format)) {
      return _clipData[format];
    }
  };
  /**
 * The underlying implementation of `ZeroClipboard.focus`/`ZeroClipboard.activate`.
 * @private
 */
  var _focus = function(element) {
    if (!(element && element.nodeType === 1)) {
      return;
    }
    if (_currentElement) {
      _removeClass(_currentElement, _globalConfig.activeClass);
      if (_currentElement !== element) {
        _removeClass(_currentElement, _globalConfig.hoverClass);
      }
    }
    _currentElement = element;
    _addClass(element, _globalConfig.hoverClass);
    var newTitle = element.getAttribute("title") || _globalConfig.title;
    if (typeof newTitle === "string" && newTitle) {
      var htmlBridge = _getHtmlBridge(_flashState.bridge);
      if (htmlBridge) {
        htmlBridge.setAttribute("title", newTitle);
      }
    }
    var useHandCursor = _globalConfig.forceHandCursor === true || _getStyle(element, "cursor") === "pointer";
    _setHandCursor(useHandCursor);
    _reposition();
  };
  /**
 * The underlying implementation of `ZeroClipboard.blur`/`ZeroClipboard.deactivate`.
 * @private
 */
  var _blur = function() {
    var htmlBridge = _getHtmlBridge(_flashState.bridge);
    if (htmlBridge) {
      htmlBridge.removeAttribute("title");
      htmlBridge.style.left = "0px";
      htmlBridge.style.top = "-9999px";
      htmlBridge.style.width = "1px";
      htmlBridge.style.top = "1px";
    }
    if (_currentElement) {
      _removeClass(_currentElement, _globalConfig.hoverClass);
      _removeClass(_currentElement, _globalConfig.activeClass);
      _currentElement = null;
    }
  };
  /**
 * The underlying implementation of `ZeroClipboard.activeElement`.
 * @private
 */
  var _activeElement = function() {
    return _currentElement || null;
  };
  /**
 * Check if a value is a valid HTML4 `ID` or `Name` token.
 * @private
 */
  var _isValidHtml4Id = function(id) {
    return typeof id === "string" && id && /^[A-Za-z][A-Za-z0-9_:\-\.]*$/.test(id);
  };
  /**
 * Create or update an `event` object, based on the `eventType`.
 * @private
 */
  var _createEvent = function(event) {
    var eventType;
    if (typeof event === "string" && event) {
      eventType = event;
      event = {};
    } else if (typeof event === "object" && event && typeof event.type === "string" && event.type) {
      eventType = event.type;
    }
    if (!eventType) {
      return;
    }
    if (!event.target && /^(copy|aftercopy|_click)$/.test(eventType.toLowerCase())) {
      event.target = _copyTarget;
    }
    _extend(event, {
      type: eventType.toLowerCase(),
      target: event.target || _currentElement || null,
      relatedTarget: event.relatedTarget || null,
      currentTarget: _flashState && _flashState.bridge || null,
      timeStamp: event.timeStamp || _now() || null
    });
    var msg = _eventMessages[event.type];
    if (event.type === "error" && event.name && msg) {
      msg = msg[event.name];
    }
    if (msg) {
      event.message = msg;
    }
    if (event.type === "ready") {
      _extend(event, {
        target: null,
        version: _flashState.version
      });
    }
    if (event.type === "error") {
      if (/^flash-(disabled|outdated|unavailable|deactivated|overdue)$/.test(event.name)) {
        _extend(event, {
          target: null,
          minimumVersion: _minimumFlashVersion
        });
      }
      if (/^flash-(outdated|unavailable|deactivated|overdue)$/.test(event.name)) {
        _extend(event, {
          version: _flashState.version
        });
      }
    }
    if (event.type === "copy") {
      event.clipboardData = {
        setData: ZeroClipboard.setData,
        clearData: ZeroClipboard.clearData
      };
    }
    if (event.type === "aftercopy") {
      event = _mapClipResultsFromFlash(event, _clipDataFormatMap);
    }
    if (event.target && !event.relatedTarget) {
      event.relatedTarget = _getRelatedTarget(event.target);
    }
    event = _addMouseData(event);
    return event;
  };
  /**
 * Get a relatedTarget from the target's `data-clipboard-target` attribute
 * @private
 */
  var _getRelatedTarget = function(targetEl) {
    var relatedTargetId = targetEl && targetEl.getAttribute && targetEl.getAttribute("data-clipboard-target");
    return relatedTargetId ? _document.getElementById(relatedTargetId) : null;
  };
  /**
 * Add element and position data to `MouseEvent` instances
 * @private
 */
  var _addMouseData = function(event) {
    if (event && /^_(?:click|mouse(?:over|out|down|up|move))$/.test(event.type)) {
      var srcElement = event.target;
      var fromElement = event.type === "_mouseover" && event.relatedTarget ? event.relatedTarget : undefined;
      var toElement = event.type === "_mouseout" && event.relatedTarget ? event.relatedTarget : undefined;
      var pos = _getDOMObjectPosition(srcElement);
      var screenLeft = _window.screenLeft || _window.screenX || 0;
      var screenTop = _window.screenTop || _window.screenY || 0;
      var scrollLeft = _document.body.scrollLeft + _document.documentElement.scrollLeft;
      var scrollTop = _document.body.scrollTop + _document.documentElement.scrollTop;
      var pageX = pos.left + (typeof event._stageX === "number" ? event._stageX : 0);
      var pageY = pos.top + (typeof event._stageY === "number" ? event._stageY : 0);
      var clientX = pageX - scrollLeft;
      var clientY = pageY - scrollTop;
      var screenX = screenLeft + clientX;
      var screenY = screenTop + clientY;
      var moveX = typeof event.movementX === "number" ? event.movementX : 0;
      var moveY = typeof event.movementY === "number" ? event.movementY : 0;
      delete event._stageX;
      delete event._stageY;
      _extend(event, {
        srcElement: srcElement,
        fromElement: fromElement,
        toElement: toElement,
        screenX: screenX,
        screenY: screenY,
        pageX: pageX,
        pageY: pageY,
        clientX: clientX,
        clientY: clientY,
        x: clientX,
        y: clientY,
        movementX: moveX,
        movementY: moveY,
        offsetX: 0,
        offsetY: 0,
        layerX: 0,
        layerY: 0
      });
    }
    return event;
  };
  /**
 * Determine if an event's registered handlers should be execute synchronously or asynchronously.
 *
 * @returns {boolean}
 * @private
 */
  var _shouldPerformAsync = function(event) {
    var eventType = event && typeof event.type === "string" && event.type || "";
    return !/^(?:(?:before)?copy|destroy)$/.test(eventType);
  };
  /**
 * Control if a callback should be executed asynchronously or not.
 *
 * @returns `undefined`
 * @private
 */
  var _dispatchCallback = function(func, context, args, async) {
    if (async) {
      _setTimeout(function() {
        func.apply(context, args);
      }, 0);
    } else {
      func.apply(context, args);
    }
  };
  /**
 * Handle the actual dispatching of events to client instances.
 *
 * @returns `undefined`
 * @private
 */
  var _dispatchCallbacks = function(event) {
    if (!(typeof event === "object" && event && event.type)) {
      return;
    }
    var async = _shouldPerformAsync(event);
    var wildcardTypeHandlers = _handlers["*"] || [];
    var specificTypeHandlers = _handlers[event.type] || [];
    var handlers = wildcardTypeHandlers.concat(specificTypeHandlers);
    if (handlers && handlers.length) {
      var i, len, func, context, eventCopy, originalContext = this;
      for (i = 0, len = handlers.length; i < len; i++) {
        func = handlers[i];
        context = originalContext;
        if (typeof func === "string" && typeof _window[func] === "function") {
          func = _window[func];
        }
        if (typeof func === "object" && func && typeof func.handleEvent === "function") {
          context = func;
          func = func.handleEvent;
        }
        if (typeof func === "function") {
          eventCopy = _extend({}, event);
          _dispatchCallback(func, context, [ eventCopy ], async);
        }
      }
    }
    return this;
  };
  /**
 * Preprocess any special behaviors, reactions, or state changes after receiving this event.
 * Executes only once per event emitted, NOT once per client.
 * @private
 */
  var _preprocessEvent = function(event) {
    var element = event.target || _currentElement || null;
    var sourceIsSwf = event._source === "swf";
    delete event._source;
    var flashErrorNames = [ "flash-disabled", "flash-outdated", "flash-unavailable", "flash-deactivated", "flash-overdue" ];
    switch (event.type) {
     case "error":
      if (flashErrorNames.indexOf(event.name) !== -1) {
        _extend(_flashState, {
          disabled: event.name === "flash-disabled",
          outdated: event.name === "flash-outdated",
          unavailable: event.name === "flash-unavailable",
          deactivated: event.name === "flash-deactivated",
          overdue: event.name === "flash-overdue",
          ready: false
        });
      }
      break;

     case "ready":
      var wasDeactivated = _flashState.deactivated === true;
      _extend(_flashState, {
        disabled: false,
        outdated: false,
        unavailable: false,
        deactivated: false,
        overdue: wasDeactivated,
        ready: !wasDeactivated
      });
      break;

     case "beforecopy":
      _copyTarget = element;
      break;

     case "copy":
      var textContent, htmlContent, targetEl = event.relatedTarget;
      if (!(_clipData["text/html"] || _clipData["text/plain"]) && targetEl && (htmlContent = targetEl.value || targetEl.outerHTML || targetEl.innerHTML) && (textContent = targetEl.value || targetEl.textContent || targetEl.innerText)) {
        event.clipboardData.clearData();
        event.clipboardData.setData("text/plain", textContent);
        if (htmlContent !== textContent) {
          event.clipboardData.setData("text/html", htmlContent);
        }
      } else if (!_clipData["text/plain"] && event.target && (textContent = event.target.getAttribute("data-clipboard-text"))) {
        event.clipboardData.clearData();
        event.clipboardData.setData("text/plain", textContent);
      }
      break;

     case "aftercopy":
      ZeroClipboard.clearData();
      if (element && element !== _safeActiveElement() && element.focus) {
        element.focus();
      }
      break;

     case "_mouseover":
      ZeroClipboard.focus(element);
      if (_globalConfig.bubbleEvents === true && sourceIsSwf) {
        if (element && element !== event.relatedTarget && !_containedBy(event.relatedTarget, element)) {
          _fireMouseEvent(_extend({}, event, {
            type: "mouseenter",
            bubbles: false,
            cancelable: false
          }));
        }
        _fireMouseEvent(_extend({}, event, {
          type: "mouseover"
        }));
      }
      break;

     case "_mouseout":
      ZeroClipboard.blur();
      if (_globalConfig.bubbleEvents === true && sourceIsSwf) {
        if (element && element !== event.relatedTarget && !_containedBy(event.relatedTarget, element)) {
          _fireMouseEvent(_extend({}, event, {
            type: "mouseleave",
            bubbles: false,
            cancelable: false
          }));
        }
        _fireMouseEvent(_extend({}, event, {
          type: "mouseout"
        }));
      }
      break;

     case "_mousedown":
      _addClass(element, _globalConfig.activeClass);
      if (_globalConfig.bubbleEvents === true && sourceIsSwf) {
        _fireMouseEvent(_extend({}, event, {
          type: event.type.slice(1)
        }));
      }
      break;

     case "_mouseup":
      _removeClass(element, _globalConfig.activeClass);
      if (_globalConfig.bubbleEvents === true && sourceIsSwf) {
        _fireMouseEvent(_extend({}, event, {
          type: event.type.slice(1)
        }));
      }
      break;

     case "_click":
      _copyTarget = null;
      if (_globalConfig.bubbleEvents === true && sourceIsSwf) {
        _fireMouseEvent(_extend({}, event, {
          type: event.type.slice(1)
        }));
      }
      break;

     case "_mousemove":
      if (_globalConfig.bubbleEvents === true && sourceIsSwf) {
        _fireMouseEvent(_extend({}, event, {
          type: event.type.slice(1)
        }));
      }
      break;
    }
    if (/^_(?:click|mouse(?:over|out|down|up|move))$/.test(event.type)) {
      return true;
    }
  };
  /**
 * Dispatch a synthetic MouseEvent.
 *
 * @returns `undefined`
 * @private
 */
  var _fireMouseEvent = function(event) {
    if (!(event && typeof event.type === "string" && event)) {
      return;
    }
    var e, target = event.target || null, doc = target && target.ownerDocument || _document, defaults = {
      view: doc.defaultView || _window,
      canBubble: true,
      cancelable: true,
      detail: event.type === "click" ? 1 : 0,
      button: typeof event.which === "number" ? event.which - 1 : typeof event.button === "number" ? event.button : doc.createEvent ? 0 : 1
    }, args = _extend(defaults, event);
    if (!target) {
      return;
    }
    if (doc.createEvent && target.dispatchEvent) {
      args = [ args.type, args.canBubble, args.cancelable, args.view, args.detail, args.screenX, args.screenY, args.clientX, args.clientY, args.ctrlKey, args.altKey, args.shiftKey, args.metaKey, args.button, args.relatedTarget ];
      e = doc.createEvent("MouseEvents");
      if (e.initMouseEvent) {
        e.initMouseEvent.apply(e, args);
        e._source = "js";
        target.dispatchEvent(e);
      }
    }
  };
  /**
 * Create the HTML bridge element to embed the Flash object into.
 * @private
 */
  var _createHtmlBridge = function() {
    var container = _document.createElement("div");
    container.id = _globalConfig.containerId;
    container.className = _globalConfig.containerClass;
    container.style.position = "absolute";
    container.style.left = "0px";
    container.style.top = "-9999px";
    container.style.width = "1px";
    container.style.height = "1px";
    container.style.zIndex = "" + _getSafeZIndex(_globalConfig.zIndex);
    return container;
  };
  /**
 * Get the HTML element container that wraps the Flash bridge object/element.
 * @private
 */
  var _getHtmlBridge = function(flashBridge) {
    var htmlBridge = flashBridge && flashBridge.parentNode;
    while (htmlBridge && htmlBridge.nodeName === "OBJECT" && htmlBridge.parentNode) {
      htmlBridge = htmlBridge.parentNode;
    }
    return htmlBridge || null;
  };
  /**
 * Create the SWF object.
 *
 * @returns The SWF object reference.
 * @private
 */
  var _embedSwf = function() {
    var len, flashBridge = _flashState.bridge, container = _getHtmlBridge(flashBridge);
    if (!flashBridge) {
      var allowScriptAccess = _determineScriptAccess(_window.location.host, _globalConfig);
      var allowNetworking = allowScriptAccess === "never" ? "none" : "all";
      var flashvars = _vars(_globalConfig);
      var swfUrl = _globalConfig.swfPath + _cacheBust(_globalConfig.swfPath, _globalConfig);
      container = _createHtmlBridge();
      var divToBeReplaced = _document.createElement("div");
      container.appendChild(divToBeReplaced);
      _document.body.appendChild(container);
      var tmpDiv = _document.createElement("div");
      var oldIE = _flashState.pluginType === "activex";
      tmpDiv.innerHTML = '<object id="' + _globalConfig.swfObjectId + '" name="' + _globalConfig.swfObjectId + '" ' + 'width="100%" height="100%" ' + (oldIE ? 'classid="clsid:d27cdb6e-ae6d-11cf-96b8-444553540000"' : 'type="application/x-shockwave-flash" data="' + swfUrl + '"') + ">" + (oldIE ? '<param name="movie" value="' + swfUrl + '"/>' : "") + '<param name="allowScriptAccess" value="' + allowScriptAccess + '"/>' + '<param name="allowNetworking" value="' + allowNetworking + '"/>' + '<param name="menu" value="false"/>' + '<param name="wmode" value="transparent"/>' + '<param name="flashvars" value="' + flashvars + '"/>' + "</object>";
      flashBridge = tmpDiv.firstChild;
      tmpDiv = null;
      _unwrap(flashBridge).ZeroClipboard = ZeroClipboard;
      container.replaceChild(flashBridge, divToBeReplaced);
    }
    if (!flashBridge) {
      flashBridge = _document[_globalConfig.swfObjectId];
      if (flashBridge && (len = flashBridge.length)) {
        flashBridge = flashBridge[len - 1];
      }
      if (!flashBridge && container) {
        flashBridge = container.firstChild;
      }
    }
    _flashState.bridge = flashBridge || null;
    return flashBridge;
  };
  /**
 * Destroy the SWF object.
 * @private
 */
  var _unembedSwf = function() {
    var flashBridge = _flashState.bridge;
    if (flashBridge) {
      var htmlBridge = _getHtmlBridge(flashBridge);
      if (htmlBridge) {
        if (_flashState.pluginType === "activex" && "readyState" in flashBridge) {
          flashBridge.style.display = "none";
          (function removeSwfFromIE() {
            if (flashBridge.readyState === 4) {
              for (var prop in flashBridge) {
                if (typeof flashBridge[prop] === "function") {
                  flashBridge[prop] = null;
                }
              }
              if (flashBridge.parentNode) {
                flashBridge.parentNode.removeChild(flashBridge);
              }
              if (htmlBridge.parentNode) {
                htmlBridge.parentNode.removeChild(htmlBridge);
              }
            } else {
              _setTimeout(removeSwfFromIE, 10);
            }
          })();
        } else {
          if (flashBridge.parentNode) {
            flashBridge.parentNode.removeChild(flashBridge);
          }
          if (htmlBridge.parentNode) {
            htmlBridge.parentNode.removeChild(htmlBridge);
          }
        }
      }
      _flashState.ready = null;
      _flashState.bridge = null;
      _flashState.deactivated = null;
    }
  };
  /**
 * Map the data format names of the "clipData" to Flash-friendly names.
 *
 * @returns A new transformed object.
 * @private
 */
  var _mapClipDataToFlash = function(clipData) {
    var newClipData = {}, formatMap = {};
    if (!(typeof clipData === "object" && clipData)) {
      return;
    }
    for (var dataFormat in clipData) {
      if (dataFormat && _hasOwn.call(clipData, dataFormat) && typeof clipData[dataFormat] === "string" && clipData[dataFormat]) {
        switch (dataFormat.toLowerCase()) {
         case "text/plain":
         case "text":
         case "air:text":
         case "flash:text":
          newClipData.text = clipData[dataFormat];
          formatMap.text = dataFormat;
          break;

         case "text/html":
         case "html":
         case "air:html":
         case "flash:html":
          newClipData.html = clipData[dataFormat];
          formatMap.html = dataFormat;
          break;

         case "application/rtf":
         case "text/rtf":
         case "rtf":
         case "richtext":
         case "air:rtf":
         case "flash:rtf":
          newClipData.rtf = clipData[dataFormat];
          formatMap.rtf = dataFormat;
          break;

         default:
          break;
        }
      }
    }
    return {
      data: newClipData,
      formatMap: formatMap
    };
  };
  /**
 * Map the data format names from Flash-friendly names back to their original "clipData" names (via a format mapping).
 *
 * @returns A new transformed object.
 * @private
 */
  var _mapClipResultsFromFlash = function(clipResults, formatMap) {
    if (!(typeof clipResults === "object" && clipResults && typeof formatMap === "object" && formatMap)) {
      return clipResults;
    }
    var newResults = {};
    for (var prop in clipResults) {
      if (_hasOwn.call(clipResults, prop)) {
        if (prop !== "success" && prop !== "data") {
          newResults[prop] = clipResults[prop];
          continue;
        }
        newResults[prop] = {};
        var tmpHash = clipResults[prop];
        for (var dataFormat in tmpHash) {
          if (dataFormat && _hasOwn.call(tmpHash, dataFormat) && _hasOwn.call(formatMap, dataFormat)) {
            newResults[prop][formatMap[dataFormat]] = tmpHash[dataFormat];
          }
        }
      }
    }
    return newResults;
  };
  /**
 * Will look at a path, and will create a "?noCache={time}" or "&noCache={time}"
 * query param string to return. Does NOT append that string to the original path.
 * This is useful because ExternalInterface often breaks when a Flash SWF is cached.
 *
 * @returns The `noCache` query param with necessary "?"/"&" prefix.
 * @private
 */
  var _cacheBust = function(path, options) {
    var cacheBust = options == null || options && options.cacheBust === true;
    if (cacheBust) {
      return (path.indexOf("?") === -1 ? "?" : "&") + "noCache=" + _now();
    } else {
      return "";
    }
  };
  /**
 * Creates a query string for the FlashVars param.
 * Does NOT include the cache-busting query param.
 *
 * @returns FlashVars query string
 * @private
 */
  var _vars = function(options) {
    var i, len, domain, domains, str = "", trustedOriginsExpanded = [];
    if (options.trustedDomains) {
      if (typeof options.trustedDomains === "string") {
        domains = [ options.trustedDomains ];
      } else if (typeof options.trustedDomains === "object" && "length" in options.trustedDomains) {
        domains = options.trustedDomains;
      }
    }
    if (domains && domains.length) {
      for (i = 0, len = domains.length; i < len; i++) {
        if (_hasOwn.call(domains, i) && domains[i] && typeof domains[i] === "string") {
          domain = _extractDomain(domains[i]);
          if (!domain) {
            continue;
          }
          if (domain === "*") {
            trustedOriginsExpanded.length = 0;
            trustedOriginsExpanded.push(domain);
            break;
          }
          trustedOriginsExpanded.push.apply(trustedOriginsExpanded, [ domain, "//" + domain, _window.location.protocol + "//" + domain ]);
        }
      }
    }
    if (trustedOriginsExpanded.length) {
      str += "trustedOrigins=" + _encodeURIComponent(trustedOriginsExpanded.join(","));
    }
    if (options.forceEnhancedClipboard === true) {
      str += (str ? "&" : "") + "forceEnhancedClipboard=true";
    }
    if (typeof options.swfObjectId === "string" && options.swfObjectId) {
      str += (str ? "&" : "") + "swfObjectId=" + _encodeURIComponent(options.swfObjectId);
    }
    return str;
  };
  /**
 * Extract the domain (e.g. "github.com") from an origin (e.g. "https://github.com") or
 * URL (e.g. "https://github.com/zeroclipboard/zeroclipboard/").
 *
 * @returns the domain
 * @private
 */
  var _extractDomain = function(originOrUrl) {
    if (originOrUrl == null || originOrUrl === "") {
      return null;
    }
    originOrUrl = originOrUrl.replace(/^\s+|\s+$/g, "");
    if (originOrUrl === "") {
      return null;
    }
    var protocolIndex = originOrUrl.indexOf("//");
    originOrUrl = protocolIndex === -1 ? originOrUrl : originOrUrl.slice(protocolIndex + 2);
    var pathIndex = originOrUrl.indexOf("/");
    originOrUrl = pathIndex === -1 ? originOrUrl : protocolIndex === -1 || pathIndex === 0 ? null : originOrUrl.slice(0, pathIndex);
    if (originOrUrl && originOrUrl.slice(-4).toLowerCase() === ".swf") {
      return null;
    }
    return originOrUrl || null;
  };
  /**
 * Set `allowScriptAccess` based on `trustedDomains` and `window.location.host` vs. `swfPath`.
 *
 * @returns The appropriate script access level.
 * @private
 */
  var _determineScriptAccess = function() {
    var _extractAllDomains = function(origins) {
      var i, len, tmp, resultsArray = [];
      if (typeof origins === "string") {
        origins = [ origins ];
      }
      if (!(typeof origins === "object" && origins && typeof origins.length === "number")) {
        return resultsArray;
      }
      for (i = 0, len = origins.length; i < len; i++) {
        if (_hasOwn.call(origins, i) && (tmp = _extractDomain(origins[i]))) {
          if (tmp === "*") {
            resultsArray.length = 0;
            resultsArray.push("*");
            break;
          }
          if (resultsArray.indexOf(tmp) === -1) {
            resultsArray.push(tmp);
          }
        }
      }
      return resultsArray;
    };
    return function(currentDomain, configOptions) {
      var swfDomain = _extractDomain(configOptions.swfPath);
      if (swfDomain === null) {
        swfDomain = currentDomain;
      }
      var trustedDomains = _extractAllDomains(configOptions.trustedDomains);
      var len = trustedDomains.length;
      if (len > 0) {
        if (len === 1 && trustedDomains[0] === "*") {
          return "always";
        }
        if (trustedDomains.indexOf(currentDomain) !== -1) {
          if (len === 1 && currentDomain === swfDomain) {
            return "sameDomain";
          }
          return "always";
        }
      }
      return "never";
    };
  }();
  /**
 * Get the currently active/focused DOM element.
 *
 * @returns the currently active/focused element, or `null`
 * @private
 */
  var _safeActiveElement = function() {
    try {
      return _document.activeElement;
    } catch (err) {
      return null;
    }
  };
  /**
 * Add a class to an element, if it doesn't already have it.
 *
 * @returns The element, with its new class added.
 * @private
 */
  var _addClass = function(element, value) {
    if (!element || element.nodeType !== 1) {
      return element;
    }
    if (element.classList) {
      if (!element.classList.contains(value)) {
        element.classList.add(value);
      }
      return element;
    }
    if (value && typeof value === "string") {
      var classNames = (value || "").split(/\s+/);
      if (element.nodeType === 1) {
        if (!element.className) {
          element.className = value;
        } else {
          var className = " " + element.className + " ", setClass = element.className;
          for (var c = 0, cl = classNames.length; c < cl; c++) {
            if (className.indexOf(" " + classNames[c] + " ") < 0) {
              setClass += " " + classNames[c];
            }
          }
          element.className = setClass.replace(/^\s+|\s+$/g, "");
        }
      }
    }
    return element;
  };
  /**
 * Remove a class from an element, if it has it.
 *
 * @returns The element, with its class removed.
 * @private
 */
  var _removeClass = function(element, value) {
    if (!element || element.nodeType !== 1) {
      return element;
    }
    if (element.classList) {
      if (element.classList.contains(value)) {
        element.classList.remove(value);
      }
      return element;
    }
    if (typeof value === "string" && value) {
      var classNames = value.split(/\s+/);
      if (element.nodeType === 1 && element.className) {
        var className = (" " + element.className + " ").replace(/[\n\t]/g, " ");
        for (var c = 0, cl = classNames.length; c < cl; c++) {
          className = className.replace(" " + classNames[c] + " ", " ");
        }
        element.className = className.replace(/^\s+|\s+$/g, "");
      }
    }
    return element;
  };
  /**
 * Attempt to interpret the element's CSS styling. If `prop` is `"cursor"`,
 * then we assume that it should be a hand ("pointer") cursor if the element
 * is an anchor element ("a" tag).
 *
 * @returns The computed style property.
 * @private
 */
  var _getStyle = function(el, prop) {
    var value = _window.getComputedStyle(el, null).getPropertyValue(prop);
    if (prop === "cursor") {
      if (!value || value === "auto") {
        if (el.nodeName === "A") {
          return "pointer";
        }
      }
    }
    return value;
  };
  /**
 * Get the zoom factor of the browser. Always returns `1.0`, except at
 * non-default zoom levels in IE<8 and some older versions of WebKit.
 *
 * @returns Floating unit percentage of the zoom factor (e.g. 150% = `1.5`).
 * @private
 */
  var _getZoomFactor = function() {
    var rect, physicalWidth, logicalWidth, zoomFactor = 1;
    if (typeof _document.body.getBoundingClientRect === "function") {
      rect = _document.body.getBoundingClientRect();
      physicalWidth = rect.right - rect.left;
      logicalWidth = _document.body.offsetWidth;
      zoomFactor = _round(physicalWidth / logicalWidth * 100) / 100;
    }
    return zoomFactor;
  };
  /**
 * Get the DOM positioning info of an element.
 *
 * @returns Object containing the element's position, width, and height.
 * @private
 */
  var _getDOMObjectPosition = function(obj) {
    var info = {
      left: 0,
      top: 0,
      width: 0,
      height: 0
    };
    if (obj.getBoundingClientRect) {
      var rect = obj.getBoundingClientRect();
      var pageXOffset, pageYOffset, zoomFactor;
      if ("pageXOffset" in _window && "pageYOffset" in _window) {
        pageXOffset = _window.pageXOffset;
        pageYOffset = _window.pageYOffset;
      } else {
        zoomFactor = _getZoomFactor();
        pageXOffset = _round(_document.documentElement.scrollLeft / zoomFactor);
        pageYOffset = _round(_document.documentElement.scrollTop / zoomFactor);
      }
      var leftBorderWidth = _document.documentElement.clientLeft || 0;
      var topBorderWidth = _document.documentElement.clientTop || 0;
      info.left = rect.left + pageXOffset - leftBorderWidth;
      info.top = rect.top + pageYOffset - topBorderWidth;
      info.width = "width" in rect ? rect.width : rect.right - rect.left;
      info.height = "height" in rect ? rect.height : rect.bottom - rect.top;
    }
    return info;
  };
  /**
 * Reposition the Flash object to cover the currently activated element.
 *
 * @returns `undefined`
 * @private
 */
  var _reposition = function() {
    var htmlBridge;
    if (_currentElement && (htmlBridge = _getHtmlBridge(_flashState.bridge))) {
      var pos = _getDOMObjectPosition(_currentElement);
      _extend(htmlBridge.style, {
        width: pos.width + "px",
        height: pos.height + "px",
        top: pos.top + "px",
        left: pos.left + "px",
        zIndex: "" + _getSafeZIndex(_globalConfig.zIndex)
      });
    }
  };
  /**
 * Sends a signal to the Flash object to display the hand cursor if `true`.
 *
 * @returns `undefined`
 * @private
 */
  var _setHandCursor = function(enabled) {
    if (_flashState.ready === true) {
      if (_flashState.bridge && typeof _flashState.bridge.setHandCursor === "function") {
        _flashState.bridge.setHandCursor(enabled);
      } else {
        _flashState.ready = false;
      }
    }
  };
  /**
 * Get a safe value for `zIndex`
 *
 * @returns an integer, or "auto"
 * @private
 */
  var _getSafeZIndex = function(val) {
    if (/^(?:auto|inherit)$/.test(val)) {
      return val;
    }
    var zIndex;
    if (typeof val === "number" && !_isNaN(val)) {
      zIndex = val;
    } else if (typeof val === "string") {
      zIndex = _getSafeZIndex(_parseInt(val, 10));
    }
    return typeof zIndex === "number" ? zIndex : "auto";
  };
  /**
 * Detect the Flash Player status, version, and plugin type.
 *
 * @see {@link https://code.google.com/p/doctype-mirror/wiki/ArticleDetectFlash#The_code}
 * @see {@link http://stackoverflow.com/questions/12866060/detecting-pepper-ppapi-flash-with-javascript}
 *
 * @returns `undefined`
 * @private
 */
  var _detectFlashSupport = function(ActiveXObject) {
    var plugin, ax, mimeType, hasFlash = false, isActiveX = false, isPPAPI = false, flashVersion = "";
    /**
   * Derived from Apple's suggested sniffer.
   * @param {String} desc e.g. "Shockwave Flash 7.0 r61"
   * @returns {String} "7.0.61"
   * @private
   */
    function parseFlashVersion(desc) {
      var matches = desc.match(/[\d]+/g);
      matches.length = 3;
      return matches.join(".");
    }
    function isPepperFlash(flashPlayerFileName) {
      return !!flashPlayerFileName && (flashPlayerFileName = flashPlayerFileName.toLowerCase()) && (/^(pepflashplayer\.dll|libpepflashplayer\.so|pepperflashplayer\.plugin)$/.test(flashPlayerFileName) || flashPlayerFileName.slice(-13) === "chrome.plugin");
    }
    function inspectPlugin(plugin) {
      if (plugin) {
        hasFlash = true;
        if (plugin.version) {
          flashVersion = parseFlashVersion(plugin.version);
        }
        if (!flashVersion && plugin.description) {
          flashVersion = parseFlashVersion(plugin.description);
        }
        if (plugin.filename) {
          isPPAPI = isPepperFlash(plugin.filename);
        }
      }
    }
    if (_navigator.plugins && _navigator.plugins.length) {
      plugin = _navigator.plugins["Shockwave Flash"];
      inspectPlugin(plugin);
      if (_navigator.plugins["Shockwave Flash 2.0"]) {
        hasFlash = true;
        flashVersion = "2.0.0.11";
      }
    } else if (_navigator.mimeTypes && _navigator.mimeTypes.length) {
      mimeType = _navigator.mimeTypes["application/x-shockwave-flash"];
      plugin = mimeType && mimeType.enabledPlugin;
      inspectPlugin(plugin);
    } else if (typeof ActiveXObject !== "undefined") {
      isActiveX = true;
      try {
        ax = new ActiveXObject("ShockwaveFlash.ShockwaveFlash.7");
        hasFlash = true;
        flashVersion = parseFlashVersion(ax.GetVariable("$version"));
      } catch (e1) {
        try {
          ax = new ActiveXObject("ShockwaveFlash.ShockwaveFlash.6");
          hasFlash = true;
          flashVersion = "6.0.21";
        } catch (e2) {
          try {
            ax = new ActiveXObject("ShockwaveFlash.ShockwaveFlash");
            hasFlash = true;
            flashVersion = parseFlashVersion(ax.GetVariable("$version"));
          } catch (e3) {
            isActiveX = false;
          }
        }
      }
    }
    _flashState.disabled = hasFlash !== true;
    _flashState.outdated = flashVersion && _parseFloat(flashVersion) < _parseFloat(_minimumFlashVersion);
    _flashState.version = flashVersion || "0.0.0";
    _flashState.pluginType = isPPAPI ? "pepper" : isActiveX ? "activex" : hasFlash ? "netscape" : "unknown";
  };
  /**
 * Invoke the Flash detection algorithms immediately upon inclusion so we're not waiting later.
 */
  _detectFlashSupport(_ActiveXObject);
  /**
 * A shell constructor for `ZeroClipboard` client instances.
 *
 * @constructor
 */
  var ZeroClipboard = function() {
    if (!(this instanceof ZeroClipboard)) {
      return new ZeroClipboard();
    }
    if (typeof ZeroClipboard._createClient === "function") {
      ZeroClipboard._createClient.apply(this, _args(arguments));
    }
  };
  /**
 * The ZeroClipboard library's version number.
 *
 * @static
 * @readonly
 * @property {string}
 */
  /*_defineProperty(ZeroClipboard, "version", {
    value: "2.1.6",
    writable: false,
    configurable: true,
    enumerable: true
  });*/
  /**
 * Update or get a copy of the ZeroClipboard global configuration.
 * Returns a copy of the current/updated configuration.
 *
 * @returns Object
 * @static
 */
  ZeroClipboard.config = function() {
    return _config.apply(this, _args(arguments));
  };
  /**
 * Diagnostic method that describes the state of the browser, Flash Player, and ZeroClipboard.
 *
 * @returns Object
 * @static
 */
  ZeroClipboard.state = function() {
    return _state.apply(this, _args(arguments));
  };
  /**
 * Check if Flash is unusable for any reason: disabled, outdated, deactivated, etc.
 *
 * @returns Boolean
 * @static
 */
  ZeroClipboard.isFlashUnusable = function() {
    return _isFlashUnusable.apply(this, _args(arguments));
  };
  /**
 * Register an event listener.
 *
 * @returns `ZeroClipboard`
 * @static
 */
  ZeroClipboard.on = function() {
    return _on.apply(this, _args(arguments));
  };
  /**
 * Unregister an event listener.
 * If no `listener` function/object is provided, it will unregister all listeners for the provided `eventType`.
 * If no `eventType` is provided, it will unregister all listeners for every event type.
 *
 * @returns `ZeroClipboard`
 * @static
 */
  ZeroClipboard.off = function() {
    return _off.apply(this, _args(arguments));
  };
  /**
 * Retrieve event listeners for an `eventType`.
 * If no `eventType` is provided, it will retrieve all listeners for every event type.
 *
 * @returns array of listeners for the `eventType`; if no `eventType`, then a map/hash object of listeners for all event types; or `null`
 */
  ZeroClipboard.handlers = function() {
    return _listeners.apply(this, _args(arguments));
  };
  /**
 * Event emission receiver from the Flash object, forwarding to any registered JavaScript event listeners.
 *
 * @returns For the "copy" event, returns the Flash-friendly "clipData" object; otherwise `undefined`.
 * @static
 */
  ZeroClipboard.emit = function() {
    return _emit.apply(this, _args(arguments));
  };
  /**
 * Create and embed the Flash object.
 *
 * @returns The Flash object
 * @static
 */
  ZeroClipboard.create = function() {
    return _create.apply(this, _args(arguments));
  };
  /**
 * Self-destruct and clean up everything, including the embedded Flash object.
 *
 * @returns `undefined`
 * @static
 */
  ZeroClipboard.destroy = function() {
    return _destroy.apply(this, _args(arguments));
  };
  /**
 * Set the pending data for clipboard injection.
 *
 * @returns `undefined`
 * @static
 */
  ZeroClipboard.setData = function() {
    return _setData.apply(this, _args(arguments));
  };
  /**
 * Clear the pending data for clipboard injection.
 * If no `format` is provided, all pending data formats will be cleared.
 *
 * @returns `undefined`
 * @static
 */
  ZeroClipboard.clearData = function() {
    return _clearData.apply(this, _args(arguments));
  };
  /**
 * Get a copy of the pending data for clipboard injection.
 * If no `format` is provided, a copy of ALL pending data formats will be returned.
 *
 * @returns `String` or `Object`
 * @static
 */
  ZeroClipboard.getData = function() {
    return _getData.apply(this, _args(arguments));
  };
  /**
 * Sets the current HTML object that the Flash object should overlay. This will put the global
 * Flash object on top of the current element; depending on the setup, this may also set the
 * pending clipboard text data as well as the Flash object's wrapping element's title attribute
 * based on the underlying HTML element and ZeroClipboard configuration.
 *
 * @returns `undefined`
 * @static
 */
  ZeroClipboard.focus = ZeroClipboard.activate = function() {
    return _focus.apply(this, _args(arguments));
  };
  /**
 * Un-overlays the Flash object. This will put the global Flash object off-screen; depending on
 * the setup, this may also unset the Flash object's wrapping element's title attribute based on
 * the underlying HTML element and ZeroClipboard configuration.
 *
 * @returns `undefined`
 * @static
 */
  ZeroClipboard.blur = ZeroClipboard.deactivate = function() {
    return _blur.apply(this, _args(arguments));
  };
  /**
 * Returns the currently focused/"activated" HTML element that the Flash object is wrapping.
 *
 * @returns `HTMLElement` or `null`
 * @static
 */
  ZeroClipboard.activeElement = function() {
    return _activeElement.apply(this, _args(arguments));
  };
  /**
 * Keep track of the ZeroClipboard client instance counter.
 */
  var _clientIdCounter = 0;
  /**
 * Keep track of the state of the client instances.
 *
 * Entry structure:
 *   _clientMeta[client.id] = {
 *     instance: client,
 *     elements: [],
 *     handlers: {}
 *   };
 */
  var _clientMeta = {};
  /**
 * Keep track of the ZeroClipboard clipped elements counter.
 */
  var _elementIdCounter = 0;
  /**
 * Keep track of the state of the clipped element relationships to clients.
 *
 * Entry structure:
 *   _elementMeta[element.zcClippingId] = [client1.id, client2.id];
 */
  var _elementMeta = {};
  /**
 * Keep track of the state of the mouse event handlers for clipped elements.
 *
 * Entry structure:
 *   _mouseHandlers[element.zcClippingId] = {
 *     mouseover:  function(event) {},
 *     mouseout:   function(event) {},
 *     mouseenter: function(event) {},
 *     mouseleave: function(event) {},
 *     mousemove:  function(event) {}
 *   };
 */
  var _mouseHandlers = {};
  /**
 * Extending the ZeroClipboard configuration defaults for the Client module.
 */
  _extend(_globalConfig, {
    autoActivate: true
  });
  /**
 * The real constructor for `ZeroClipboard` client instances.
 * @private
 */
  var _clientConstructor = function(elements) {
    var client = this;
    client.id = "" + _clientIdCounter++;
    _clientMeta[client.id] = {
      instance: client,
      elements: [],
      handlers: {}
    };
    if (elements) {
      client.clip(elements);
    }
    ZeroClipboard.on("*", function(event) {
      return client.emit(event);
    });
    ZeroClipboard.on("destroy", function() {
      client.destroy();
    });
    ZeroClipboard.create();
  };
  /**
 * The underlying implementation of `ZeroClipboard.Client.prototype.on`.
 * @private
 */
  var _clientOn = function(eventType, listener) {
    var i, len, events, added = {}, handlers = _clientMeta[this.id] && _clientMeta[this.id].handlers;
    if (typeof eventType === "string" && eventType) {
      events = eventType.toLowerCase().split(/\s+/);
    } else if (typeof eventType === "object" && eventType && typeof listener === "undefined") {
      for (i in eventType) {
        if (_hasOwn.call(eventType, i) && typeof i === "string" && i && typeof eventType[i] === "function") {
          this.on(i, eventType[i]);
        }
      }
    }
    if (events && events.length) {
      for (i = 0, len = events.length; i < len; i++) {
        eventType = events[i].replace(/^on/, "");
        added[eventType] = true;
        if (!handlers[eventType]) {
          handlers[eventType] = [];
        }
        handlers[eventType].push(listener);
      }
      if (added.ready && _flashState.ready) {
        this.emit({
          type: "ready",
          client: this
        });
      }
      if (added.error) {
        var errorTypes = [ "disabled", "outdated", "unavailable", "deactivated", "overdue" ];
        for (i = 0, len = errorTypes.length; i < len; i++) {
          if (_flashState[errorTypes[i]]) {
            this.emit({
              type: "error",
              name: "flash-" + errorTypes[i],
              client: this
            });
            break;
          }
        }
      }
    }
    return this;
  };
  /**
 * The underlying implementation of `ZeroClipboard.Client.prototype.off`.
 * @private
 */
  var _clientOff = function(eventType, listener) {
    var i, len, foundIndex, events, perEventHandlers, handlers = _clientMeta[this.id] && _clientMeta[this.id].handlers;
    if (arguments.length === 0) {
      events = _keys(handlers);
    } else if (typeof eventType === "string" && eventType) {
      events = eventType.split(/\s+/);
    } else if (typeof eventType === "object" && eventType && typeof listener === "undefined") {
      for (i in eventType) {
        if (_hasOwn.call(eventType, i) && typeof i === "string" && i && typeof eventType[i] === "function") {
          this.off(i, eventType[i]);
        }
      }
    }
    if (events && events.length) {
      for (i = 0, len = events.length; i < len; i++) {
        eventType = events[i].toLowerCase().replace(/^on/, "");
        perEventHandlers = handlers[eventType];
        if (perEventHandlers && perEventHandlers.length) {
          if (listener) {
            foundIndex = perEventHandlers.indexOf(listener);
            while (foundIndex !== -1) {
              perEventHandlers.splice(foundIndex, 1);
              foundIndex = perEventHandlers.indexOf(listener, foundIndex);
            }
          } else {
            perEventHandlers.length = 0;
          }
        }
      }
    }
    return this;
  };
  /**
 * The underlying implementation of `ZeroClipboard.Client.prototype.handlers`.
 * @private
 */
  var _clientListeners = function(eventType) {
    var copy = null, handlers = _clientMeta[this.id] && _clientMeta[this.id].handlers;
    if (handlers) {
      if (typeof eventType === "string" && eventType) {
        copy = handlers[eventType] ? handlers[eventType].slice(0) : [];
      } else {
        copy = _deepCopy(handlers);
      }
    }
    return copy;
  };
  /**
 * The underlying implementation of `ZeroClipboard.Client.prototype.emit`.
 * @private
 */
  var _clientEmit = function(event) {
    if (_clientShouldEmit.call(this, event)) {
      if (typeof event === "object" && event && typeof event.type === "string" && event.type) {
        event = _extend({}, event);
      }
      var eventCopy = _extend({}, _createEvent(event), {
        client: this
      });
      _clientDispatchCallbacks.call(this, eventCopy);
    }
    return this;
  };
  /**
 * The underlying implementation of `ZeroClipboard.Client.prototype.clip`.
 * @private
 */
  var _clientClip = function(elements) {
    elements = _prepClip(elements);
    for (var i = 0; i < elements.length; i++) {
      if (_hasOwn.call(elements, i) && elements[i] && elements[i].nodeType === 1) {
        if (!elements[i].zcClippingId) {
          elements[i].zcClippingId = "zcClippingId_" + _elementIdCounter++;
          _elementMeta[elements[i].zcClippingId] = [ this.id ];
          if (_globalConfig.autoActivate === true) {
            _addMouseHandlers(elements[i]);
          }
        } else if (_elementMeta[elements[i].zcClippingId].indexOf(this.id) === -1) {
          _elementMeta[elements[i].zcClippingId].push(this.id);
        }
        var clippedElements = _clientMeta[this.id] && _clientMeta[this.id].elements;
        if (clippedElements.indexOf(elements[i]) === -1) {
          clippedElements.push(elements[i]);
        }
      }
    }
    return this;
  };
  /**
 * The underlying implementation of `ZeroClipboard.Client.prototype.unclip`.
 * @private
 */
  var _clientUnclip = function(elements) {
    var meta = _clientMeta[this.id];
    if (!meta) {
      return this;
    }
    var clippedElements = meta.elements;
    var arrayIndex;
    if (typeof elements === "undefined") {
      elements = clippedElements.slice(0);
    } else {
      elements = _prepClip(elements);
    }
    for (var i = elements.length; i--; ) {
      if (_hasOwn.call(elements, i) && elements[i] && elements[i].nodeType === 1) {
        arrayIndex = 0;
        while ((arrayIndex = clippedElements.indexOf(elements[i], arrayIndex)) !== -1) {
          clippedElements.splice(arrayIndex, 1);
        }
        var clientIds = _elementMeta[elements[i].zcClippingId];
        if (clientIds) {
          arrayIndex = 0;
          while ((arrayIndex = clientIds.indexOf(this.id, arrayIndex)) !== -1) {
            clientIds.splice(arrayIndex, 1);
          }
          if (clientIds.length === 0) {
            if (_globalConfig.autoActivate === true) {
              _removeMouseHandlers(elements[i]);
            }
            delete elements[i].zcClippingId;
          }
        }
      }
    }
    return this;
  };
  /**
 * The underlying implementation of `ZeroClipboard.Client.prototype.elements`.
 * @private
 */
  var _clientElements = function() {
    var meta = _clientMeta[this.id];
    return meta && meta.elements ? meta.elements.slice(0) : [];
  };
  /**
 * The underlying implementation of `ZeroClipboard.Client.prototype.destroy`.
 * @private
 */
  var _clientDestroy = function() {
    this.unclip();
    this.off();
    delete _clientMeta[this.id];
  };
  /**
 * Inspect an Event to see if the Client (`this`) should honor it for emission.
 * @private
 */
  var _clientShouldEmit = function(event) {
    if (!(event && event.type)) {
      return false;
    }
    if (event.client && event.client !== this) {
      return false;
    }
    var clippedEls = _clientMeta[this.id] && _clientMeta[this.id].elements;
    var hasClippedEls = !!clippedEls && clippedEls.length > 0;
    var goodTarget = !event.target || hasClippedEls && clippedEls.indexOf(event.target) !== -1;
    var goodRelTarget = event.relatedTarget && hasClippedEls && clippedEls.indexOf(event.relatedTarget) !== -1;
    var goodClient = event.client && event.client === this;
    if (!(goodTarget || goodRelTarget || goodClient)) {
      return false;
    }
    return true;
  };
  /**
 * Handle the actual dispatching of events to a client instance.
 *
 * @returns `this`
 * @private
 */
  var _clientDispatchCallbacks = function(event) {
    if (!(typeof event === "object" && event && event.type)) {
      return;
    }
    var async = _shouldPerformAsync(event);
    var wildcardTypeHandlers = _clientMeta[this.id] && _clientMeta[this.id].handlers["*"] || [];
    var specificTypeHandlers = _clientMeta[this.id] && _clientMeta[this.id].handlers[event.type] || [];
    var handlers = wildcardTypeHandlers.concat(specificTypeHandlers);
    if (handlers && handlers.length) {
      var i, len, func, context, eventCopy, originalContext = this;
      for (i = 0, len = handlers.length; i < len; i++) {
        func = handlers[i];
        context = originalContext;
        if (typeof func === "string" && typeof _window[func] === "function") {
          func = _window[func];
        }
        if (typeof func === "object" && func && typeof func.handleEvent === "function") {
          context = func;
          func = func.handleEvent;
        }
        if (typeof func === "function") {
          eventCopy = _extend({}, event);
          _dispatchCallback(func, context, [ eventCopy ], async);
        }
      }
    }
    return this;
  };
  /**
 * Prepares the elements for clipping/unclipping.
 *
 * @returns An Array of elements.
 * @private
 */
  var _prepClip = function(elements) {
    if (typeof elements === "string") {
      elements = [];
    }
    return typeof elements.length !== "number" ? [ elements ] : elements;
  };
  /**
 * Add a `mouseover` handler function for a clipped element.
 *
 * @returns `undefined`
 * @private
 */
  var _addMouseHandlers = function(element) {
    if (!(element && element.nodeType === 1)) {
      return;
    }
    var _suppressMouseEvents = function(event) {
      if (!(event || (event = _window.event))) {
        return;
      }
      if (event._source !== "js") {
        event.stopImmediatePropagation();
        event.preventDefault();
      }
      delete event._source;
    };
    var _elementMouseOver = function(event) {
      if (!(event || (event = _window.event))) {
        return;
      }
      _suppressMouseEvents(event);
      ZeroClipboard.focus(element);
    };
    element.addEventListener("mouseover", _elementMouseOver, false);
    element.addEventListener("mouseout", _suppressMouseEvents, false);
    element.addEventListener("mouseenter", _suppressMouseEvents, false);
    element.addEventListener("mouseleave", _suppressMouseEvents, false);
    element.addEventListener("mousemove", _suppressMouseEvents, false);
    _mouseHandlers[element.zcClippingId] = {
      mouseover: _elementMouseOver,
      mouseout: _suppressMouseEvents,
      mouseenter: _suppressMouseEvents,
      mouseleave: _suppressMouseEvents,
      mousemove: _suppressMouseEvents
    };
  };
  /**
 * Remove a `mouseover` handler function for a clipped element.
 *
 * @returns `undefined`
 * @private
 */
  var _removeMouseHandlers = function(element) {
    if (!(element && element.nodeType === 1)) {
      return;
    }
    var mouseHandlers = _mouseHandlers[element.zcClippingId];
    if (!(typeof mouseHandlers === "object" && mouseHandlers)) {
      return;
    }
    var key, val, mouseEvents = [ "move", "leave", "enter", "out", "over" ];
    for (var i = 0, len = mouseEvents.length; i < len; i++) {
      key = "mouse" + mouseEvents[i];
      val = mouseHandlers[key];
      if (typeof val === "function") {
        element.removeEventListener(key, val, false);
      }
    }
    delete _mouseHandlers[element.zcClippingId];
  };
  /**
 * Creates a new ZeroClipboard client instance.
 * Optionally, auto-`clip` an element or collection of elements.
 *
 * @constructor
 */
  ZeroClipboard._createClient = function() {
    _clientConstructor.apply(this, _args(arguments));
  };
  /**
 * Register an event listener to the client.
 *
 * @returns `this`
 */
  ZeroClipboard.prototype.on = function() {
    return _clientOn.apply(this, _args(arguments));
  };
  /**
 * Unregister an event handler from the client.
 * If no `listener` function/object is provided, it will unregister all handlers for the provided `eventType`.
 * If no `eventType` is provided, it will unregister all handlers for every event type.
 *
 * @returns `this`
 */
  ZeroClipboard.prototype.off = function() {
    return _clientOff.apply(this, _args(arguments));
  };
  /**
 * Retrieve event listeners for an `eventType` from the client.
 * If no `eventType` is provided, it will retrieve all listeners for every event type.
 *
 * @returns array of listeners for the `eventType`; if no `eventType`, then a map/hash object of listeners for all event types; or `null`
 */
  ZeroClipboard.prototype.handlers = function() {
    return _clientListeners.apply(this, _args(arguments));
  };
  /**
 * Event emission receiver from the Flash object for this client's registered JavaScript event listeners.
 *
 * @returns For the "copy" event, returns the Flash-friendly "clipData" object; otherwise `undefined`.
 */
  ZeroClipboard.prototype.emit = function() {
    return _clientEmit.apply(this, _args(arguments));
  };
  /**
 * Register clipboard actions for new element(s) to the client.
 *
 * @returns `this`
 */
  ZeroClipboard.prototype.clip = function() {
    return _clientClip.apply(this, _args(arguments));
  };
  /**
 * Unregister the clipboard actions of previously registered element(s) on the page.
 * If no elements are provided, ALL registered elements will be unregistered.
 *
 * @returns `this`
 */
  ZeroClipboard.prototype.unclip = function() {
    return _clientUnclip.apply(this, _args(arguments));
  };
  /**
 * Get all of the elements to which this client is clipped.
 *
 * @returns array of clipped elements
 */
  ZeroClipboard.prototype.elements = function() {
    return _clientElements.apply(this, _args(arguments));
  };
  /**
 * Self-destruct and clean up everything for a single client.
 * This will NOT destroy the embedded Flash object.
 *
 * @returns `undefined`
 */
  ZeroClipboard.prototype.destroy = function() {
    return _clientDestroy.apply(this, _args(arguments));
  };
  /**
 * Stores the pending plain text to inject into the clipboard.
 *
 * @returns `this`
 */
  ZeroClipboard.prototype.setText = function(text) {
    ZeroClipboard.setData("text/plain", text);
    return this;
  };
  /**
 * Stores the pending HTML text to inject into the clipboard.
 *
 * @returns `this`
 */
  ZeroClipboard.prototype.setHtml = function(html) {
    ZeroClipboard.setData("text/html", html);
    return this;
  };
  /**
 * Stores the pending rich text (RTF) to inject into the clipboard.
 *
 * @returns `this`
 */
  ZeroClipboard.prototype.setRichText = function(richText) {
    ZeroClipboard.setData("application/rtf", richText);
    return this;
  };
  /**
 * Stores the pending data to inject into the clipboard.
 *
 * @returns `this`
 */
  ZeroClipboard.prototype.setData = function() {
    ZeroClipboard.setData.apply(this, _args(arguments));
    return this;
  };
  /**
 * Clears the pending data to inject into the clipboard.
 * If no `format` is provided, all pending data formats will be cleared.
 *
 * @returns `this`
 */
  ZeroClipboard.prototype.clearData = function() {
    ZeroClipboard.clearData.apply(this, _args(arguments));
    return this;
  };
  /**
 * Gets a copy of the pending data to inject into the clipboard.
 * If no `format` is provided, a copy of ALL pending data formats will be returned.
 *
 * @returns `String` or `Object`
 */
  ZeroClipboard.prototype.getData = function() {
    return ZeroClipboard.getData.apply(this, _args(arguments));
  };
  /*if (typeof define === "function" && define.amd) {
    define(function() {
      return ZeroClipboard;
    });
  } else*/ if (typeof module === "object" && module && typeof module.exports === "object" && module.exports) {
    module.exports = ZeroClipboard;
  } else {
    window.ZeroClipboard = ZeroClipboard;
  }
})(function() {
  return this || window;
}());
/*jslint node: true */
/*global ZeroClipboard */

(function(window, angular, undefined) {
  'use strict';

  angular.module('ngClipboard', []).
    provider('ngClip', function() {
      var self = this;
      this.path = '/vmf/m/components/zeroClipboard/swf/ZeroClipboard.swf';
      return {
        setPath: function(newPath) {
         self.path = newPath;
        },
        setConfig: function(config) {
          self.config = config;
        },
        $get: function() {
          return {
            path: self.path,
            config: self.config
          };
        }
      };
    }).
    run(['ngClip', function(ngClip) {
      var config = {
        swfPath: ngClip.path,
        trustedDomains: ["*"],
        allowScriptAccess: "always",
        forceHandCursor: true,
      };
      ZeroClipboard.config(angular.extend(config,ngClip.config || {}));
    }]).
    directive('clipCopy', ['ngClip', function (ngClip) {
      return {
        scope: {
          clipCopy: '&',
          clipClick: '&',
          clipClickFallback: '&'
        },
        restrict: 'A',
        link: function (scope, element, attrs) {
          // Bind a fallback function if flash is unavailable
          if (ZeroClipboard.isFlashUnusable()) {
            element.bind('click', function($event) {
              // Execute the expression with local variables `$event` and `copy`
              scope.$apply(scope.clipClickFallback({
                $event: $event,
                copy: scope.$eval(scope.clipCopy)
              }));
            });

            return;
          }

          // Create the client object
          var client = new ZeroClipboard(element);
          if (attrs.clipCopy === "") {
            scope.clipCopy = function(scope) {
              return element[0].previousElementSibling.innerText;
            };
          }
          client.on( 'ready', function(readyEvent) {

            client.on('copy', function (event) {
              var clipboard = event.clipboardData;
              clipboard.setData(attrs.clipCopyMimeType || 'text/plain', scope.$eval(scope.clipCopy));
            });

            client.on( 'aftercopy', function(event) {
              if (angular.isDefined(attrs.clipClick)) {
                scope.$apply(scope.clipClick);
              }
            });

            scope.$on('$destroy', function() {
              client.destroy();
            });
          });
        }
      };
    }]);
})(window, window.angular);
